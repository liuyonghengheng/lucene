@startuml

/' diagram meta data start
config=StructureConfiguration;
{
  "projectClassification": {
    "searchMode": "OpenProject", // OpenProject, AllProjects
    "includedProjects": "",
    "pathEndKeywords": "*.impl",
    "isClientPath": "",
    "isClientName": "",
    "isTestPath": "",
    "isTestName": "",
    "isMappingPath": "",
    "isMappingName": "",
    "isDataAccessPath": "",
    "isDataAccessName": "",
    "isDataStructurePath": "",
    "isDataStructureName": "",
    "isInterfaceStructuresPath": "",
    "isInterfaceStructuresName": "",
    "isEntryPointPath": "",
    "isEntryPointName": "",
    "treatFinalFieldsAsMandatory": false
  },
  "graphRestriction": {
    "classPackageExcludeFilter": "",
    "classPackageIncludeFilter": "",
    "classNameExcludeFilter": "",
    "classNameIncludeFilter": "",
    "methodNameExcludeFilter": "",
    "methodNameIncludeFilter": "",
    "removeByInheritance": "", // inheritance/annotation based filtering is done in a second step
    "removeByAnnotation": "",
    "removeByClassPackage": "", // cleanup the graph after inheritance/annotation based filtering is done
    "removeByClassName": "",
    "cutMappings": false,
    "cutEnum": true,
    "cutTests": true,
    "cutClient": true,
    "cutDataAccess": false,
    "cutInterfaceStructures": false,
    "cutDataStructures": false,
    "cutGetterAndSetter": true,
    "cutConstructors": true
  },
  "graphTraversal": {
    "forwardDepth": 6,
    "backwardDepth": 6,
    "classPackageExcludeFilter": "",
    "classPackageIncludeFilter": "",
    "classNameExcludeFilter": "",
    "classNameIncludeFilter": "",
    "methodNameExcludeFilter": "",
    "methodNameIncludeFilter": "",
    "hideMappings": false,
    "hideDataStructures": false,
    "hidePrivateMethods": true,
    "hideInterfaceCalls": true, // indirection: implementation -> interface (is hidden) -> implementation
    "onlyShowApplicationEntryPoints": false, // root node is included
    "useMethodCallsForStructureDiagram": "ForwardOnly" // ForwardOnly, BothDirections, No
  },
  "details": {
    "aggregation": "GroupByClass", // ByClass, GroupByClass, None
    "showClassGenericTypes": true,
    "showMethods": true,
    "showMethodParameterNames": true,
    "showMethodParameterTypes": true,
    "showMethodReturnType": true,
    "showPackageLevels": 2,
    "showDetailedClassStructure": true
  },
  "rootClass": "org.apache.lucene.codecs.Codec",
  "extensionCallbackMethod": "" // qualified.class.name#methodName - signature: public static String method(String)
}
diagram meta data end '/



digraph g {
    rankdir="TB"
    splines=polyline
    

'nodes 
subgraph cluster_1411517106 { 
   	label=apache
	labeljust=l
	fillcolor="#ececec"
	style=filled
   
   subgraph cluster_408512322 { 
   	label=lucene
	labeljust=l
	fillcolor="#d8d8d8"
	style=filled
   
   AbstractBeforeAfterRule1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractBeforeAfterRule</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># after()</TD></TR>
<TR><TD ALIGN="LEFT" >+ apply(s: Statement, d: Description): Statement</TD></TR>
<TR><TD ALIGN="LEFT" ># before()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractMultiTermQueryConstantScoreWrapper536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractMultiTermQueryConstantScoreWrapper&lt;Q extends MultiTermQuery&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   query: Q [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AbstractPagedMutable611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AbstractPagedMutable&lt;T extends AbstractPagedMutable&lt;T&gt;&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bitsPerValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pageMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pageShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   size: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subMutables: Mutable[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># baseRamBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># fillPages()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(minSize: long): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(): T</TD></TR>
<TR><TD ALIGN="LEFT" ># indexInPage(index: long): int</TD></TR>
<TR><TD ALIGN="LEFT" ># lastPageSize(size: long): int</TD></TR>
<TR><TD ALIGN="LEFT" ># newMutable(valueCount: int, bitsPerValue: int): Mutable</TD></TR>
<TR><TD ALIGN="LEFT" ># newUnfilledCopy(newSize: long): T</TD></TR>
<TR><TD ALIGN="LEFT" ># pageIndex(index: long): int</TD></TR>
<TR><TD ALIGN="LEFT" ># pageSize(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ resize(newSize: long): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AddIndexesMergeSource104941043[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AddIndexesMergeSource</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   pendingAddIndexesMerges: Queue&lt;OneMerge&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: IndexWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abortPendingMerges()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onMergeFinished(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerMerge(merge: OneMerge)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AlcoholicMergePolicy450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AlcoholicMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   calendar: Calendar [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># size(info: SegmentCommitInfo, mergeContext: MergeContext): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AnalysisThread808145979[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AnalysisThread</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   a: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   failed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   graphOffsetsAreCorrect: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   iterations: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   iw: RandomIndexWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   latch: CountDownLatch [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxWordLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   seed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   simple: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   useCharFilter: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ run()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AnalyzingInfixSuggester598362673[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AnalyzingInfixSuggester</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allTermsRequired: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closeIndexWriterOnBuild: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   commitOnBuild: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   highlight: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexAnalyzer: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   minPrefixChars: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   queryAnalyzer: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   searcherMgr: SearcherManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   searcherMgrLock: ReadWriteLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   searcherMgrReadLock: Lock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   searcherMgrWriteLock: Lock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writer: IndexWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writerLock: Object [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(text: BytesRef, contexts: Set&lt;BytesRef&gt;, weight: long, payload: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addContextToQuery(query: Builder, context: BytesRef, clause: Occur)</TD></TR>
<TR><TD ALIGN="LEFT" ># addNonMatch(sb: StringBuilder, text: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># addPrefixMatch(sb: StringBuilder, surface: String, analyzed: String, prefixToken: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># addWholeMatch(sb: StringBuilder, surface: String, analyzed: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(iter: InputIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >- buildDocument(text: BytesRef, contexts: Set&lt;BytesRef&gt;, weight: long, payload: BytesRef): Document</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit()</TD></TR>
<TR><TD ALIGN="LEFT" ># createResults(searcher: IndexSearcher, hits: TopFieldDocs, num: int, charSequence: CharSequence, doHighlight: boolean, matchedTokens: Set&lt;String&gt;, prefixToken: String): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" ># finishQuery(in: Builder, allTermsRequired: boolean): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># getDirectory(path: Path): Directory</TD></TR>
<TR><TD ALIGN="LEFT" ># getIndexWriterConfig(indexAnalyzer: Analyzer, openMode: OpenMode): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" ># getLastTokenQuery(token: String): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># highlight(text: String, matchedTokens: Set&lt;String&gt;, prefixToken: String): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(out: DataInput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, onlyMorePopular: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, num: int, allTermsRequired: boolean, doHighlight: boolean): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, num: int, allTermsRequired: boolean, doHighlight: boolean): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contextInfo: Map&lt;BytesRef, Occur&gt;, num: int, allTermsRequired: boolean, doHighlight: boolean): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contextQuery: BooleanQuery, num: int, allTermsRequired: boolean, doHighlight: boolean): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ refresh()</TD></TR>
<TR><TD ALIGN="LEFT" >+ store(in: DataOutput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- toQuery(contextInfo: Map&lt;BytesRef, Occur&gt;): BooleanQuery</TD></TR>
<TR><TD ALIGN="LEFT" >- toQuery(contextInfo: Set&lt;BytesRef&gt;): BooleanQuery</TD></TR>
<TR><TD ALIGN="LEFT" >+ update(text: BytesRef, contexts: Set&lt;BytesRef&gt;, weight: long, payload: BytesRef)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AnalyzingSuggester598362673[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AnalyzingSuggester</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exactFirst: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fst: FST&lt;Pair&lt;Long, BytesRef&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexAnalyzer: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxAnalyzedPathsForOneInput: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxGraphExpansions: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSurfaceFormsPerAnalyzedForm: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preservePositionIncrements: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   preserveSep: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queryAnalyzer: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempDir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempFileNamePrefix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(iterator: InputIterator)</TD></TR>
<TR><TD ALIGN="LEFT" ># convertAutomaton(a: Automaton): Automaton</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeWeight(encoded: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeWeight(value: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: CharSequence): Object</TD></TR>
<TR><TD ALIGN="LEFT" ># getFullPrefixPaths(prefixPaths: List&lt;Path&lt;Pair&lt;Long, BytesRef&gt;&gt;&gt;, lookupAutomaton: Automaton, fst: FST&lt;Pair&lt;Long, BytesRef&gt;&gt;): List&lt;Path&lt;Pair&lt;Long, BytesRef&gt;&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getLookupResult(output1: Long, output2: BytesRef, spare: CharsRefBuilder): LookupResult</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(input: DataInput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, onlyMorePopular: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- replaceSep(a: Automaton): Automaton</TD></TR>
<TR><TD ALIGN="LEFT" >- sameSurfaceForm(key: BytesRef, output2: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ store(output: DataOutput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># toAutomaton(surfaceForm: BytesRef, ts2a: TokenStreamToAutomaton): Automaton</TD></TR>
<TR><TD ALIGN="LEFT" ># toLookupAutomaton(key: CharSequence): Automaton</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ApplyDeletesResult1951225561[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ApplyDeletesResult</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   allDeleted: List&lt;SegmentCommitInfo&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   anyDeletes: boolean [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ArrayUtil2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ArrayUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareUnsigned4(a: byte[], aOffset: int, b: byte[], bOffset: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareUnsigned8(a: byte[], aOffset: int, b: byte[], bOffset: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOfSubArray(array: byte[], from: int, to: int): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOfSubArray(array: char[], from: int, to: int): char[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOfSubArray(array: short[], from: int, to: int): short[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOfSubArray(array: int[], from: int, to: int): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOfSubArray(array: long[], from: int, to: int): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOfSubArray(array: float[], from: int, to: int): float[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOfSubArray(array: double[], from: int, to: int): double[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOfSubArray(array: T[], from: int, to: int): T[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getUnsignedComparator(numBytes: int): ByteArrayComparator</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: T[]): T[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: T[], minSize: int): T[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: short[], minSize: int): short[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: short[]): short[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: float[], minSize: int): float[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: float[]): float[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: double[], minSize: int): double[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: double[]): double[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: int[], minSize: int): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: int[]): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: long[], minSize: int): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: long[]): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: byte[], minSize: int): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: char[], minSize: int): char[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(array: char[]): char[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growExact(array: T[], newLength: int): T[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growExact(array: short[], newLength: int): short[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growExact(array: float[], newLength: int): float[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growExact(array: double[], newLength: int): double[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growExact(array: int[], newLength: int): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growExact(array: long[], newLength: int): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growExact(array: byte[], newLength: int): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growExact(array: char[], newLength: int): char[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growNoCopy(array: int[], minSize: int): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growNoCopy(array: long[], minSize: int): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ growNoCopy(array: byte[], minSize: int): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ hashCode(array: char[], start: int, end: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ introSort(a: T[], fromIndex: int, toIndex: int, comp: Comparator&lt;? super T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ introSort(a: T[], comp: Comparator&lt;? super T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ introSort(a: T[], fromIndex: int, toIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ introSort(a: T[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ oversize(minTargetSize: int, bytesPerElement: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- parse(chars: char[], offset: int, len: int, radix: int, negative: boolean): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseInt(chars: char[], offset: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseInt(chars: char[], offset: int, len: int, radix: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ select(arr: T[], from: int, to: int, k: int, comparator: Comparator&lt;? super T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ swap(arr: T[], i: int, j: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ timSort(a: T[], fromIndex: int, toIndex: int, comp: Comparator&lt;? super T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ timSort(a: T[], comp: Comparator&lt;? super T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ timSort(a: T[], fromIndex: int, toIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ timSort(a: T[])</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingBinaryDocValues240599230[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingBinaryDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: BinaryDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ binaryValue(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingBits240599230[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingBits</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: Bits [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingCodec132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultKnnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValues: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   knnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocs: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   norms: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointsFormat: PointsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postings: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFields: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectors: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># assertThread(object: String, creationThread: Thread)</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKnnVectorsFormatForField(field: String): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingDocValuesConsumer19733963[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingDocValuesConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: DocValuesConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedSetField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingDocValuesFormat132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingDocValuesFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: DocValuesFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): DocValuesProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingDocValuesProducer19733963[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingDocValuesProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: DocValuesProducer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(field: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(field: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(field: FieldInfo): SortedSetDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingFieldsConsumer952482012[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingFieldsConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: FieldsConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeState: SegmentWriteState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fields: Fields, norms: NormsProducer)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingFieldsProducer952482012[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingFieldsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: FieldsProducer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingKnnVectorsFormat132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingKnnVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   delegate: KnnVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingKnnVectorsReader1194681000[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingKnnVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: KnnVectorsReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fis: FieldInfos [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingKnnVectorsWriter1194681000[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingKnnVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: KnnVectorsWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addField(fieldInfo: FieldInfo): KnnFieldVectorsWriter&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush(maxDoc: int, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeOneField(fieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingLeafReader450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingLeafReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- assertThread(object: String, creationThread: Thread)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinaryDocValues(field: String): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNormValues(field: String): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumericDocValues(field: String): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPointValues(field: String): PointValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedDocValues(field: String): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumericDocValues(field: String): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSetDocValues(field: String): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTermVectors(docID: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFields(): StoredFields</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectors(): TermVectors</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingLiveDocsFormat132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingLiveDocsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: LiveDocsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- check(bits: Bits, expectedLength: int, expectedDeleteCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ files(info: SegmentCommitInfo, files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLiveDocs(dir: Directory, info: SegmentCommitInfo, context: IOContext): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLiveDocs(bits: Bits, dir: Directory, info: SegmentCommitInfo, newDelCount: int, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingNormsFormat132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingNormsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: NormsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ normsConsumer(state: SegmentWriteState): NormsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsProducer(state: SegmentReadState): NormsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingNormsProducer1942197810[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingNormsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: NormsProducer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNorms(field: FieldInfo): NumericDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingNumericDocValues240599230[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: NumericDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingPointTree240599230[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingPointTree</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: PointTree [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pointValues: PointValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): PointTree</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToChild(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToParent(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToSibling(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocIDs(visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocValues(visitor: IntersectVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingPointsFormat132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingPointsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: PointsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): PointsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): PointsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingPostingsFormat132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: PostingsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingSortedDocValues240599230[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingSortedDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: SortedDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingSortedNumericDocValues240599230[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingSortedNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: SortedNumericDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueUpto: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(in: SortedNumericDocValues, maxDoc: int): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextValue(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingSortedSetDocValues240599230[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingSortedSetDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: SortedSetDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastOrd: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueCount: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(in: SortedSetDocValues, maxDoc: int): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextOrd(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingStoredFieldsFormat132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingStoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: StoredFieldsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingStoredFieldsReader1117745233[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingStoredFieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   creationThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: StoredFieldsReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(n: int, visitor: StoredFieldVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingStoredFieldsWriter1117745233[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingStoredFieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docStatus: Status [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: StoredFieldsWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numWritten: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: float)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: double)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingTermVectorsFormat132317806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingTermVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ vectorsReader(directory: Directory, segmentInfo: SegmentInfo, fieldInfos: FieldInfos, context: IOContext): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorsWriter(directory: Directory, segmentInfo: SegmentInfo, context: IOContext): TermVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingTermVectorsReader732135745[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingTermVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: TermVectorsReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(doc: int): Fields</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AssertingTermVectorsWriter732135745[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AssertingTermVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docStatus: Status [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldStatus: Status [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   hasPositions: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: TermVectorsWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positionCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termStatus: Status [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addPosition(position: int, startOffset: int, endOffset: int, payload: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishField()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishTerm()</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument(numVectorFields: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startField(info: FieldInfo, numTerms: int, positions: boolean, offsets: boolean, payloads: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startTerm(term: BytesRef, freq: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Automaton1522148614[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Automaton</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   curState: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   destMinMaxSorter: Sorter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deterministic: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isAccept: BitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minMaxDestSorter: Sorter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextState: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextTransition: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   states: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transitions: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addEpsilon(source: int, dest: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addTransition(source: int, dest: int, label: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addTransition(source: int, dest: int, min: int, max: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># appendCharString(c: int, b: StringBuilder)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copy(other: Automaton)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createState(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- finishCurrentState()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishState()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNextTransition(t: Transition)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumTransitions(state: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTransition(state: int, index: int, t: Transition)</TD></TR>
<TR><TD ALIGN="LEFT" >- growStates()</TD></TR>
<TR><TD ALIGN="LEFT" >- growTransitions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ initTransition(state: int, t: Transition): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ isAccept(state: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(transition: Transition, label: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- next(state: int, fromTransitionIndex: int, label: int, transition: Transition): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ step(state: int, label: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ toDot(): String</TD></TR>
<TR><TD ALIGN="LEFT" >- transitionSorted(t: Transition): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

AutomatonQuery536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)AutomatonQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   automaton: Automaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   automatonIsBinary: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   compiled: CompiledAutomaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   term: Term [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># getTermsEnum(terms: Terms, atts: AttributeSource): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BKDPointTree480502827[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BKDPointTree</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   commonPrefixLengths: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: BKDConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docIdsWriter: DocIdsWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   innerNodes: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isTreeBalanced: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastLeafNodePointCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leafBlockFPStack: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leafNodeOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leafNodes: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   level: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   negativeDeltas: boolean[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nodeID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nodeRoot: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pointCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readNodeDataPositions: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rightMostLeafNode: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rightNodePositions: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchDataPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchIterator: BKDReaderDocIDSetIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchMaxIndexPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchMinIndexPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   splitDimValueStack: byte[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   splitDimsPos: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   splitValuesStack: byte[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAll(visitor: IntersectVisitor, grown: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- balanceTreeNodePosition(minNode: int, maxNode: int, node: int, position: int, level: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): PointTree</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumLeavesSlow(node: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getTreeDepth(numLeaves: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToChild(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToParent(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToSibling(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- nodeExists(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- pop()</TD></TR>
<TR><TD ALIGN="LEFT" >- popBounds(packedValue: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >- pushBoundsLeft()</TD></TR>
<TR><TD ALIGN="LEFT" >- pushBoundsRight()</TD></TR>
<TR><TD ALIGN="LEFT" >- pushLeft()</TD></TR>
<TR><TD ALIGN="LEFT" >- pushRight()</TD></TR>
<TR><TD ALIGN="LEFT" >- readCommonPrefixes(commonPrefixLengths: int[], scratchPackedValue: byte[], in: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >- readCompressedDim(in: IndexInput): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readDocIDs(in: IndexInput, blockFP: long, iterator: BKDReaderDocIDSetIterator): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readMinMax(commonPrefixLengths: int[], minPackedValue: byte[], maxPackedValue: byte[], in: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >- readNodeData(isLeft: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- resetNodeDataPosition()</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- sizeFromBalancedTree(leftMostLeafNode: int, rightMostLeafNode: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >- visitCompressedDocValues(commonPrefixLengths: int[], scratchPackedValue: byte[], in: IndexInput, scratchIterator: BKDReaderDocIDSetIterator, count: int, visitor: IntersectVisitor, compressedDim: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocIDs(visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocValues(visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- visitDocValues(visitor: IntersectVisitor, fp: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- visitDocValuesNoCardinality(commonPrefixLengths: int[], scratchDataPackedValue: byte[], scratchMinIndexPackedValue: byte[], scratchMaxIndexPackedValue: byte[], in: IndexInput, scratchIterator: BKDReaderDocIDSetIterator, count: int, visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- visitDocValuesWithCardinality(commonPrefixLengths: int[], scratchDataPackedValue: byte[], scratchMinIndexPackedValue: byte[], scratchMaxIndexPackedValue: byte[], in: IndexInput, scratchIterator: BKDReaderDocIDSetIterator, count: int, visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- visitLeavesOneByOne(visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- visitSparseRawDocValues(commonPrefixLengths: int[], scratchPackedValue: byte[], in: IndexInput, scratchIterator: BKDReaderDocIDSetIterator, count: int, visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- visitUniqueRawDocValues(scratchPackedValue: byte[], scratchIterator: BKDReaderDocIDSetIterator, count: int, visitor: IntersectVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BKDWriter146901819[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BKDWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   commonPrefixComparator: ByteArrayComparator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   commonPrefixLengths: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   comparator: ByteArrayComparator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   config: BKDConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docIdsWriter: DocIdsWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docsSeen: FixedBitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   equalsPredicate: ByteArrayPredicate [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   finished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxMBSortInHeap: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPointsSortInHeap: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   minPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pointCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointWriter: PointWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch1: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch2: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratchBytesRef1: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratchBytesRef2: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratchDiff: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   tempDir: TrackingDirectoryWrapper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   tempFileNamePrefix: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempInput: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalPointCount: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(packedValue: byte[], docID: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- appendBlock(writeBuffer: ByteBuffersDataOutput, blocks: List&lt;byte[]&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" >- build(leavesOffset: int, numLeaves: int, reader: MutablePointTree, from: int, to: int, out: IndexOutput, minPackedValue: byte[], maxPackedValue: byte[], parentSplits: int[], splitPackedValues: byte[], splitDimensionValues: byte[], leafBlockFPs: long[], spareDocIds: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >- build(leavesOffset: int, numLeaves: int, points: PathSlice, out: IndexOutput, radixSelector: BKDRadixSelector, minPackedValue: byte[], maxPackedValue: byte[], parentSplits: int[], splitPackedValues: byte[], splitDimensionValues: byte[], leafBlockFPs: long[], spareDocIds: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >- checkMaxLeafNodeCount(numLeaves: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- computeCommonPrefixLength(heapPointWriter: HeapPointWriter, commonPrefix: byte[], from: int, to: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- computeMinMax(count: int, packedValues: IntFunction&lt;BytesRef&gt;, offset: int, length: int): BytesRef[]</TD></TR>
<TR><TD ALIGN="LEFT" >- computePackedValueBounds(values: MutablePointTree, from: int, to: int, minPackedValue: byte[], maxPackedValue: byte[], scratch: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >- computePackedValueBounds(slice: PathSlice, minPackedValue: byte[], maxPackedValue: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(metaOut: IndexOutput, indexOut: IndexOutput, dataOut: IndexOutput): Runnable</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumLeftLeafNodes(numLeaves: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- initPointWriter()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(metaOut: IndexOutput, indexOut: IndexOutput, dataOut: IndexOutput, docMaps: List&lt;DocMap&gt;, readers: List&lt;PointValues&gt;): Runnable</TD></TR>
<TR><TD ALIGN="LEFT" >- packIndex(leafNodes: BKDTreeLeafNodes): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- recursePackIndex(writeBuffer: ByteBuffersDataOutput, leafNodes: BKDTreeLeafNodes, minBlockFP: long, blocks: List&lt;byte[]&gt;, lastSplitValues: byte[], negativeDeltas: boolean[], isLeft: boolean, leavesOffset: int, numLeaves: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- runLen(packedValues: IntFunction&lt;BytesRef&gt;, start: int, end: int, byteOffset: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># split(minPackedValue: byte[], maxPackedValue: byte[], parentSplits: int[]): int</TD></TR>
<TR><TD ALIGN="LEFT" >- switchToHeap(source: PointWriter): HeapPointWriter</TD></TR>
<TR><TD ALIGN="LEFT" >- valueInBounds(config: BKDConfig, packedValue: BytesRef, minPackedValue: byte[], maxPackedValue: byte[]): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- valueInOrder(config: BKDConfig, ord: long, sortedDim: int, lastPackedValue: byte[], packedValue: byte[], packedValueOffset: int, doc: int, lastDoc: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- valuesInOrderAndBounds(config: BKDConfig, count: int, sortedDim: int, minPackedValue: byte[], maxPackedValue: byte[], values: IntFunction&lt;BytesRef&gt;, docs: int[], docsOffset: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyChecksum(priorException: Throwable, writer: PointWriter): Error</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyParams(maxMBSortInHeap: double, totalPointCount: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeActualBounds(out: DataOutput, commonPrefixLengths: int[], count: int, packedValues: IntFunction&lt;BytesRef&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeCommonPrefixes(out: DataOutput, commonPrefixes: int[], packedValue: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(metaOut: IndexOutput, indexOut: IndexOutput, dataOut: IndexOutput, fieldName: String, reader: MutablePointTree): Runnable</TD></TR>
<TR><TD ALIGN="LEFT" >- writeField1Dim(metaOut: IndexOutput, indexOut: IndexOutput, dataOut: IndexOutput, fieldName: String, reader: MutablePointTree): Runnable</TD></TR>
<TR><TD ALIGN="LEFT" >- writeFieldNDims(metaOut: IndexOutput, indexOut: IndexOutput, dataOut: IndexOutput, fieldName: String, values: MutablePointTree): Runnable</TD></TR>
<TR><TD ALIGN="LEFT" >- writeHighCardinalityLeafBlockPackedValues(out: DataOutput, commonPrefixLengths: int[], count: int, sortedDim: int, packedValues: IntFunction&lt;BytesRef&gt;, compressedByteOffset: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeIndex(metaOut: IndexOutput, indexOut: IndexOutput, countPerLeaf: int, leafNodes: BKDTreeLeafNodes, dataStartFP: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeIndex(metaOut: IndexOutput, indexOut: IndexOutput, countPerLeaf: int, numLeaves: int, packedIndex: byte[], dataStartFP: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeLeafBlockDocs(out: DataOutput, docIDs: int[], start: int, count: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeLeafBlockPackedValues(out: DataOutput, commonPrefixLengths: int[], count: int, sortedDim: int, packedValues: IntFunction&lt;BytesRef&gt;, leafCardinality: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeLeafBlockPackedValuesRange(out: DataOutput, commonPrefixLengths: int[], start: int, end: int, packedValues: IntFunction&lt;BytesRef&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeLowCardinalityLeafBlockPackedValues(out: DataOutput, commonPrefixLengths: int[], count: int, packedValues: IntFunction&lt;BytesRef&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BackCompatSortedNumericDocValues1914416286[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BackCompatSortedNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   binaryDocValues: BinaryDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   binaryValueDecoder: BiConsumer&lt;BytesRef, IntsRef&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   curr: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: IntsRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># loadValues(buf: BytesRef, ordinals: IntsRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- reloadValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrap(binaryDocValues: BinaryDocValues, binaryValueDecoder: BiConsumer&lt;BytesRef, IntsRef&gt;): SortedNumericDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseBitSetTestCase1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseBitSetTestCase&lt;T extends BitSet&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># assertEquals(set1: BitSet, set2: T, maxDoc: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOf(bs: BitSet, length: int): T</TD></TR>
<TR><TD ALIGN="LEFT" >- randomCopy(set: BitSet, numBits: int): DocIdSet</TD></TR>
<TR><TD ALIGN="LEFT" ># randomSet(numBits: int, numBitsSet: int): BitSet</TD></TR>
<TR><TD ALIGN="LEFT" ># randomSet(numBits: int, percentSet: float): BitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCardinality()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testClear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testClearRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testGetAndSet()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNextSetBit()</TD></TR>
<TR><TD ALIGN="LEFT" >- testOr(load: float)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOrDense()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOrRandom()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOrSparse()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPrevSetBit()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSet()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseChunkedDirectoryTestCase459647902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseChunkedDirectoryTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- assertChunking(random: Random, chunkSize: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- assertSlice(bytes: byte[], slicer: IndexInput, outerSliceStart: int, sliceStart: int, sliceLength: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># getDirectory(path: Path): Directory</TD></TR>
<TR><TD ALIGN="LEFT" ># getDirectory(path: Path, maxChunkSize: int): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCloneClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCloneSliceClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLittleEndianFloatsCrossBoundary()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLittleEndianLongsCrossBoundary()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomChunkSizes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeekEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeekSliceEnd()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeekSliceZero()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeekZero()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeeking()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSliceOfSlice()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSlicedSeeking()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseCompoundFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseCompoundFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertEqualArrays(msg: String, expected: byte[], test: byte[], start: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertSameSeekBehavior(msg: String, expected: IndexInput, actual: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertSameStreams(msg: String, expected: IndexInput, test: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertSameStreams(msg: String, expected: IndexInput, actual: IndexInput, seekTo: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># createLargeCFS(dir: Directory): Directory</TD></TR>
<TR><TD ALIGN="LEFT" ># createRandomFile(dir: Directory, name: String, size: int, segId: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" ># createSequenceFile(dir: Directory, name: String, start: byte, size: int, segID: byte[], segSuffix: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># newSegmentInfo(dir: Directory, name: String): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCheckIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testClonedStreamsClosing()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCorruptFilesAreCaught()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCreateOutputDisabled()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDeleteFileDisabled()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDoubleClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEmpty()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFileNotFound()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLargeCFS()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testListAll()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMakeLockDisabled()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testManySubFiles()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMergeStability()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMissingCodecHeadersAreCaught()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPassIOContext()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomAccess()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomAccessClones()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomFiles()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testReadPastEOF()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRenameFileDisabled()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testResourceNameInsideCompoundFile()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSingleFile()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSyncDisabled()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoFiles()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseCompressingDocValuesFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseCompressingDocValuesFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># dirSize(d: Directory): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDateCompression()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSingleBigValueCompression()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testUniqueValuesCompression()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseDirectoryTestCase459647902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseDirectoryTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># getDirectory(path: Path): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >- runCopyFrom(source: Directory, dest: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAlignedFloats()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAlignedInts()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAlignedLittleEndianLongs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testByte()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testChecksum()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCopyBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCopyBytesWithThreads()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCopyFrom()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCreateOutputForExistingFile()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCreateTempOutput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDeleteFile()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDetectClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDoubleCloseInput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDoubleCloseOutput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFileExistsInListAfterCreated()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFloatsUnderflow()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFsyncDoesntCreateNewFiles()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalEOF()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexOutputToString()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testInt()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIntsUnderflow()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLargeWrites()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testListAllIsSorted()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLittleEndianLongsUnderflow()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLong()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMapOfStrings()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNoDir()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPendingDeletions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomByte()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomInt()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomLong()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomShort()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRename()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeekBeyondEndOfFile()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeekPastEOF()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeekToEOFThenBack()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSeekToEndOfFile()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSetOfStrings()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testShort()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSliceOfSlice()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSliceOutOfBounds()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testString()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreadSafetyInListAll()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testUnalignedFloats()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testUnalignedInts()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testUnalignedLittleEndianLongs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testVInt()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testVLong()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testZInt()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testZLong()</TD></TR>
<TR><TD ALIGN="LEFT" >- value(idx: int): byte</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseDocIdSetTestCase1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseDocIdSetTestCase&lt;T extends DocIdSet&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ assertEquals(numBits: int, ds1: BitSet, ds2: T)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOf(bs: BitSet, length: int): T</TD></TR>
<TR><TD ALIGN="LEFT" >- ramBytesUsed(set: DocIdSet, length: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ test1Bit()</TD></TR>
<TR><TD ALIGN="LEFT" >+ test2Bits()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAgainstBitSet()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNoBit()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRamBytesUsed()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseDocValuesFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseDocValuesFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertDVIterate(dir: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" ># codecAcceptsHugeBinaryValues(field: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestBinaryFixedLengthVsStoredFields(density: double)</TD></TR>
<TR><TD ALIGN="LEFT" >+ doTestBinaryVariableLengthVsStoredFields(density: double)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestBinaryVsStoredFields(density: double, bytes: Supplier&lt;byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestGCDCompression(density: double)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestNumericsVsStoredFields(density: double, longs: LongSupplier)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestNumericsVsStoredFields(density: double, longs: LongSupplier, minDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestRandomAdvance(fieldCreator: FieldCreator)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestSortedNumericsVsStoredFields(counts: LongSupplier, values: LongSupplier)</TD></TR>
<TR><TD ALIGN="LEFT" ># doTestSortedSetEnumAdvanceIndependently(dv: SortedSetDocValues)</TD></TR>
<TR><TD ALIGN="LEFT" ># doTestSortedSetVsStoredFields(numDocs: int, minLength: int, maxLength: int, maxValuesPerDoc: int, maxUniqueValues: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># doTestSortedVsStoredFields(numDocs: int, density: double, bytes: Supplier&lt;byte[]&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># doTestSortedVsStoredFields(numDocs: int, density: double, minLength: int, maxLength: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBigNumericRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBigNumericRange2()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBinaryFixedLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBinaryMergeAwayAllValuesLargeSegment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBinaryVariableLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBooleanNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testByteNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBytesMergeAwayAllValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBytesTwoDocumentsMerged()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBytesWithNewline()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCodecUsesOwnBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCodecUsesOwnSortedBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDocValuesSimple()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEmptyBinaryValueOnPageSizes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEmptyBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEmptySortedBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testGCDCompression()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testHighOrdsSortedSetDV()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIntNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLongNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMissingSortedBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNumberMergeAwayAllValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNumericMergeAwayAllValuesLargeSegment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOneFloat()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOneNumber()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOneSortedNumber()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOneSortedNumberOneMissing()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomAdvanceBinary()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomAdvanceNumeric()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomSortedBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testShortNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedBytesThreeDocuments()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedBytesTwoDocuments()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedBytesTwoDocumentsMerged()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedEnumAdvanceIndependently()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedFixedLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedMergeAwayAllValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedMergeAwayAllValuesLargeSegment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedNumberMerge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedNumberMergeAwayAllValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedNumericMergeAwayAllValuesLargeSegment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedNumericsFewUniqueSetsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedNumericsMultipleValuesVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedNumericsSingleValuedMissingVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedNumericsSingleValuedVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetEnumAdvanceIndependently()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetFixedLengthFewUniqueSetsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetFixedLengthManyValuesPerDocVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetFixedLengthSingleValuedVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetFixedLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetMergeAwayAllValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetMergeAwayAllValuesLargeSegment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetOneValue()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTermsEnum()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetThreeValuesTwoDocs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTwoDocumentsFirstMissing()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTwoDocumentsFirstMissingMerge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTwoDocumentsLastMissing()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTwoDocumentsLastMissingMerge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTwoDocumentsMerged()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTwoFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTwoValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetTwoValuesUnordered()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetVariableLengthFewUniqueSetsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetVariableLengthManyValuesPerDocVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetVariableLengthSingleValuedVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedSetVariableLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedTermsEnum()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedVariableLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseBinaryFixedLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseBinaryVariableLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseBooleanNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseByteNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseGCDCompression()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseIntNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseLongNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseShortNumericsVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseSortedFixedLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseSortedVariableLengthVsStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseZeros()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreads()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreads2()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreads3()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreeBytesOneMissingWithMerging()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreeFieldsMixed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreeFieldsMixed2()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreeNumbersOneMissingWithMerging()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoBinaryValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoBytesOneMissing()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoBytesOneMissingWithMerging()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoDocumentsMerged()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoDocumentsNumeric()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoFieldsMixed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoNumbers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoNumbersOneMissing()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoNumbersOneMissingWithMerging()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoSortedNumber()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoSortedNumberOneMissing()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testTwoSortedNumberSameValue()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testVariouslyCompressibleBinaryValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testVeryLargeButLegalBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testVeryLargeButLegalSortedBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testZeroOrMin()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testZeros()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseExplanationTestCase1349913227[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseExplanationTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ afterClassTestExplanations()</TD></TR>
<TR><TD ALIGN="LEFT" >+ beforeClassTestExplanations()</TD></TR>
<TR><TD ALIGN="LEFT" >+ bqtest(q: Query, expDocNrs: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ createDoc(index: int): Document</TD></TR>
<TR><TD ALIGN="LEFT" ># matchTheseItems(terms: int[]): Query</TD></TR>
<TR><TD ALIGN="LEFT" >+ optB(q: Query): Query</TD></TR>
<TR><TD ALIGN="LEFT" >+ qtest(q: Query, expDocNrs: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ reqB(q: Query): Query</TD></TR>
<TR><TD ALIGN="LEFT" >+ ta(s: String[]): Term[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseFieldInfoFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseFieldInfoFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addAttributes(fi: FieldInfo)</TD></TR>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertEquals(expected: FieldInfos, actual: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertEquals(expected: FieldInfo, actual: FieldInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >- createFieldInfo(): FieldInfo</TD></TR>
<TR><TD ALIGN="LEFT" ># newSegmentInfo(dir: Directory, name: String): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- randomFieldType(r: Random): IndexableFieldType</TD></TR>
<TR><TD ALIGN="LEFT" >+ testExceptionOnCloseInput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testExceptionOnCloseOutput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testExceptionOnCreateOutput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testExceptionOnOpenInput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testImmutableAttributes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOneField()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandom()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseGeoPointTestCase1752419662[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseGeoPointTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addPointToDoc(field: String, doc: Document, lat: double, lon: double)</TD></TR>
<TR><TD ALIGN="LEFT" >- buildError(docID: int, expected: boolean, id: int, lats: double[], lons: double[], query: Query, liveDocs: Bits, explain: Consumer&lt;StringBuilder&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- doRandomDistanceTest(numDocs: int, numQueries: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestRandom(count: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- indexPoints(lats: double[], lons: double[], deleted: Set&lt;Integer&gt;, w: IndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" ># newDistanceQuery(field: String, centerLat: double, centerLon: double, radiusMeters: double): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newGeometryQuery(field: String, geometry: LatLonGeometry...): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newPolygonQuery(field: String, polygon: Polygon...): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newRectQuery(field: String, minLat: double, maxLat: double, minLon: double, maxLon: double): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># nextBox(): Rectangle</TD></TR>
<TR><TD ALIGN="LEFT" ># nextCircle(): Circle</TD></TR>
<TR><TD ALIGN="LEFT" ># nextGeometry(): LatLonGeometry[]</TD></TR>
<TR><TD ALIGN="LEFT" ># nextLatitude(): double</TD></TR>
<TR><TD ALIGN="LEFT" ># nextLongitude(): double</TD></TR>
<TR><TD ALIGN="LEFT" ># nextPolygon(): Polygon</TD></TR>
<TR><TD ALIGN="LEFT" ># quantizeLat(lat: double): double</TD></TR>
<TR><TD ALIGN="LEFT" ># quantizeLon(lon: double): double</TD></TR>
<TR><TD ALIGN="LEFT" ># rectContainsPoint(rect: Rectangle, pointLat: double, pointLon: double): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- searchIndex(s: IndexSearcher, query: Query, maxDoc: int): FixedBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >- searchSmallSet(query: Query, size: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAllLatEqual()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAllLonEqual()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBoxBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBoxInvalidCoordinates()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBoxNull()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceIllegal()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceInf()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceNaN()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceNegative()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceNull()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEquals()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexExtremeValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexInfValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexNaNValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexOutOfRangeValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLowCardinality()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMultiPolygonBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMultiValued()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPolygonBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPolygonHole()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPolygonHoleExcludes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPolygonNullField()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomBig()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomDistance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomDistanceHuge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomMedium()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomTiny()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRectBoundariesAreInclusive()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSamePointManyTimes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetDateline()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetDistance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetDistanceDateline()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetDistanceNotEmpty()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetHugeDistance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetMultiValued()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetPoly()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetPolyWholeMap()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetRect()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetTinyDistance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetWholeMap()</TD></TR>
<TR><TD ALIGN="LEFT" >- verify(lats: double[], lons: double[])</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyRandomDistances(lats: double[], lons: double[])</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyRandomGeometries(lats: double[], lons: double[])</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyRandomPolygons(lats: double[], lons: double[])</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyRandomRectangles(lats: double[], lons: double[])</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseIndexFileFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseIndexFileFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   savedCodec: Codec [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" ># applyCreatedVersionMajor(d: D): D</TD></TR>
<TR><TD ALIGN="LEFT" >- bytesUsedByExtension(d: Directory): Map&lt;String, Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># excludedExtensionsFromByteCounts(): Collection&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- handleFakeIOException(e: IOException, exceptionStream: PrintStream)</TD></TR>
<TR><TD ALIGN="LEFT" ># maybeWrapWithMergingReader(r: DirectoryReader): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># mergeIsStable(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># shouldTestMergeInstance(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tearDown()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCheckIntegrityReadsAllBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMergeStability()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMultiClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomExceptions()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseKnnVectorsFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseKnnVectorsFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   similarityFunction: VectorSimilarityFunction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorEncoding: VectorEncoding [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- add(iw: IndexWriter, field: String, id: int, vector: float[], similarityFunction: VectorSimilarityFunction)</TD></TR>
<TR><TD ALIGN="LEFT" >- add(iw: IndexWriter, field: String, id: int, vector: byte[], similarity: VectorSimilarityFunction)</TD></TR>
<TR><TD ALIGN="LEFT" >- add(iw: IndexWriter, field: String, id: int, sortKey: int, vector: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >- add(iw: IndexWriter, field: String, id: int, sortKey: int, vector: byte[], similarityFunction: VectorSimilarityFunction)</TD></TR>
<TR><TD ALIGN="LEFT" >- add(iw: IndexWriter, field: String, id: int, sortkey: int, vector: float[])</TD></TR>
<TR><TD ALIGN="LEFT" >- add(iw: IndexWriter, field: String, id: int, sortkey: int, vector: float[], similarityFunction: VectorSimilarityFunction)</TD></TR>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" >+ init()</TD></TR>
<TR><TD ALIGN="LEFT" >- randomSimilarity(): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >- randomVector(dim: int): float[]</TD></TR>
<TR><TD ALIGN="LEFT" >- randomVector8(dim: int): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" ># randomVectorEncoding(): VectorEncoding</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAddIndexesDirectory0()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAddIndexesDirectory01()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAddIndexesDirectory1()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAdvance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testCheckIndexIncludesVectors()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDeleteAllVectorDocs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDifferentCodecs1()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDifferentCodecs2()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFieldConstructor()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFieldConstructorExceptions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFieldSetValue()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalDimChangeTwoDocs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalDimChangeTwoWriters()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalDimChangeViaAddIndexesCodecReader()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalDimChangeViaAddIndexesDirectory()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalDimChangeViaAddIndexesSlowCodecReader()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalDimensionTooLarge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalEmptyVector()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalMultipleValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalSimilarityFunctionChange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalSimilarityFunctionChangeTwoWriters()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalSimilarityFunctionChangeViaAddIndexesCodecReader()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalSimilarityFunctionChangeViaAddIndexesDirectory()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIllegalSimilarityFunctionChangeViaAddIndexesSlowCodecReader()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexMultipleKnnVectorFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexedValueNotAliased()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testInvalidKnnVectorFieldUsage()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testKnnVectorFieldMissingFromOneSegment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandom()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomWithUpdatesAndGraph()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSearchWithVisitedLimit()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSimilarityFunctionIdentifiers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedIndex()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSortedIndexBytes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseVectors()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testVectorEncodingOrdinals()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testVectorValuesReportCorrectDocs()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseLiveDocsFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseLiveDocsFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   savedCodec: Codec [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ tearDown()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDenseLiveDocs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEmptyLiveDocs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOverflow()</TD></TR>
<TR><TD ALIGN="LEFT" >- testSerialization(maxDoc: int, numLiveDocs: int, fixedBitSet: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseLiveDocs()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseLockFactoryTestCase459647902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseLockFactoryTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addDoc(writer: IndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" ># getDirectory(path: Path): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDoubleClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testInvalidAfterClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testObtainConcurrently()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testStressLocks()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testValidAfterAcquire()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseMergePolicyTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseMergePolicyTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># applyDeletes(infos: SegmentInfos, numDeletes: int): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" ># applyMerge(infos: SegmentInfos, merge: OneMerge, mergedSegmentName: String, stats: IOStats): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" ># assertMerge(policy: MergePolicy, merge: MergeSpecification)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertSegmentInfos(policy: MergePolicy, infos: SegmentInfos)</TD></TR>
<TR><TD ALIGN="LEFT" ># doTestSimulateAppendOnly(mergePolicy: MergePolicy, totalDocs: int, maxDocsPerFlush: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># doTestSimulateUpdates(mergePolicy: MergePolicy, totalDocs: int, maxDocsPerFlush: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># makeSegmentCommitInfo(name: String, maxDoc: int, numDeletedDocs: int, sizeMB: double, source: String): SegmentCommitInfo</TD></TR>
<TR><TD ALIGN="LEFT" ># mergePolicy(): MergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFindForcedDeletesMerges()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testForceMergeNotNeeded()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNoPathologicalMerges()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSimulateAppendOnly()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSimulateUpdates()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseNormsFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseNormsFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkNormsVsDocValues(ir: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" ># codecSupportsSparsity(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestNormsVersusDocValues(density: double, longs: LongSupplier)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAllZeros()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testByteRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFewLargeValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFewSparseLargeValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFewSparseValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFewValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFullLongRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndependantIterators()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndependantSparseIterators()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLongRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMergeStability()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMostZeros()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNCommon()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNCommonBig()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOutliers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOutliers2()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testShortRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseAllZeros()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseByteRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseFullLongRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseLongRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseNCommon()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseNCommonBig()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseOutliers()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseOutliers2()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSparseShortRange()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testThreads()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testUndeadNorms()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BasePointsFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BasePointsFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" >- assertSize(tree: PointTree)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestRandomBinary(count: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- flattenBinaryPoint(value: byte[][], numDataDims: int, numBytesPerDim: int): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >- getDirectory(numPoints: int): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >- getPointValues(size: long, docCount: int, estimatedPointCount: long): PointValues</TD></TR>
<TR><TD ALIGN="LEFT" >- handlePossiblyFakeException(e: Exception): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># mergeIsStable(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- randomBigInt(numBytes: int): BigInteger</TD></TR>
<TR><TD ALIGN="LEFT" >- randomPointTreeNavigation(tree: PointTree)</TD></TR>
<TR><TD ALIGN="LEFT" >- switchIndex(w: RandomIndexWriter, dir: Directory, saveW: RandomIndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAddIndexes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAllEqual()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAllPointDocsDeletedInSegment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBasic()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBigIntNDims()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDocCountEdgeCases()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMerge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMergeMissing()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMultiValued()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOneDimEqual()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testOneDimTwoValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomBinaryBig()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomBinaryMedium()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomBinaryTiny()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomDocCount()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testWithExceptions()</TD></TR>
<TR><TD ALIGN="LEFT" >- verify(docValues: byte[][][], docIDs: int[], numDims: int, numBytesPerDim: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- verify(docValues: byte[][][], docIDs: int[], numDataDims: int, numIndexDims: int, numBytesPerDim: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- verify(dir: Directory, docValues: byte[][][], ids: int[], numDims: int, numIndexDims: int, numBytesPerDim: int, expectExceptions: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BasePostingsFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BasePostingsFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" >+ afterClass()</TD></TR>
<TR><TD ALIGN="LEFT" ># assertReused(field: String, p1: PostingsEnum, p2: PostingsEnum)</TD></TR>
<TR><TD ALIGN="LEFT" ># checkReuse(termsEnum: TermsEnum, firstFlags: int, secondFlags: int, shouldReuse: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createPostings()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAskForPositionsWhenNotThere()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDidntWantFreqsButAskedAnyway()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDocsAndFreqs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDocsAndFreqsAndPositions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDocsAndFreqsAndPositionsAndOffsets()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDocsAndFreqsAndPositionsAndOffsetsAndPayloads()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDocsAndFreqsAndPositionsAndPayloads()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDocsOnly()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEmptyFieldAndEmptyTerm()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testGhosts()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testInvertedWrite()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testJustEmptyField()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLevel2Ghosts()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumAll()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumDocsOnly()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumFreqs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumOffsets()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumPayloads()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumPositions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumReuse()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandom()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseRangeFieldQueryTestCase1349913227[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseRangeFieldQueryTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRange(doc: Document, box: Range)</TD></TR>
<TR><TD ALIGN="LEFT" ># dimension(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestRandom(count: int, multiValued: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># expectedBBoxQueryResult(queryRange: Range, range: Range, queryType: QueryType): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># expectedResult(queryRange: Range, range: Range[], queryType: QueryType): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># newContainsQuery(box: Range): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newCrossesQuery(box: Range): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newIntersectsQuery(box: Range): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newRangeField(box: Range): Field</TD></TR>
<TR><TD ALIGN="LEFT" ># newWithinQuery(box: Range): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># nextRange(dimensions: int): Range</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAllEqual()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLowCardinality()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMultiValued()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomBig()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomMedium()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomTiny()</TD></TR>
<TR><TD ALIGN="LEFT" >- verify(ranges: Range[][])</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseSegmentInfoFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseSegmentInfoFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertEquals(expected: SegmentInfo, actual: SegmentInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >- randomIndexSortField(): SortField</TD></TR>
<TR><TD ALIGN="LEFT" ># supportsIndexSort(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># supportsMinVersion(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAddsSelfToFiles()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAttributes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDiagnostics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testExceptionOnCloseInput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testExceptionOnCloseOutput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testExceptionOnCreateOutput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testExceptionOnOpenInput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFiles()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandom()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSort()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testUniqueID()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testVersions()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseSimilarityTestCase925567676[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseSimilarityTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ afterClass()</TD></TR>
<TR><TD ALIGN="LEFT" >+ beforeClass()</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestScoring(similarity: Similarity, corpus: CollectionStatistics, term: TermStatistics, boost: float, freq: float, norm: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># getSimilarity(random: Random): Similarity</TD></TR>
<TR><TD ALIGN="LEFT" ># newCorpus(random: Random, norm: int): CollectionStatistics</TD></TR>
<TR><TD ALIGN="LEFT" ># newTerm(random: Random, corpus: CollectionStatistics): TermStatistics</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomScoring()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseSortedDocValues841633975[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseSortedDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   entry: SortedEntry [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termsEnum: TermsEnum [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ termsEnum(): TermsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseSortedSetDocValues841633975[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseSortedSetDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   entry: SortedSetEntry [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termsEnum: TermsEnum [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ termsEnum(): TermsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseStoredFieldsFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseStoredFieldsFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addRandomFields(d: Document)</TD></TR>
<TR><TD ALIGN="LEFT" >- randomByteArray(length: int, max: int): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBigDocuments()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBinaryFieldOffsetLength()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBulkMergeWithDeletes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testConcurrentReads()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEmptyDocs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexedBit()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMergeFilterReader()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMismatchedFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testNumericField()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomStoredFieldsWithIndexSort()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testReadSkip()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testStoredFieldsOrder()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testWriteReadMerge()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseTermVectorsFormatTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseTermVectorsFormatTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docsEnum: ThreadLocal&lt;PostingsEnum&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addId(doc: Document, id: String): Document</TD></TR>
<TR><TD ALIGN="LEFT" ># addRandomFields(doc: Document)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertEquals(doc: RandomDocument, fields: Fields)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertEquals(tk: RandomTokenStream, ft: FieldType, terms: Terms)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestMerge(indexSort: Sort, allowDeletes: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># docID(reader: IndexReader, id: String): int</TD></TR>
<TR><TD ALIGN="LEFT" ># fieldType(options: Options): FieldType</TD></TR>
<TR><TD ALIGN="LEFT" ># randomOptions(): Options</TD></TR>
<TR><TD ALIGN="LEFT" >+ testClone()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testHighFreqs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLotsOfFields()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMerge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMergeWithDeletes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMergeWithIndexSort()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMergeWithIndexSortAndDeletes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMixedOptions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumAll()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumFreqs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumOffsets()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumOffsetsWithoutPositions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumPayloads()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPostingsEnumPositions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandom()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRareVectors()</TD></TR>
<TR><TD ALIGN="LEFT" ># validOptions(): Set&lt;Options&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseTestCheckIndex450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseTestCheckIndex</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ testChecksumsOnly(dir: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testChecksumsOnlyVerbose(dir: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDeletedDocs(dir: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testObtainsLock(dir: Directory)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseTokenStreamFactoryTestCase1726600449[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseTokenStreamFactoryTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- analysisFactory(clazz: Class&lt;? extends AbstractAnalysisFactory&gt;, matchVersion: Version, loader: ResourceLoader, keysAndValues: String...): AbstractAnalysisFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># charFilterFactory(name: String, keysAndValues: String...): CharFilterFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># charFilterFactory(name: String, matchVersion: Version, loader: ResourceLoader, keysAndValues: String...): CharFilterFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># tokenFilterFactory(name: String, version: Version, keysAndValues: String...): TokenFilterFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># tokenFilterFactory(name: String, keysAndValues: String...): TokenFilterFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># tokenFilterFactory(name: String, matchVersion: Version, loader: ResourceLoader, keysAndValues: String...): TokenFilterFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># tokenizerFactory(name: String, keysAndValues: String...): TokenizerFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># tokenizerFactory(name: String, version: Version, keysAndValues: String...): TokenizerFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># tokenizerFactory(name: String, matchVersion: Version, loader: ResourceLoader, keysAndValues: String...): TokenizerFactory</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseTokenStreamTestCase1726600449[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseTokenStreamTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[], graphOffsetsAreCorrect: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[], graphOffsetsAreCorrect: boolean, payloads: byte[][])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[], types: String[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[], posIncrements: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[], startOffsets: int[], endOffsets: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesTo(a: Analyzer, input: String, output: String[], startOffsets: int[], endOffsets: int[], posIncrements: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesToPositions(a: Analyzer, input: String, output: String[], posIncrements: int[], posLengths: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAnalyzesToPositions(a: Analyzer, input: String, output: String[], types: String[], posIncrements: int[], posLengths: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertGraphStrings(analyzer: Analyzer, text: String, expectedStrings: String...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertGraphStrings(tokenStream: TokenStream, expectedStrings: String...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertStreamHasNumberOfTokens(ts: TokenStream, expectedCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[], finalOffset: Integer, finalPosInc: Integer, keywordAtts: boolean[], graphOffsetsAreCorrect: boolean, payloads: byte[][], flags: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[], finalOffset: Integer, keywordAtts: boolean[], graphOffsetsAreCorrect: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[], finalOffset: Integer, finalPosInc: Integer, keywordAtts: boolean[], graphOffsetsAreCorrect: boolean, payloads: byte[][])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[], finalOffset: Integer, graphOffsetsAreCorrect: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[], finalOffset: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], finalOffset: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], types: String[], posIncrements: int[], posLengths: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], types: String[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], posIncrements: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], finalOffset: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], posIncrements: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], posIncrements: int[], finalOffset: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTokenStreamContents(ts: TokenStream, output: String[], startOffsets: int[], endOffsets: int[], posIncrements: int[], posLengths: int[], finalOffset: Integer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkAnalysisConsistency(random: Random, a: Analyzer, useCharFilter: boolean, text: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkAnalysisConsistency(random: Random, a: Analyzer, useCharFilter: boolean, text: String, graphOffsetsAreCorrect: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkAnalysisConsistency(random: Random, a: Analyzer, useCharFilter: boolean, text: String, graphOffsetsAreCorrect: boolean, field: Field)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkOneTerm(a: Analyzer, input: String, expected: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkRandomData(random: Random, a: Analyzer, iterations: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkRandomData(random: Random, a: Analyzer, iterations: int, maxWordLength: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkRandomData(random: Random, a: Analyzer, iterations: int, simple: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkRandomData(random: Random, a: Analyzer, iterations: int, maxWordLength: int, simple: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkRandomData(random: Random, a: Analyzer, iterations: int, maxWordLength: int, simple: boolean, graphOffsetsAreCorrect: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkRandomData(random: Random, a: Analyzer, iterations: int, maxWordLength: int, useCharFilter: boolean, simple: boolean, graphOffsetsAreCorrect: boolean, iw: RandomIndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkResetException(a: Analyzer, input: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ escape(s: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getGraphStrings(analyzer: Analyzer, text: String): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getGraphStrings(tokenStream: TokenStream): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># keywordMockTokenizer(input: Reader): MockTokenizer</TD></TR>
<TR><TD ALIGN="LEFT" ># keywordMockTokenizer(input: String): MockTokenizer</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAttributeFactory(random: Random): AttributeFactory</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAttributeFactory(): AttributeFactory</TD></TR>
<TR><TD ALIGN="LEFT" ># toDot(a: Analyzer, inputText: String): String</TD></TR>
<TR><TD ALIGN="LEFT" ># toDotFile(a: Analyzer, inputText: String, localFileName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- toIntArray(list: List&lt;Integer&gt;): int[]</TD></TR>
<TR><TD ALIGN="LEFT" ># whitespaceMockTokenizer(input: Reader): MockTokenizer</TD></TR>
<TR><TD ALIGN="LEFT" ># whitespaceMockTokenizer(input: String): MockTokenizer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BaseXYPointTestCase1752419662[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BaseXYPointTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addPointToDoc(field: String, doc: Document, x: float, y: float)</TD></TR>
<TR><TD ALIGN="LEFT" >- buildError(docID: int, expected: boolean, id: int, xs: float[], ys: float[], query: Query, liveDocs: Bits, explain: Consumer&lt;StringBuilder&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># cartesianDistance(x1: double, y1: double, x2: double, y2: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >- doRandomDistanceTest(numDocs: int, numQueries: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- doTestRandom(count: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- indexPoints(xs: float[], ys: float[], deleted: Set&lt;Integer&gt;, w: IndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" ># newDistanceQuery(field: String, centerX: float, centerY: float, radius: float): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newGeometryQuery(field: String, geometries: XYGeometry...): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newPolygonQuery(field: String, polygon: XYPolygon...): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># newRectQuery(field: String, minX: float, maxX: float, minY: float, maxY: float): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># nextBox(): XYRectangle</TD></TR>
<TR><TD ALIGN="LEFT" ># nextGeometry(): XYGeometry[]</TD></TR>
<TR><TD ALIGN="LEFT" ># nextPolygon(): XYPolygon</TD></TR>
<TR><TD ALIGN="LEFT" ># nextX(): float</TD></TR>
<TR><TD ALIGN="LEFT" ># nextY(): float</TD></TR>
<TR><TD ALIGN="LEFT" ># rectContainsPoint(rect: XYRectangle, x: double, y: double): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- searchIndex(s: IndexSearcher, query: Query, maxDoc: int): FixedBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >- searchSmallSet(query: Query, size: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAllXEqual()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testAllYEqual()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBoxBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBoxInvalidCoordinates()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testBoxNull()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceIllegal()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceInf()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceNaN()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceNegative()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDistanceNull()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testEquals()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexExtremeValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexInfValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testIndexNaNValues()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testLowCardinality()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMultiPolygonBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testMultiValued()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPolygonBasics()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPolygonHole()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPolygonHoleExcludes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testPolygonNullField()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomBig()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomDistance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomDistanceHuge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomMedium()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRandomTiny()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testRectBoundariesAreInclusive()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSamePointManyTimes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetDistance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetHugeDistance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetMultiValued()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetPoly()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetPolyWholeSpace()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetRect()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetRect2()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetTinyDistance()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testSmallSetWholeSpace()</TD></TR>
<TR><TD ALIGN="LEFT" >- verify(xs: float[], ys: float[])</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyRandomDistances(xs: float[], ys: float[])</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyRandomGeometries(xs: float[], ys: float[])</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyRandomPolygons(xs: float[], ys: float[])</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyRandomRectangles(xs: float[], ys: float[])</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BinaryDVs815682522[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BinaryDVs</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   offsets: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   values: BytesRefArray [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BinaryDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BinaryDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ binaryValue(): BytesRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BinaryRangeDocValues14040943[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BinaryRangeDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: BinaryDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBytesPerDimension: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDims: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packedValue: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ binaryValue(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeRanges()</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BitDocIdSet2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BitDocIdSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cost: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   set: BitSet [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bits(): BitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BitSet2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BitSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ approximateCardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ cardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># checkUnpositioned(iter: DocIdSetIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(i: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(startIndex: int, endIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAndSet(i: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextSetBit(index: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(it: DocIdSetIterator, maxDoc: int): BitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ or(iter: DocIdSetIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >+ prevSetBit(index: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BitsSlice250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BitsSlice</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   length: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   parent: Bits [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   start: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(doc: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlockHeader157807647[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlockHeader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   baseDocsFP: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   basePayloadsFP: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   basePositionsFP: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   linesCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   middleLineIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   middleLineOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termStatesBaseOffset: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># reset(linesCount: int, baseDocsFP: long, basePositionsFP: long, basePayloadsFP: long, termStatesBaseOffset: int, middleTermOffset: int): BlockHeader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlockLine157807647[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlockLine</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   termBytes: TermBytes [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termState: BlockTermState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termStateRelativeOffset: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># reset(termBytes: TermBytes, termStateRelativeOffset: int): BlockLine</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlockReader157807647[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlockReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blockDecoder: BlockDecoder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockFirstLineStart: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockHeader: BlockHeader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockHeaderReader: Serializer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockInput: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockLine: BlockLine [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockLineReader: Serializer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockReadBuffer: ByteArrayDataInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockStartFP: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dictionaryBrowser: Browser [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dictionaryBrowserSupplier: BrowserSupplier [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldMetadata: FieldMetadata [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   forcedTerm: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lineIndexInBlock: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsReader: PostingsReaderBase [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratchBlockBytes: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratchBlockLine: BlockLine [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratchTermState: BlockTermState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termState: BlockTermState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termStateForced: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termStateSerializer: DeltaBaseTermStateSerializer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termStatesReadBuffer: ByteArrayDataInput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># clearTermState()</TD></TR>
<TR><TD ALIGN="LEFT" ># compareToMiddleAndJump(searchedTerm: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" ># createBlockHeaderSerializer(): Serializer</TD></TR>
<TR><TD ALIGN="LEFT" ># createBlockLineSerializer(): Serializer</TD></TR>
<TR><TD ALIGN="LEFT" ># createDeltaBaseTermStateSerializer(): DeltaBaseTermStateSerializer</TD></TR>
<TR><TD ALIGN="LEFT" ># decodeBlockBytesIfNeeded(numBlockBytes: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" ># initializeBlockReadLazily()</TD></TR>
<TR><TD ALIGN="LEFT" ># initializeHeader(searchedTerm: BytesRef, targetBlockStartFP: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># isBeyondLastTerm(searchedTerm: BytesRef, blockStartFP: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isCurrentTerm(searchedTerm: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># newCorruptIndexException(msg: String, fp: Long): CorruptIndexException</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" ># nextTerm(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readHeader(): BlockHeader</TD></TR>
<TR><TD ALIGN="LEFT" ># readLineInBlock(): BlockLine</TD></TR>
<TR><TD ALIGN="LEFT" ># readTermState(): BlockTermState</TD></TR>
<TR><TD ALIGN="LEFT" ># readTermStateIfNotRead(): BlockTermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(searchedTerm: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(searchedTerm: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># seekInBlock(searchedTerm: BytesRef, blockStartFP: long): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" ># seekInBlock(searchedTerm: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlockTermsReader625905195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlockTermsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: TreeMap&lt;String, FieldReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexReader: TermsIndexReaderBase [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsReader: PostingsReaderBase [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- seekDir(input: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BlockTreeOrdsPostingsFormat679407426[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BlockTreeOrdsPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   maxTermBlockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minTermBlockSize: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BloomFilteredFieldsConsumer2057373899[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BloomFilteredFieldsConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bloomFilters: Map&lt;FieldInfo, FuzzySet&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delegateFieldsConsumer: FieldsConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: SegmentWriteState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- saveAppropriatelySizedBloomFilter(bloomOutput: IndexOutput, bloomFilter: FuzzySet, fieldInfo: FieldInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fields: Fields, norms: NormsProducer)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BloomFilteredFieldsProducer2057373899[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BloomFilteredFieldsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bloomsByFieldName: HashMap&lt;String, FuzzySet&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delegateFieldsProducer: FieldsProducer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BloomFilteredTermsEnum1038637548[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BloomFilteredTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   delegateTerms: Terms [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delegateTermsEnum: TermsEnum [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   filter: FuzzySet [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- delegate(): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" ># reset(delegateTerms: Terms)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BloomFilteringPostingsFormat329228184[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BloomFilteringPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bloomFilterFactory: BloomFilterFactory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delegatePostingsFormat: PostingsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedBinaryDocValues815682522[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedBinaryDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bytesIterator: DataInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docsWithField: DocIdSetIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lengthsIterator: Iterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   value: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ binaryValue(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedInputIterator833569740[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedInputIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   contextSets: List&lt;Set&lt;BytesRef&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   curPos: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   entries: BytesRefArray [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   freqs: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasContexts: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadSpare: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   payloads: BytesRefArray [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   spare: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ contexts(): Set&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ payload(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ weight(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedNorms1391967427[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedNorms</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   docsWithField: DocIdSetIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   iter: Iterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedNumericDocValues647795726[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   docsWithField: DocIdSetIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   iter: Iterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedSortedDocValues1468564066[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedSortedDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   docsWithField: DocIdSetIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   hash: BytesRefHash [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   iter: Iterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ord: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ordMap: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedValues: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedSortedNumericDocValues1976607119[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedSortedNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   docsWithField: DocIdSetIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   valueCountsIter: Iterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueUpto: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   valuesIter: Iterator [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextValue(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedSortedSetDocValues1314305254[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedSortedSetDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   currentDoc: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docsWithField: DocIdSetIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   hash: BytesRefHash [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ordCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ordCountsIter: Iterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ordMap: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ordUpto: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ordsIter: Iterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedValues: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextOrd(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedUpdates250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedUpdates</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytesUsed: Counter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deleteQueries: Map&lt;Query, Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deleteTerms: Map&lt;Term, Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldUpdates: Map&lt;String, FieldUpdatesBuffer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldUpdatesBytesUsed: Counter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   gen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numFieldUpdates: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numTermDeletes: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segmentName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termsBytesUsed: Counter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addBinaryUpdate(update: BinaryDocValuesUpdate, docIDUpto: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># addNumericUpdate(update: NumericDocValuesUpdate, docIDUpto: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addQuery(query: Query, docIDUpto: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addTerm(term: Term, docIDUpto: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># any(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># clear()</TD></TR>
<TR><TD ALIGN="LEFT" ># clearDeleteTerms()</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferedUpdatesStream250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferedUpdatesStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytesUsed: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   finishedSegments: FinishedSegments [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numTerms: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   updates: Set&lt;FrozenBufferedUpdates&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># any(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- checkDeleteStats(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># clear()</TD></TR>
<TR><TD ALIGN="LEFT" ># finished(packet: FrozenBufferedUpdates)</TD></TR>
<TR><TD ALIGN="LEFT" ># finishedSegment(delGen: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># numTerms(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># push(packet: FrozenBufferedUpdates): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># stillRunning(delGen: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- waitApply(waitFor: Set&lt;FrozenBufferedUpdates&gt;, writer: IndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" ># waitApplyAll(writer: IndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" ># waitApplyForMerge(mergeInfos: List&lt;SegmentCommitInfo&gt;, writer: IndexWriter)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BufferingKnnVectorsWriter985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BufferingKnnVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: List&lt;FieldWriter&lt;?&gt;&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addField(fieldInfo: FieldInfo): KnnFieldVectorsWriter&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush(maxDoc: int, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeOneField(fieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># writeField(fieldInfo: FieldInfo, floatVectorValues: FloatVectorValues, maxDoc: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeField(fieldInfo: FieldInfo, byteVectorValues: ByteVectorValues, maxDoc: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder1141387501[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fields: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   state: SegmentWriteState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   suffix: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addField(field: String): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># build(): FieldsGroup</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Builder55156406[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Builder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   acceptableOverheadRatio: float [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pageMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pageShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pending: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingOff: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   size: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   values: Reader[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   valuesOff: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(l: long): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># baseRamBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(): PackedLongValues</TD></TR>
<TR><TD ALIGN="LEFT" ># finish()</TD></TR>
<TR><TD ALIGN="LEFT" ># grow(newBlockCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- pack()</TD></TR>
<TR><TD ALIGN="LEFT" ># pack(values: long[], numValues: int, block: int, acceptableOverheadRatio: float)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteArrayDataInput260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteArrayDataInput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytes: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   limit: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pos: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ eof(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readByte(): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ readBytes(b: byte[], offset: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readInt(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLong(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readShort(): short</TD></TR>
<TR><TD ALIGN="LEFT" >+ readVInt(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readVLong(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset(bytes: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset(bytes: byte[], offset: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rewind()</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipBytes(count: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteArrayDataOutput260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteArrayDataOutput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytes: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   limit: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pos: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ reset(bytes: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset(bytes: byte[], offset: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeByte(b: byte)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBytes(b: byte[], offset: int, length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeInt(i: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLong(i: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeShort(i: short)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteBlockPool2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteBlockPool</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   allocator: Allocator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   buffer: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bufferUpto: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   buffers: byte[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   byteOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   byteUpto: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ allocKnownSizeSlice(slice: byte[], upto: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ allocSlice(slice: byte[], upto: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ append(bytes: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSlice(size: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextBuffer()</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readBytes(offset: long, bytes: byte[], bytesOffset: int, bytesLength: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset(zeroFillBuffers: boolean, reuseFirst: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteBuffersDataInput260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteBuffersDataInput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockBits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blocks: ByteBuffer[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   floatBuffers: FloatBuffer[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   longBuffers: LongBuffer[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pos: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   size: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- blockIndex(pos: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >- blockOffset(pos: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >- blockSize(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># determineBlockPage(buffers: List&lt;ByteBuffer&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureAssumptions(buffers: List&lt;ByteBuffer&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- getFloatBuffer(pos: long): FloatBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >- getLongBuffer(pos: long): LongBuffer</TD></TR>
<TR><TD ALIGN="LEFT" >- isPowerOfTwo(v: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ position(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readByte(): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ readByte(pos: long): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ readBytes(buffer: ByteBuffer, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readBytes(arr: byte[], off: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readFloats(arr: float[], off: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readInt(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readInt(pos: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLong(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLong(pos: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLongs(arr: long[], off: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readShort(): short</TD></TR>
<TR><TD ALIGN="LEFT" >+ readShort(pos: long): short</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(position: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipBytes(numBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ slice(offset: long, length: long): ByteBuffersDataInput</TD></TR>
<TR><TD ALIGN="LEFT" >- sliceBufferList(buffers: List&lt;ByteBuffer&gt;, offset: long, length: long): List&lt;ByteBuffer&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteBuffersDataOutput260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteBuffersDataOutput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockAllocate: IntFunction&lt;ByteBuffer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockBits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockReuse: Consumer&lt;ByteBuffer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blocks: ArrayDeque&lt;ByteBuffer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentBlock: ByteBuffer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxBitsPerBlock: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- UTF16toUTF8(s: CharSequence, offset: int, length: int, buf: byte[], bufferFlusher: IntConsumer): int</TD></TR>
<TR><TD ALIGN="LEFT" >- appendBlock()</TD></TR>
<TR><TD ALIGN="LEFT" >- blockSize(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- computeBlockSizeBitsFor(bytes: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyBytes(input: DataInput, numBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyTo(output: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newResettableInstance(): ByteBuffersDataOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >- rewriteToBlockSize(targetBlockBits: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ toArrayCopy(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBufferList(): ArrayList&lt;ByteBuffer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ toDataInput(): ByteBuffersDataInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ toWriteableBufferList(): ArrayList&lt;ByteBuffer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeByte(b: byte)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBytes(src: byte[], offset: int, length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBytes(b: byte[], length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBytes(b: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBytes(buffer: ByteBuffer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeInt(v: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLong(v: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeMapOfStrings(map: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeSetOfStrings(set: Set&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeShort(v: short)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeString(v: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteSequenceIterator522240398[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteSequenceIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   reader: ByteSequencesReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ByteSequencesReader85288584[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ByteSequencesReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   end: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: ChecksumIndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ref: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BytesRef2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BytesRef</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   bytes: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   length: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   offset: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bytesEquals(other: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(other: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ deepCopyOf(other: BytesRef): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ utf8ToString(): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BytesRefArray2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BytesRefArray</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytesUsed: Counter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentOffset: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastElement: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offsets: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pool: ByteBlockPool [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ append(bytes: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(spare: BytesRefBuilder, index: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): BytesRefIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(comp: Comparator&lt;BytesRef&gt;): BytesRefIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(sortState: SortState): IndexedBytesRefIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ sort(comp: Comparator&lt;BytesRef&gt;, tieComparator: IntBinaryOperator): SortState</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BytesRefBuilder2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BytesRefBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ref: BytesRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ append(b: byte)</TD></TR>
<TR><TD ALIGN="LEFT" >+ append(b: byte[], off: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ append(ref: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ append(builder: BytesRefBuilder)</TD></TR>
<TR><TD ALIGN="LEFT" >+ byteAt(offset: int): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ bytes(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyBytes(b: byte[], off: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyBytes(ref: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyBytes(builder: BytesRefBuilder)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyChars(text: CharSequence)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyChars(text: CharSequence, off: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyChars(text: char[], off: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(capacity: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ toBytesRef(): BytesRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BytesRefHash2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BytesRefHash</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bytesStart: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesStartArray: BytesStartArray [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesUsed: Counter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashHalfSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ids: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pool: ByteBlockPool [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(bytes: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ addByPoolOffset(offset: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ byteStart(bytesID: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(resetPool: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ compact(): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >- doHash(bytes: byte[], offset: int, length: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ find(bytes: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >- findHash(bytes: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(bytesID: int, ref: BytesRef): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- rehash(newSize: int, hashOnData: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ reinit()</TD></TR>
<TR><TD ALIGN="LEFT" >- shrink(targetSize: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ sort(): int[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BytesRefHashIterator664386453[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BytesRefHashIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   scratch: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedTerms: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   terms: BytesRefHash [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   upto: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

BytesStore146897711[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)BytesStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockBits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blocks: List&lt;byte[]&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   current: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextWrite: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ copyBytes(input: DataInput, numBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyBytes(src: long, dest: long, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyBytes(src: long, dest: byte[], offset: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" ># getReverseReader(allowSingle: boolean): BytesReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ reverse(srcPos: long, destPos: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipBytes(len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ truncate(newLen: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeByte(dest: long, b: byte)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeByte(b: byte)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBytes(b: byte[], offset: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeBytes(dest: long, b: byte[], offset: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeInt(pos: long, value: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(out: DataOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CacheAndCount915011271[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CacheAndCount</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: DocIdSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ count(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CachedOrdinalsReader1914416286[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CachedOrdinalsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ordsCache: Map&lt;Object, CachedOrds&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   source: OrdinalsReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- getCachedOrds(context: LeafReaderContext): CachedOrds</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReader(context: LeafReaderContext): OrdinalsSegmentReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CachedOrds1498707127[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CachedOrds</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   offsets: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   ordinals: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CellToBytesRefIterator1037972046[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CellToBytesRefIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bytesRef: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cellIter: Iterator&lt;Cell&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset(cellIter: Iterator&lt;Cell&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CharsRefBuilder2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CharsRefBuilder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ref: CharsRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ append(csq: CharSequence): CharsRefBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ append(csq: CharSequence, start: int, end: int): CharsRefBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ append(c: char): CharsRefBuilder</TD></TR>
<TR><TD ALIGN="LEFT" >+ append(otherChars: char[], otherOffset: int, otherLength: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ charAt(offset: int): char</TD></TR>
<TR><TD ALIGN="LEFT" >+ chars(): char[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyChars(other: CharsRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyChars(otherChars: char[], otherOffset: int, otherLength: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyUTF8Bytes(bytes: byte[], offset: int, length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyUTF8Bytes(bytes: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ grow(newLength: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ toCharsRef(): CharsRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CheapBastardCodec830865138[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CheapBastardCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   postings: PostingsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Codec985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ availableCodecs(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ forName(name: String): Codec</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ reloadCodecs(classloader: ClassLoader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CodecReader250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CodecReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" ># doClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinaryDocValues(field: String): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getDVField(field: String, type: DocValuesType): FieldInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNormValues(field: String): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumericDocValues(field: String): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPointValues(field: String): PointValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedDocValues(field: String): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumericDocValues(field: String): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSetDocValues(field: String): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTermVectors(docID: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" >+ searchNearestVectors(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ searchNearestVectors(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFields(): StoredFields</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectors(): TermVectors</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CodecUtil985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CodecUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkFooter(in: ChecksumIndexInput): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkFooter(in: ChecksumIndexInput, priorException: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkHeader(in: DataInput, codec: String, minVersion: int, maxVersion: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkHeaderNoMagic(in: DataInput, codec: String, minVersion: int, maxVersion: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIndexHeader(in: DataInput, codec: String, minVersion: int, maxVersion: int, expectedID: byte[], expectedSuffix: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIndexHeaderID(in: DataInput, expectedID: byte[]): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIndexHeaderSuffix(in: DataInput, expectedSuffix: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ checksumEntireFile(input: IndexInput): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ footerLength(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ headerLength(codec: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ indexHeaderLength(codec: String, suffix: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readBEInt(in: DataInput): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readBELong(in: DataInput): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readCRC(input: IndexInput): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readFooter(in: IndexInput): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ readIndexHeader(in: IndexInput): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ retrieveChecksum(in: IndexInput): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ retrieveChecksum(in: IndexInput, expectedLength: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- validateFooter(in: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ verifyAndCopyIndexHeader(in: IndexInput, out: DataOutput, expectedID: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBEInt(out: DataOutput, i: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBELong(out: DataOutput, l: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeCRC(output: IndexOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeFooter(out: IndexOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeHeader(out: DataOutput, codec: String, version: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeIndexHeader(out: DataOutput, codec: String, version: int, id: byte[], suffix: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CollationTestBase1726600449[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CollationTestBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   firstRangeBeginningOriginal: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   firstRangeEndOriginal: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   secondRangeBeginningOriginal: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   secondRangeEndOriginal: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ assertThreadSafe(analyzer: Analyzer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFarsiRangeFilterCollating(analyzer: Analyzer, firstBeg: BytesRef, firstEnd: BytesRef, secondBeg: BytesRef, secondEnd: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFarsiRangeQueryCollating(analyzer: Analyzer, firstBeg: BytesRef, firstEnd: BytesRef, secondBeg: BytesRef, secondEnd: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testFarsiTermRangeQuery(analyzer: Analyzer, firstBeg: BytesRef, firstEnd: BytesRef, secondBeg: BytesRef, secondEnd: BytesRef)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CollectionUtil2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CollectionUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ introSort(list: List&lt;T&gt;, comp: Comparator&lt;? super T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ introSort(list: List&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newHashMap(size: int): HashMap&lt;K, V&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ newHashSet(size: int): HashSet&lt;E&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ timSort(list: List&lt;T&gt;, comp: Comparator&lt;? super T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ timSort(list: List&lt;T&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CombinedFieldQuery786328997[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CombinedFieldQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fieldAndWeights: TreeMap&lt;String, FieldAndWeight&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldTerms: Term[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   terms: BytesRef[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ rewrite(reader: IndexReader): Query</TD></TR>
<TR><TD ALIGN="LEFT" >- rewriteToBoolean(): BooleanQuery</TD></TR>
<TR><TD ALIGN="LEFT" >- validateConsistentNorms(reader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompiledAutomaton1522148614[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompiledAutomaton</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   automaton: Automaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   commonSuffixRef: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   finite: Boolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   runAutomaton: ByteRunAutomaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   sinkState: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   term: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   transition: Transition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   type: AUTOMATON_TYPE [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addTail(state: int, term: BytesRefBuilder, idx: int, leadLabel: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >- findSinkState(automaton: Automaton): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ floor(input: BytesRef, output: BytesRefBuilder): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTermsEnum(terms: Terms): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor, parent: Query, field: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Completion50PostingsFormat1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Completion50PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># delegatePostingsFormat(): PostingsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Completion84PostingsFormat1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Completion84PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># delegatePostingsFormat(): PostingsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Completion90PostingsFormat1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Completion90PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># delegatePostingsFormat(): PostingsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompletionFieldsConsumer1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompletionFieldsConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   codecName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delegateFieldsConsumer: FieldsConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delegatePostingsFormatName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dictOut: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   seenFields: Map&lt;String, CompletionMetaData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: SegmentWriteState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fields: Fields, norms: NormsProducer)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompletionFieldsProducer1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompletionFieldsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   delegateFieldsProducer: FieldsProducer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dictIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readers: Map&lt;String, CompletionsTermsReader&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompletionPostingsFormat1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompletionPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fstLoadMode: FSTLoadMode [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># delegatePostingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompletionsTermsReader1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompletionsTermsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dictIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstLoadMode: FSTLoadMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   maxWeight: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   minWeight: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   suggester: NRTSuggester [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   type: byte [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ suggester(): NRTSuggester</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompoundDirectory985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompoundDirectory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ createOutput(name: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempOutput(prefix: String, suffix: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFile(name: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ obtainLock(name: String): Lock</TD></TR>
<TR><TD ALIGN="LEFT" >+ rename(from: String, to: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sync(names: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncMetaData()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompoundFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompoundFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getCompoundReader(dir: Directory, si: SegmentInfo, context: IOContext): CompoundDirectory</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressedBinaryBlockWriter405642323[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressedBinaryBlockWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   block: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockAddressesStart: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docLengths: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ht: FastCompressionHashTable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxUncompressedBlockLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numDocsInCurrentBlock: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempBinaryOffsets: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   totalChunks: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   uncompressedBlockLength: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addDoc(doc: int, v: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- flushData()</TD></TR>
<TR><TD ALIGN="LEFT" ># writeMetaData()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressingCodec673666990[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressingCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: Lucene90CompressingStoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termVectorsFormat: Lucene90CompressingTermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ randomInstance(random: Random, chunkSize: int, maxDocsPerChunk: int, withSegmentSuffix: boolean, blockShift: int): CompressingCodec</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomInstance(random: Random): CompressingCodec</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomInstance(random: Random, withSegmentSuffix: boolean): CompressingCodec</TD></TR>
<TR><TD ALIGN="LEFT" >+ reasonableInstance(random: Random): CompressingCodec</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressionMode1091407211[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressionMode</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ newCompressor(): Compressor</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDecompressor(): Decompressor</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CompressionMode1687999461[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CompressionMode</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ newCompressor(): Compressor</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDecompressor(): Decompressor</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConfigurableMCodec346484465[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConfigurableMCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   knnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ConsumerAndSuffix439672098[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ConsumerAndSuffix</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   consumer: DocValuesConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   suffix: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ContextQuery1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ContextQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   contexts: Map&lt;IntsRef, ContextMetaData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   innerQuery: CompletionQuery [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   matchAllContexts: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: IntsRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAllContexts()</TD></TR>
<TR><TD ALIGN="LEFT" >+ addContext(context: CharSequence)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addContext(context: CharSequence, boost: float)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addContext(context: CharSequence, boost: float, exact: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- toContextAutomaton(contexts: Map&lt;IntsRef, ContextMetaData&gt;, matchAllContexts: boolean): Automaton</TD></TR>
<TR><TD ALIGN="LEFT" >- updateRamBytesUsed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CopyState1813495465[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CopyState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   completedMergeFiles: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   files: Map&lt;String, FileMetaData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   gen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   infos: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   infosBytes: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   primaryGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   version: long [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Counter2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Counter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAndGet(delta: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ newCounter(): Counter</TD></TR>
<TR><TD ALIGN="LEFT" >+ newCounter(threadSafe: boolean): Counter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CoveringQuery786328997[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CoveringQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   hashCode: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minimumNumberMatch: LongValuesSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queries: Collection&lt;Query&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- computeHashCode(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ rewrite(reader: IndexReader): Query</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyCodec185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyCompoundFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyCompoundFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getCompoundReader(dir: Directory, si: SegmentInfo, context: IOContext): CompoundDirectory</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyDocValuesConsumer562316335[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyDocValuesConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: DocValuesConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedSetField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyDocValuesFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyDocValuesFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): DocValuesProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyFieldInfosFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyFieldInfosFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, iocontext: IOContext): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, infos: FieldInfos, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyLiveDocsFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyLiveDocsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ files(info: SegmentCommitInfo, files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLiveDocs(dir: Directory, info: SegmentCommitInfo, context: IOContext): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLiveDocs(bits: Bits, dir: Directory, info: SegmentCommitInfo, newDelCount: int, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyNormsFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyNormsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ normsConsumer(state: SegmentWriteState): NormsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsProducer(state: SegmentReadState): NormsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyPointsFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyPointsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: PointsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): PointsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): PointsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyPostingsFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankySegmentInfoFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankySegmentInfoFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentName: String, segmentID: byte[], context: IOContext): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, info: SegmentInfo, ioContext: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyStoredFieldsFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyStoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyStoredFieldsWriter1067712659[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyStoredFieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: StoredFieldsWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: float)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: double)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyTermVectorsFormat185529096[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyTermVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: TermVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ vectorsReader(directory: Directory, segmentInfo: SegmentInfo, fieldInfos: FieldInfos, context: IOContext): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorsWriter(directory: Directory, segmentInfo: SegmentInfo, context: IOContext): TermVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

CrankyTermVectorsWriter1832214875[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)CrankyTermVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: TermVectorsWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addPosition(position: int, startOffset: int, endOffset: int, payload: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProx(numProx: int, positions: DataInput, offsets: DataInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishField()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishTerm()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument(numVectorFields: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startField(info: FieldInfo, numTerms: int, positions: boolean, offsets: boolean, payloads: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startTerm(term: BytesRef, freq: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DataInput260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DataInput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): DataInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ readByte(): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ readBytes(b: byte[], offset: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readBytes(b: byte[], offset: int, len: int, useBuffer: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readFloats(floats: float[], offset: int, len: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readInt(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readInts(dst: int[], offset: int, length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLong(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLongs(dst: long[], offset: int, length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readMapOfStrings(): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readSetOfStrings(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readShort(): short</TD></TR>
<TR><TD ALIGN="LEFT" >+ readString(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ readVInt(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readVLong(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readVLong(allowNegative: boolean): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readZInt(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readZLong(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipBytes(numBytes: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DataOutput260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DataOutput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   copyBuffer: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ copyBytes(input: DataInput, numBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeByte(b: byte)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBytes(b: byte[], length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBytes(b: byte[], offset: int, length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeInt(i: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLong(i: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeMapOfStrings(map: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeSetOfStrings(set: Set&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeShort(i: short)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeSignedVLong(i: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeString(s: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeVInt(i: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeVLong(i: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeZInt(i: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeZLong(i: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DefaultSortedSetDocValuesReaderState1241185064[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DefaultSortedSetDocValuesReaderState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cachedOrdMaps: Map&lt;String, OrdinalMap&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: FacetsConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   prefixToDimTree: Map&lt;String, DimTree&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   prefixToOrdRange: Map&lt;String, OrdRange&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   reader: IndexReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- createOneFlatFacetDimState(dv: SortedSetDocValues, dimStartOrd: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- createOneHierarchicalFacetDimState(dv: SortedSetDocValues, dimStartOrd: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDimTree(dim: String): DimTree</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOrdRange(dim: String): OrdRange</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DeflateWithPresetCompressingCodec673666990[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DeflateWithPresetCompressingCodec</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DelegatingCacheHelper164815750[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DelegatingCacheHelper</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cacheKey: CacheKey [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delegate: CacheHelper [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addClosedListener(listener: ClosedListener)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DeltaBaseTermStateSerializer157807647[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DeltaBaseTermStateSerializer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   baseDocStartFP: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   basePayStartFP: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   basePosStartFP: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(termState: TermState): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ readTermState(baseDocStartFP: long, basePosStartFP: long, basePayStartFP: long, termStatesInput: DataInput, fieldInfo: FieldInfo, reuse: BlockTermState): BlockTermState</TD></TR>
<TR><TD ALIGN="LEFT" ># reset(termState: IntBlockTermState): IntBlockTermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetBaseStartFP()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTermState(termStatesOutput: DataOutput, fieldInfo: FieldInfo, termState: BlockTermState)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DenseBinaryDocValues841633975[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DenseBinaryDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   doc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DenseNormsIterator371244166[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DenseNormsIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   doc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DenseNumericDocValues841633975[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DenseNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   doc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectField530590557[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectField</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   count: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasFreq: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasOffsets: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPos: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minSkipCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sameCounts: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   skipCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   skipOffsets: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   skips: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sumDocFreq: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sumTotalTermFreq: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termBytes: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termOffsets: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   terms: TermAndSkip[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># compare(ord: int, other: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >- finishSkips()</TD></TR>
<TR><TD ALIGN="LEFT" >+ intersect(compiled: CompiledAutomaton, startTerm: BytesRef): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- saveSkip(ord: int, backCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectFields530590557[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, DirectField&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectIntersectTermsEnum181433766[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectIntersectTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compiledAutomaton: CompiledAutomaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   runAutomaton: RunAutomaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stateUpto: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   states: State[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termOrd: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- grow()</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(term: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectMonotonicReader611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectMonotonicReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   avgs: float[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockMask: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bpvs: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mins: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonZeroBpvs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readers: LongValues[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ binarySearch(fromIndex: long, toIndex: long, key: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getBounds(index: long): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInstance(meta: Meta, data: RandomAccessInput): DirectMonotonicReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInstance(meta: Meta, data: RandomAccessInput, merging: boolean): DirectMonotonicReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ loadMeta(metaIn: IndexInput, numValues: long, blockShift: int): Meta</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectMonotonicWriter611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectMonotonicWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   baseDataPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   buffer: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bufferSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   data: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   finished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   meta: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numValues: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   previous: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(v: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >- flush()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInstance(metaOut: IndexOutput, dataOut: IndexOutput, numValues: long, blockShift: int): DirectMonotonicWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPacked64SingleBlockReader611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPacked64SingleBlockReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitsPerValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mask: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valuesPerBlock: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader12748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader12</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader16748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader16</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader1748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader1</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader20748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader20</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader24748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader24</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader2748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader2</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader28748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader28</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader32748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader32</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader40748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader40</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader4748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader4</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader48748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader48</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader56748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader56</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bitsPerValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   startPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   valueMask: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader64748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader64</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPackedReader8748024224[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPackedReader8</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectPostingsFormat1307742404[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   lowFreqCutoff: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minSkipCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectTermsEnum181433766[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termOrd: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- findTerm(term: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(term: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >- setTerm(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectWriter611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bitsPerValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   finished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nextBlocks: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nextValues: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numValues: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   off: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   output: DataOutput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(l: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ bitsRequired(maxValue: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >- encode(nextValues: long[], upTo: int, nextBlocks: byte[], bitsPerValue: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >- flush()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInstance(output: DataOutput, numValues: long, bitsPerValue: int): DirectWriter</TD></TR>
<TR><TD ALIGN="LEFT" >- roundBits(bitsRequired: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsignedBitsRequired(maxValue: long): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Directory260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Directory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(from: Directory, src: String, dest: String, context: IOContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createOutput(name: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempOutput(prefix: String, suffix: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFile(name: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" >+ fileLength(name: String): long</TD></TR>
<TR><TD ALIGN="LEFT" ># getTempFileName(prefix: String, suffix: String, counter: long): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ listAll(): String[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ obtainLock(name: String): Lock</TD></TR>
<TR><TD ALIGN="LEFT" >+ openChecksumInput(name: String, context: IOContext): ChecksumIndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ openInput(name: String, context: IOContext): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ rename(source: String, dest: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ sync(names: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncMetaData()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectoryTaxonomyReader91058461[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectoryTaxonomyReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   categoryCache: LRUHashMap&lt;Integer, FacetLabel&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexReader: DirectoryReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ordinalCache: LRUHashMap&lt;FacetLabel, Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   taxoArrays: TaxonomyIndexArrays [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   taxoEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   taxoWriter: DirectoryTaxonomyWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkOrdinalBounds(ordinals: int...)</TD></TR>
<TR><TD ALIGN="LEFT" ># doClose()</TD></TR>
<TR><TD ALIGN="LEFT" ># doOpenIfChanged(): DirectoryTaxonomyReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBulkPath(ordinals: int...): FacetLabel[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOrdinal(cp: FacetLabel): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPath(ordinal: int): FacetLabel</TD></TR>
<TR><TD ALIGN="LEFT" >- getPathFromCache(ordinals: int...): FacetLabel[]</TD></TR>
<TR><TD ALIGN="LEFT" ># openIndexReader(directory: Directory): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># openIndexReader(writer: IndexWriter): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DirectoryTaxonomyWriter91058461[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DirectoryTaxonomyWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: TaxonomyWriterCache [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheIsComplete: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheMisses: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheMissesUntilFill: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fullPathField: Field [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexEpoch: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexWriter: IndexWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initializedReaderManager: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isClosed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextID: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   parentStream: SinglePositionTokenStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   parentStreamField: Field [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readerManager: ReaderManager [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   shouldFillCache: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   shouldRefreshReaderManager: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   taxoArrays: TaxonomyIndexArrays [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   useOlderFormat: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addCategory(categoryPath: FacetLabel): int</TD></TR>
<TR><TD ALIGN="LEFT" >- addCategoryDocument(categoryPath: FacetLabel, parent: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ addTaxonomy(taxoDir: Directory, map: OrdinalMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- addToCache(categoryPath: FacetLabel, id: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># closeResources()</TD></TR>
<TR><TD ALIGN="LEFT" >- combinedCommitData(commitData: Iterable&lt;Entry&lt;String, String&gt;&gt;): Iterable&lt;Entry&lt;String, String&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># createIndexWriterConfig(openMode: OpenMode): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ defaultTaxonomyWriterCache(): TaxonomyWriterCache</TD></TR>
<TR><TD ALIGN="LEFT" >- doClose()</TD></TR>
<TR><TD ALIGN="LEFT" ># ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" ># findCategory(categoryPath: FacetLabel): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getParent(ordinal: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- initReaderManager()</TD></TR>
<TR><TD ALIGN="LEFT" >- internalAddCategory(cp: FacetLabel): int</TD></TR>
<TR><TD ALIGN="LEFT" ># openIndexWriter(directory: Directory, config: IndexWriterConfig): IndexWriter</TD></TR>
<TR><TD ALIGN="LEFT" >- perhapsFillCache()</TD></TR>
<TR><TD ALIGN="LEFT" >+ prepareCommit(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- refreshReaderManager()</TD></TR>
<TR><TD ALIGN="LEFT" >+ replaceTaxonomy(taxoDir: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rollback()</TD></TR>
<TR><TD ALIGN="LEFT" >+ useNumericDocValuesForOrdinals(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocIDMerger250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocIDMerger&lt;T extends DocIDMerger.Sub&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ next(): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(subs: List&lt;T&gt;, maxCount: int, indexIsSorted: boolean): DocIDMerger&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(subs: List&lt;T&gt;, indexIsSorted: boolean): DocIDMerger&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocIdSet536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocIdSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ all(maxDoc: int): DocIdSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ bits(): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocIdSetIterator536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocIdSetIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ all(maxDoc: int): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ empty(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ range(minDoc: int, maxDoc: int): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" ># slowAdvance(target: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocMap149786621[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocMap</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ newToOld(docID: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ oldToNew(docID: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocMap2115590293[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocMap</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(docID: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkField(in: LeafReader, field: String, expected: DocValuesType...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ emptyBinary(): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ emptyNumeric(): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ emptySorted(): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ emptySortedNumeric(): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ emptySortedSet(): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(reader: LeafReader, field: String): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(reader: LeafReader, field: String): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(reader: LeafReader, field: String): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(reader: LeafReader, field: String): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(reader: LeafReader, field: String): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ isCacheable(ctx: LeafReaderContext, fields: String...): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ singleton(dv: SortedDocValues): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ singleton(dv: NumericDocValues): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrapSingleton(dv: SortedSetDocValues): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrapSingleton(dv: SortedNumericDocValues): NumericDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocValuesConsumer985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocValuesConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedSetField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSingleValued(docToValueCount: Iterable&lt;Number&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeBinaryField(mergeFieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeNumericField(mergeFieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeNumericValues(subs: List&lt;NumericDocValuesSub&gt;, indexIsSorted: boolean): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeSortedField(fieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeSortedNumericField(mergeFieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeSortedSetField(mergeFieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeSortedValues(subs: List&lt;SortedDocValuesSub&gt;, indexIsSorted: boolean, map: OrdinalMap): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ singletonView(docToValueCount: Iterable&lt;Number&gt;, values: Iterable&lt;Number&gt;, missingValue: Number): Iterable&lt;Number&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocValuesFieldUpdates250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocValuesFieldUpdates</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitsPerValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   delGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docs: PagedMutable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   finished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   size: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   type: DocValuesType [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># add(doc: int, value: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># add(doc: int, value: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" ># add(docId: int, iterator: Iterator)</TD></TR>
<TR><TD ALIGN="LEFT" ># add(doc: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- addInternal(doc: int, hasValueMask: long): int</TD></TR>
<TR><TD ALIGN="LEFT" ># any(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># ensureFinished()</TD></TR>
<TR><TD ALIGN="LEFT" ># finish()</TD></TR>
<TR><TD ALIGN="LEFT" ># grow(size: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># iterator(): Iterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergedIterator(subs: Iterator[]): Iterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># reset(doc: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># resize(size: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># size(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># swap(i: int, j: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocValuesFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocValuesFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ availableDocValuesFormats(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): DocValuesProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ forName(name: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ reloadDocValuesFormats(classloader: ClassLoader)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocValuesIterator250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocValuesIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocValuesProducer985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocValuesProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(field: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(field: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(field: FieldInfo): SortedSetDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocsWithFieldSet250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocsWithFieldSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cardinality: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDocId: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   set: FixedBitSet [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(docID: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ cardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocumentInputIterator1681937451[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocumentInputIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentContexts: Set&lt;BytesRef&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentDocFields: IndexableField[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentDocId: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentPayload: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentWeight: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasContexts: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocs: Bits [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nextFieldsPosition: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   relevantFields: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   weightValues: NumericDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ contexts(): Set&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getRelevantFields(fields: String...): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getWeight(doc: Document, docId: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ payload(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ weight(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocumentsWriter250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocumentsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: LiveIndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentFullFlushDelQueue: DocumentsWriterDeleteQueue [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deleteQueue: DocumentsWriterDeleteQueue [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   flushControl: DocumentsWriterFlushControl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushNotifications: FlushNotifications [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocsInRAM: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingChangesInCurrentFullFlush: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingNumDocs: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   perThreadPool: DocumentsWriterPerThreadPool [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ticketQueue: DocumentsWriterFlushQueue [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># abort()</TD></TR>
<TR><TD ALIGN="LEFT" >- abortDocumentsWriterPerThread(perThread: DocumentsWriterPerThread)</TD></TR>
<TR><TD ALIGN="LEFT" ># anyChanges(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># anyDeletions(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- applyAllDeletes(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- applyDeleteOrUpdate(function: ToLongFunction&lt;DocumentsWriterDeleteQueue&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >- assertTicketQueueModification(deleteQueue: DocumentsWriterDeleteQueue): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># deleteQueries(queries: Query...): long</TD></TR>
<TR><TD ALIGN="LEFT" ># deleteTerms(terms: Term...): long</TD></TR>
<TR><TD ALIGN="LEFT" >- doFlush(flushingDWPT: DocumentsWriterPerThread): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" ># finishFullFlush(success: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># flushAllThreads(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># flushOneDWPT(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># lockAndAbortAll(): Closeable</TD></TR>
<TR><TD ALIGN="LEFT" >- postUpdate(flushingDWPT: DocumentsWriterPerThread, hasEvents: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- preUpdate(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># purgeFlushTickets(forced: boolean, consumer: IOConsumer&lt;FlushTicket&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># resetDeleteQueue(newQueue: DocumentsWriterDeleteQueue)</TD></TR>
<TR><TD ALIGN="LEFT" >- setFlushingDeleteQueue(session: DocumentsWriterDeleteQueue): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># subtractFlushedNumDocs(numFlushed: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># updateDocValues(updates: DocValuesUpdate...): long</TD></TR>
<TR><TD ALIGN="LEFT" ># updateDocuments(docs: Iterable&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;, delNode: Node&lt;?&gt;): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocumentsWriterDeleteQueue250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocumentsWriterDeleteQueue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   advanced: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   generation: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   globalBufferLock: ReentrantLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   globalBufferedUpdates: BufferedUpdates [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   globalSlice: DeleteSlice [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSeqNo: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextSeqNo: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   previousMaxSeqId: LongSupplier [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startSeqNo: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tail: Node&lt;?&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># add(deleteNode: Node&lt;?&gt;, slice: DeleteSlice): long</TD></TR>
<TR><TD ALIGN="LEFT" ># add(newNode: Node&lt;?&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" ># addDelete(queries: Query...): long</TD></TR>
<TR><TD ALIGN="LEFT" ># addDelete(terms: Term...): long</TD></TR>
<TR><TD ALIGN="LEFT" ># addDocValuesUpdates(updates: DocValuesUpdate...): long</TD></TR>
<TR><TD ALIGN="LEFT" ># advanceQueue(maxNumPendingOps: int): DocumentsWriterDeleteQueue</TD></TR>
<TR><TD ALIGN="LEFT" ># anyChanges(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" ># freezeGlobalBuffer(callerSlice: DeleteSlice): FrozenBufferedUpdates</TD></TR>
<TR><TD ALIGN="LEFT" >- freezeGlobalBufferInternal(currentTail: Node&lt;?&gt;): FrozenBufferedUpdates</TD></TR>
<TR><TD ALIGN="LEFT" >- getPrevMaxSeqIdSupplier(nextSeqNo: AtomicLong): LongSupplier</TD></TR>
<TR><TD ALIGN="LEFT" ># maybeFreezeGlobalBuffer(): FrozenBufferedUpdates</TD></TR>
<TR><TD ALIGN="LEFT" ># newNode(term: Term): Node&lt;Term&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newNode(updates: DocValuesUpdate...): Node&lt;DocValuesUpdate[]&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># newSlice(): DeleteSlice</TD></TR>
<TR><TD ALIGN="LEFT" >+ numGlobalTermDeletes(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># skipSequenceNumbers(jump: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># tryApplyGlobalSlice()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateSlice(slice: DeleteSlice): long</TD></TR>
<TR><TD ALIGN="LEFT" ># updateSliceNoSeqNo(slice: DeleteSlice): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocumentsWriterFlushControl250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocumentsWriterFlushControl</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   activeBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockedFlushes: Queue&lt;DocumentsWriterPerThread&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: LiveIndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   documentsWriter: DocumentsWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushByRAMWasDisabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushDeletes: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushPolicy: FlushPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushQueue: Queue&lt;DocumentsWriterPerThread&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushingWriters: List&lt;DocumentsWriterPerThread&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fullFlush: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fullFlushMarkDone: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hardMaxBytesPerDWPT: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConfiguredRamBuffer: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocsSinceStalled: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numPending: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   peakActiveBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   peakDelta: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   peakFlushBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   peakNetBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   perThreadPool: DocumentsWriterPerThreadPool [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   stallControl: DocumentsWriterStallControl [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stallStartNS: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># abortFullFlushes()</TD></TR>
<TR><TD ALIGN="LEFT" ># abortPendingFlushes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ activeBytes(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- addFlushingDWPT(perThread: DocumentsWriterPerThread)</TD></TR>
<TR><TD ALIGN="LEFT" >+ allActiveWriters(): Iterator&lt;DocumentsWriterPerThread&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># anyStalledThreads(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- assertActiveDeleteQueue(queue: DocumentsWriterDeleteQueue): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># assertBlockedFlushes(flushingQueue: DocumentsWriterDeleteQueue): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- assertMemory(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- assertNumDocsSinceStalled(stalled: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- checkOutForFlush(perThread: DocumentsWriterPerThread): DocumentsWriterPerThread</TD></TR>
<TR><TD ALIGN="LEFT" >- checkout(perThread: DocumentsWriterPerThread, markPending: boolean): DocumentsWriterPerThread</TD></TR>
<TR><TD ALIGN="LEFT" >- checkoutAndBlock(perThread: DocumentsWriterPerThread)</TD></TR>
<TR><TD ALIGN="LEFT" ># checkoutLargestNonPendingWriter(): DocumentsWriterPerThread</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># doAfterDocument(perThread: DocumentsWriterPerThread): DocumentsWriterPerThread</TD></TR>
<TR><TD ALIGN="LEFT" ># doAfterFlush(dwpt: DocumentsWriterPerThread)</TD></TR>
<TR><TD ALIGN="LEFT" ># doOnAbort(perThread: DocumentsWriterPerThread)</TD></TR>
<TR><TD ALIGN="LEFT" ># doOnDelete()</TD></TR>
<TR><TD ALIGN="LEFT" ># findLargestNonPendingWriter(): DocumentsWriterPerThread</TD></TR>
<TR><TD ALIGN="LEFT" ># finishFullFlush()</TD></TR>
<TR><TD ALIGN="LEFT" ># markForFullFlush(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># netBytes(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># nextPendingFlush(): DocumentsWriterPerThread</TD></TR>
<TR><TD ALIGN="LEFT" ># numBlockedFlushes(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># numFlushingDWPT(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># numQueuedFlushes(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># obtainAndLock(): DocumentsWriterPerThread</TD></TR>
<TR><TD ALIGN="LEFT" >- pruneBlockedQueue(flushingQueue: DocumentsWriterDeleteQueue)</TD></TR>
<TR><TD ALIGN="LEFT" >- ramBufferGranularity(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- stallLimitBytes(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- updatePeaks(delta: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- updateStallState(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ waitForFlush()</TD></TR>
<TR><TD ALIGN="LEFT" ># waitIfStalled()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DocumentsWriterPerThread250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DocumentsWriterPerThread</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   aborted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   abortingException: Throwable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deleteDocIDs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deleteQueue: DocumentsWriterDeleteQueue [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deleteSlice: DeleteSlice [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   directory: TrackingDirectoryWrapper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableTestPoints: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfos: Builder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   filesToDelete: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushPending: SetOnce&lt;Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasFlushed: SetOnce&lt;Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexWriterConfig: LiveIndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexingChain: IndexingChain [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCommittedBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lock: ReentrantLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nf: NumberFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDeletedDocIds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocsInRAM: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingNumDocs: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingUpdates: BufferedUpdates [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfo: SegmentInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># abort()</TD></TR>
<TR><TD ALIGN="LEFT" ># commitLastBytesUsed(delta: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteLastDocs(docCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- finishDocuments(deleteNode: Node&lt;?&gt;, docIdUpTo: int): long</TD></TR>
<TR><TD ALIGN="LEFT" ># flush(flushNotifications: FlushNotifications): FlushedSegment</TD></TR>
<TR><TD ALIGN="LEFT" ># lock()</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeAbort(location: String, flushNotifications: FlushNotifications)</TD></TR>
<TR><TD ALIGN="LEFT" >- onAbortingException(throwable: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" ># pendingFilesToDelete(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># prepareFlush(): FrozenBufferedUpdates</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- reserveOneDoc()</TD></TR>
<TR><TD ALIGN="LEFT" ># sealFlushedSegment(flushedSegment: FlushedSegment, sortMap: DocMap, flushNotifications: FlushNotifications)</TD></TR>
<TR><TD ALIGN="LEFT" >- sortLiveDocs(liveDocs: Bits, sortMap: DocMap): FixedBitSet</TD></TR>
<TR><TD ALIGN="LEFT" ># testPoint(message: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># tryLock(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># unlock()</TD></TR>
<TR><TD ALIGN="LEFT" ># updateDocuments(docs: Iterable&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;, deleteNode: Node&lt;?&gt;, flushNotifications: FlushNotifications, onNewDocOnRAM: Runnable): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DoubleSorter12078005[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DoubleSorter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   missingValue: Double [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   providerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reverseMul: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valuesProvider: NumericDocValuesProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getComparableProviders(readers: List&lt;? extends LeafReader&gt;): ComparableProvider[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocComparator(reader: LeafReader, maxDoc: int): DocComparator</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

DummyCompressingCodec223308788[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)DummyCompressingCodec</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EmptyDocValuesProducer250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EmptyDocValuesProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(field: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(field: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(field: FieldInfo): SortedSetDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EndiannessReverserUtil1523452426[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EndiannessReverserUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createOutput(directory: Directory, name: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempOutput(directory: Directory, prefix: String, suffix: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ openChecksumInput(directory: Directory, name: String, context: IOContext): ChecksumIndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ openInput(directory: Directory, name: String, context: IOContext): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrapDataInput(dataInput: DataInput): DataInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrapDataOutput(dataOutput: DataOutput): DataOutput</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

EventQueue104941043[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)EventQueue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   permits: Semaphore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queue: Queue&lt;Event&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: IndexWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- acquire()</TD></TR>
<TR><TD ALIGN="LEFT" ># add(event: Event): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># processEvents()</TD></TR>
<TR><TD ALIGN="LEFT" >- processEventsInternal()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ExitablePointTree149965818[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ExitablePointTree</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   calls: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exitableIntersectVisitor: ExitableIntersectVisitor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: PointTree [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointValues: PointValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queryTimeout: QueryTimeout [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkAndThrow()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkAndThrowWithSampling()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): PointTree</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToChild(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToParent(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToSibling(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocIDs(visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocValues(visitor: IntersectVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FST146897711[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FST&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bytes: BytesStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   emptyOutput: T [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstStore: FSTStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   inputType: INPUT_TYPE [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   outputs: Outputs&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startNode: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addNode(fstCompiler: FSTCompiler&lt;T&gt;, nodeIn: UnCompiledNode&lt;T&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ findTargetArc(labelToMatch: int, follow: Arc&lt;T&gt;, arc: Arc&lt;T&gt;, in: BytesReader): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># finish(newStartNode: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- flag(flags: int, bit: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFirstArc(arc: Arc&lt;T&gt;): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumPresenceBytes(labelRange: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># isExpandedTarget(follow: Arc&lt;T&gt;, in: BytesReader): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(path: Path, outputs: Outputs&lt;T&gt;): FST&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readArc(arc: Arc&lt;T&gt;, in: BytesReader): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readArcByDirectAddressing(arc: Arc&lt;T&gt;, in: BytesReader, rangeIndex: int): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readArcByDirectAddressing(arc: Arc&lt;T&gt;, in: BytesReader, rangeIndex: int, presenceIndex: int): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readArcByIndex(arc: Arc&lt;T&gt;, in: BytesReader, idx: int): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># readEndArc(follow: Arc&lt;T&gt;, arc: Arc&lt;T&gt;): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readFirstRealTargetArc(nodeAddress: long, arc: Arc&lt;T&gt;, in: BytesReader): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readFirstTargetArc(follow: Arc&lt;T&gt;, arc: Arc&lt;T&gt;, in: BytesReader): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLabel(in: DataInput): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLastArcByDirectAddressing(arc: Arc&lt;T&gt;, in: BytesReader): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># readLastTargetArc(follow: Arc&lt;T&gt;, arc: Arc&lt;T&gt;, in: BytesReader): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNextArc(arc: Arc&lt;T&gt;, in: BytesReader): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># readNextArcLabel(arc: Arc&lt;T&gt;, in: BytesReader): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readNextRealArc(arc: Arc&lt;T&gt;, in: BytesReader): Arc&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readPresenceBytes(arc: Arc&lt;T&gt;, in: BytesReader)</TD></TR>
<TR><TD ALIGN="LEFT" >- readUnpackedNodeTarget(in: BytesReader): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ save(metaOut: DataOutput, out: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ save(path: Path)</TD></TR>
<TR><TD ALIGN="LEFT" >- seekToNextNode(in: BytesReader)</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldExpandNodeWithDirectAddressing(fstCompiler: FSTCompiler&lt;T&gt;, nodeIn: UnCompiledNode&lt;T&gt;, numBytesPerArc: int, maxBytesPerArcWithoutLabel: int, labelRange: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldExpandNodeWithFixedLengthArcs(fstCompiler: FSTCompiler&lt;T&gt;, node: UnCompiledNode&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ targetHasArcs(arc: Arc&lt;T&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- writeLabel(out: DataOutput, v: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeNodeForBinarySearch(fstCompiler: FSTCompiler&lt;T&gt;, nodeIn: UnCompiledNode&lt;T&gt;, startAddress: long, maxBytesPerArc: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeNodeForDirectAddressing(fstCompiler: FSTCompiler&lt;T&gt;, nodeIn: UnCompiledNode&lt;T&gt;, startAddress: long, maxBytesPerArcWithoutLabel: int, labelRange: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- writePresenceBits(fstCompiler: FSTCompiler&lt;T&gt;, nodeIn: UnCompiledNode&lt;T&gt;, dest: long, numPresenceBytes: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FSTCompletionLookup2105149299[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FSTCompletionLookup</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   buckets: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exactMatchFirst: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   higherWeightsCompletion: FSTCompletion [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normalCompletion: FSTCompletion [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempDir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempFileNamePrefix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(iterator: InputIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeWeight(value: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: CharSequence): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(input: DataInput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, higherWeightsFirst: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ store(output: DataOutput): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FSTPostingsFormat1307742404[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FSTPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FSTTermsReader1307742404[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FSTTermsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fields: TreeMap&lt;String, TermsReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsReader: PostingsReaderBase [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkFieldSummary(info: SegmentInfo, in: IndexInput, field: TermsReader, previous: TermsReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- seekDir(in: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
<TR><TD ALIGN="LEFT" ># walk(fst: FST&lt;T&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FailOnNonBulkMergesInfoStream1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FailOnNonBulkMergesInfoStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ isEnabled(component: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ message(component: String, message: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FastCompressingCodec673666990[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FastCompressingCodec</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FastDecompressionCompressingCodec673666990[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FastDecompressionCompressingCodec</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Field14040943[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Field</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fieldsData: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   tokenStream: TokenStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   type: IndexableFieldType [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ binaryValue(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldType(): IndexableFieldType</TD></TR>
<TR><TD ALIGN="LEFT" >+ invertableType(): InvertableType</TD></TR>
<TR><TD ALIGN="LEFT" >+ name(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ numericValue(): Number</TD></TR>
<TR><TD ALIGN="LEFT" >+ readerValue(): Reader</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedValue(): StoredValue</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringValue(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ tokenStream(analyzer: Analyzer, reuse: TokenStream): TokenStream</TD></TR>
<TR><TD ALIGN="LEFT" >+ tokenStreamValue(): TokenStream</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldEntry1910073334[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldEntry</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   M: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   addressesLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   addressesOffset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseRankPower: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dimension: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docsWithFieldLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docsWithFieldOffset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   jumpTableEntryCount: short [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   meta: Meta [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nodesByLevel: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numLevels: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offsetsBlockShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offsetsLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offsetsMeta: Meta [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offsetsOffset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   similarityFunction: VectorSimilarityFunction [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   size: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorDataLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorDataOffset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorEncoding: VectorEncoding [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorIndexLength: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorIndexOffset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldExistsQuery536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldExistsQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   field: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- buildErrorMsg(fieldInfo: FieldInfo): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesDocIdSetIterator(field: String, reader: LeafReader): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >- hasStrictlyConsistentFieldInfos(context: LeafReaderContext): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ rewrite(reader: IndexReader): Query</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldIndexData843236785[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldIndexData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fst: FST&lt;Long&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldInfo250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   attributes: Map&lt;String, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesType: DocValuesType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dvGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexOptions: IndexOptions [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   number: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   omitNorms: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointDimensionCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointIndexDimensionCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointNumBytes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   softDeletesField: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storePayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storeTermVector: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorDimension: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorEncoding: VectorEncoding [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorSimilarityFunction: VectorSimilarityFunction [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ attributes(): Map&lt;String, String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkConsistency()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAttribute(key: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ omitsNorms(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ putAttribute(key: String, value: String): String</TD></TR>
<TR><TD ALIGN="LEFT" ># verifySameDocValuesType(fieldName: String, docValuesType1: DocValuesType, docValuesType2: DocValuesType, strictlyConsistent: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifySameIndexOptions(fieldName: String, indexOptions1: IndexOptions, indexOptions2: IndexOptions, strictlyConsistent: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifySameOmitNorms(fieldName: String, omitNorms1: boolean, omitNorms2: boolean, strictlyConsistent: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifySamePointsOptions(fieldName: String, pointDimensionCount1: int, indexDimensionCount1: int, numBytes1: int, pointDimensionCount2: int, indexDimensionCount2: int, numBytes2: int, strictlyConsistent: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifySameSchema(o: FieldInfo, strictlyConsistent: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifySameStoreTermVectors(fieldName: String, storeTermVector1: boolean, storeTermVector2: boolean, strictlyConsistent: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifySameVectorOptions(fieldName: String, vd1: int, ve1: VectorEncoding, vsf1: VectorSimilarityFunction, vd2: int, ve2: VectorEncoding, vsf2: VectorSimilarityFunction)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldInfos250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldInfos</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   byName: HashMap&lt;String, FieldInfo&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   byNumber: FieldInfo[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasDocValues: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasFreq: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasNorms: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasOffsets: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPointValues: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPostings: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasProx: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasVectorValues: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasVectors: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   softDeletesField: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: Collection&lt;FieldInfo&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldInfo(fieldName: String): FieldInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfo(fieldNumber: int): FieldInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ getIndexedFields(reader: IndexReader): Collection&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getMergedFieldInfos(reader: IndexReader): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;FieldInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldInfosFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldInfosFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, iocontext: IOContext): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, infos: FieldInfos, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldNumbers457064227[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldNumbers</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dimensions: Map&lt;String, FieldDimensions&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesType: Map&lt;String, DocValuesType&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexOptions: Map&lt;String, IndexOptions&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lowestUnassignedFieldNumber: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nameToNumber: Map&lt;String, Integer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numberToName: Map&lt;Integer, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   omitNorms: Map&lt;String, Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   softDeletesFieldName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storeTermVectors: Map&lt;String, Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   strictlyConsistent: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorProps: Map&lt;String, FieldVectorProperties&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addOrGet(fi: FieldInfo): int</TD></TR>
<TR><TD ALIGN="LEFT" ># clear()</TD></TR>
<TR><TD ALIGN="LEFT" ># constructFieldInfo(fieldName: String, dvType: DocValuesType, newFieldNumber: int): FieldInfo</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyFieldInfo(fi: FieldInfo)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyOrCreateDvOnlyField(fieldName: String, dvType: DocValuesType, fieldMustExist: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- verifySameSchema(fi: FieldInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >- verifySoftDeletedFieldName(fieldName: String, isSoftDeletesField: boolean)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldReader1943830902[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   docCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldInfo: FieldInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numTerms: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sumDocFreq: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sumTotalTermFreq: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termsStartPointer: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldTermIterator250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldTermIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># delGen(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># field(): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldType14040943[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldType</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   attributes: Map&lt;String, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dimensionCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dimensionNumBytes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesType: DocValuesType [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   frozen: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexDimensionCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexOptions: IndexOptions [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   omitNorms: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storeTermVectorOffsets: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storeTermVectorPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storeTermVectorPositions: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storeTermVectors: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stored: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tokenized: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorDimension: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorEncoding: VectorEncoding [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorSimilarityFunction: VectorSimilarityFunction [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># checkIfFrozen()</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesType(): DocValuesType</TD></TR>
<TR><TD ALIGN="LEFT" >+ freeze()</TD></TR>
<TR><TD ALIGN="LEFT" >+ indexOptions(): IndexOptions</TD></TR>
<TR><TD ALIGN="LEFT" >+ omitNorms(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointDimensionCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointIndexDimensionCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointNumBytes(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ putAttribute(key: String, value: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ storeTermVectorOffsets(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ storeTermVectorPayloads(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ storeTermVectorPositions(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ storeTermVectors(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ stored(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tokenized(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorDimension(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorEncoding(): VectorEncoding</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorSimilarityFunction(): VectorSimilarityFunction</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldWriter1781967873[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldWriter&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dim: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docsWithField: DocsWithFieldSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfo: FieldInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectors: List&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addValue(docID: int, value: T)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyValue(vectorValue: T): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Fields250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Fields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsConsumer985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState, norms: NormsProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fields: Fields, norms: NormsProducer)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsGroup1666370907[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsGroup</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fields: List&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   state: SegmentWriteState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   suffix: int [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsProducer985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsReader1327861297[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, KnnVectorsReader&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFieldReader(field: String): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsReader1666370907[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, FieldsProducer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   formats: Map&lt;String, FieldsProducer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segment: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsReader439672098[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, DocValuesProducer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   formats: Map&lt;String, DocValuesProducer&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(field: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(field: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(field: FieldInfo): SortedSetDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsWriter1327861297[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   formats: Map&lt;KnnVectorsFormat, WriterAndSuffix&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentWriteState: SegmentWriteState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   suffixes: Map&lt;String, Integer&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addField(fieldInfo: FieldInfo): KnnFieldVectorsWriter&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush(maxDoc: int, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- getInstance(field: FieldInfo): KnnVectorsWriter</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeOneField(fieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsWriter1666370907[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   toClose: List&lt;Closeable&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writeState: SegmentWriteState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- buildFieldsGroupMapping(indexedFieldNames: Iterable&lt;String&gt;): Map&lt;PostingsFormat, FieldsGroup&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState, norms: NormsProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fields: Fields, norms: NormsProducer)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FieldsWriter439672098[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   formats: Map&lt;DocValuesFormat, ConsumerAndSuffix&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentWriteState: SegmentWriteState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   suffixes: Map&lt;String, Integer&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedSetField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getInstance(field: FieldInfo): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >- getInstance(field: FieldInfo, ignoreCurrentFormat: boolean): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FileIterator45371468[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FileIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   curPayload: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   curWeight: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isFirstLine: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   spare: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ contexts(): Set&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ payload(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >- readWeight(weight: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ weight(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterBinaryDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterBinaryDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: BinaryDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ binaryValue(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterCodec985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: Codec [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterCodecReader250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterCodecReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: CodecReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" ># doClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTermVectors(docID: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDocs(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrap(reader: CodecReader): CodecReader</TD></TR>
<TR><TD ALIGN="LEFT" ># wrapLiveDocs(reader: CodecReader, liveDocs: Bits, numDocs: int): FilterCodecReader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterFields1773060597[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: Fields [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterFieldsProducer855124300[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterFieldsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   filtered: List&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: FieldsProducer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: MergePolicy [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findForcedDeletesMerges(segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedMerges(segmentInfos: SegmentInfos, maxSegmentCount: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findFullFlushMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(readers: CodecReader...): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ keepFullyDeletedSegment(readerIOSupplier: IOSupplier&lt;CodecReader&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># maxFullFlushMergeSize(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDeletesToMerge(info: SegmentCommitInfo, delCount: int, readerSupplier: IOSupplier&lt;CodecReader&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" ># size(info: SegmentCommitInfo, context: MergeContext): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrap(): MergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ useCompoundFile(infos: SegmentInfos, mergedInfo: SegmentCommitInfo, mergeContext: MergeContext): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterNumericDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: NumericDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterPath1344450007[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterPath</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delegate: Path [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fileSystem: FilterFileSystem [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(other: Path): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ endsWith(other: Path): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ endsWith(other: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getName(index: int): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;Path&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ normalize(): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ register(watcher: WatchService, events: Kind&lt;?&gt;[], modifiers: Modifier...): WatchKey</TD></TR>
<TR><TD ALIGN="LEFT" >+ register(watcher: WatchService, events: Kind&lt;?&gt;...): WatchKey</TD></TR>
<TR><TD ALIGN="LEFT" >+ relativize(other: Path): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ resolve(other: Path): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ resolve(other: String): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ resolveSibling(other: Path): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ resolveSibling(other: String): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ startsWith(other: Path): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ startsWith(other: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ subpath(beginIndex: int, endIndex: int): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ toAbsolutePath(): Path</TD></TR>
<TR><TD ALIGN="LEFT" ># toDelegate(path: Path): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ toFile(): File</TD></TR>
<TR><TD ALIGN="LEFT" >+ toRealPath(options: LinkOption...): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ toUri(): URI</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrap(): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrap(path: Path): Path</TD></TR>
<TR><TD ALIGN="LEFT" ># wrap(other: Path): Path</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterPostingsEnum1773060597[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterPostingsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: PostingsEnum [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ endOffset(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ freq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextPosition(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ startOffset(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrap(): PostingsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterScorer536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterScorer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: Scorer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ score(): float</TD></TR>
<TR><TD ALIGN="LEFT" >+ twoPhaseIterator(): TwoPhaseIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrap(): Scorer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterSortedDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterSortedDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ intersect(automaton: CompiledAutomaton): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ termsEnum(): TermsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterSortedNumericDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterSortedNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedNumericDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextValue(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterSortedSetDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterSortedSetDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedSetDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ intersect(automaton: CompiledAutomaton): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextOrd(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ termsEnum(): TermsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterTerms1773060597[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterTerms</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: Terms [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilterTermsEnum1773060597[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilterTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: TermsEnum [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ attributes(): AttributeSource</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FilteredTermsEnum250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FilteredTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   actualTerm: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   doSeek: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initialSeekTerm: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   tenum: TermsEnum [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># accept(term: BytesRef): AcceptStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ attributes(): AttributeSource</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" ># nextSeekTerm(currentTerm: BytesRef): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(term: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FixedBitSet2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FixedBitSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bits: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numWords: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ and(other: FixedBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >- and(otherArr: long[], otherNumWords: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ andNot(iter: DocIdSetIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >+ andNot(other: FixedBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >- andNot(otherOffsetWords: int, other: FixedBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >- andNot(otherOffsetWords: int, otherArr: long[], otherNumWords: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ andNotCount(a: FixedBitSet, b: FixedBitSet): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ approximateCardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ asReadOnlyBits(): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ bits2words(numBits: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ cardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(index: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(startIndex: int, endIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): FixedBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyOf(bits: Bits): FixedBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ ensureCapacity(bits: FixedBitSet, numBits: int): FixedBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ flip(startIndex: int, endIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flip(index: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAndClear(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAndSet(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ intersectionCount(a: FixedBitSet, b: FixedBitSet): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ intersects(other: FixedBitSet): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextSetBit(index: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ or(iter: DocIdSetIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >+ or(other: FixedBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >- or(otherOffsetWords: int, other: FixedBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >- or(otherOffsetWords: int, otherArr: long[], otherNumWords: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ prevSetBit(index: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ scanIsEmpty(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ unionCount(a: FixedBitSet, b: FixedBitSet): long</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyGhostBitsClear(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ xor(other: FixedBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >+ xor(iter: DocIdSetIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >- xor(otherBits: long[], otherNumWords: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FixedBits2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FixedBits</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bits: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   length: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FixedGapTermsIndexReader625905195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FixedGapTermsIndexReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blocksize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fields: HashMap&lt;String, FieldIndexData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexInterval: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packedIntsVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termBytesReader: Reader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFieldEnum(fieldInfo: FieldInfo): FieldIndexEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- seekDir(input: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportsOrd(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FloatSorter12078005[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FloatSorter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   missingValue: Float [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   providerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reverseMul: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valuesProvider: NumericDocValuesProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getComparableProviders(readers: List&lt;? extends LeafReader&gt;): ComparableProvider[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocComparator(reader: LeafReader, maxDoc: int): DocComparator</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FlushByRamOrCountsPolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FlushByRamOrCountsPolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- flushActiveBytes(control: DocumentsWriterFlushControl, perThread: DocumentsWriterPerThread)</TD></TR>
<TR><TD ALIGN="LEFT" >- flushDeletes(control: DocumentsWriterFlushControl)</TD></TR>
<TR><TD ALIGN="LEFT" ># flushOnDocCount(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># flushOnRAM(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># markLargestWriterPending(control: DocumentsWriterFlushControl, perThread: DocumentsWriterPerThread)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onChange(control: DocumentsWriterFlushControl, perThread: DocumentsWriterPerThread)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FlushPolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FlushPolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   indexWriterConfig: LiveIndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   infoStream: InfoStream [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- assertMessage(s: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># findLargestNonPendingWriter(control: DocumentsWriterFlushControl, perThread: DocumentsWriterPerThread): DocumentsWriterPerThread</TD></TR>
<TR><TD ALIGN="LEFT" ># init(indexWriterConfig: LiveIndexWriterConfig)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onChange(control: DocumentsWriterFlushControl, perThread: DocumentsWriterPerThread)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FlushTicket2070583898[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FlushTicket</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   failed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   frozenUpdates: FrozenBufferedUpdates [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasSegment: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   published: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segment: FlushedSegment [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># canPublish(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># markPublished()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FlushedSegment361602770[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FlushedSegment</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   liveDocs: FixedBitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segmentInfo: SegmentCommitInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segmentUpdates: FrozenBufferedUpdates [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortMap: DocMap [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ForceMergePolicy450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ForceMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FreeTextSuggester598362673[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FreeTextSuggester</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fst: FST&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   grams: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexAnalyzer: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queryAnalyzer: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   separator: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totTokens: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addShingles(other: Analyzer): Analyzer</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(iterator: InputIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(iterator: InputIterator, ramBufferSizeMB: double)</TD></TR>
<TR><TD ALIGN="LEFT" >- countGrams(token: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeWeight(output: Long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeWeight(ngramCount: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: CharSequence): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(input: DataInput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, onlyMorePopular: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, onlyMorePopular: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- lookupPrefix(fst: FST&lt;Long&gt;, bytesReader: BytesReader, scratch: BytesRef, arc: Arc&lt;Long&gt;): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ store(output: DataOutput): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FreqProxFields250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FreqProxFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fields: Map&lt;String, FreqProxTermsWriterPerField&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FreqProxTermsEnum135592398[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FreqProxTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   numTerms: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ord: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsArray: FreqProxPostingsArray [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedTermIDs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   terms: FreqProxTermsWriterPerField [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FrequencyTrackingRingBuffer2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FrequencyTrackingRingBuffer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   buffer: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   frequencies: IntBag [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   position: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(i: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># asFrequencyMap(): Map&lt;Integer, Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ frequency(key: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FrozenBufferedUpdates250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FrozenBufferedUpdates</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   applied: CountDownLatch [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   applyLock: ReentrantLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bytesUsed: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deleteQueries: Query[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deleteQueryLimits: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deleteTerms: PrefixCodedTerms [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldUpdates: Map&lt;String, FieldUpdatesBuffer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldUpdatesCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numTermDeletes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   privateSegment: SegmentCommitInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   totalDelCount: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># any(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># apply(segStates: SegmentState[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >- applyDocValuesUpdates(segStates: SegmentState[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >- applyDocValuesUpdates(segState: SegmentState, updates: Map&lt;String, FieldUpdatesBuffer&gt;, delGen: long, segmentPrivateDeletes: boolean): long</TD></TR>
<TR><TD ALIGN="LEFT" >- applyQueryDeletes(segStates: SegmentState[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >- applyTermDeletes(segStates: SegmentState[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ delGen(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># lock()</TD></TR>
<TR><TD ALIGN="LEFT" ># tryLock(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># unlock()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FuzzySet329228184[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FuzzySet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bloomSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   filter: FixedBitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashFunction: HashFunction [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addValue(value: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ contains(value: BytesRef): ContainsResult</TD></TR>
<TR><TD ALIGN="LEFT" >+ createOptimalSet(maxNumUniqueValues: int, targetMaxFpp: float): FuzzySet</TD></TR>
<TR><TD ALIGN="LEFT" >+ createSetBasedOnMaxMemory(maxNumBytes: int): FuzzySet</TD></TR>
<TR><TD ALIGN="LEFT" >+ createSetBasedOnQuality(maxNumUniqueValues: int, desiredMaxSaturation: float, version: int): FuzzySet</TD></TR>
<TR><TD ALIGN="LEFT" >+ deserialize(in: DataInput): FuzzySet</TD></TR>
<TR><TD ALIGN="LEFT" >+ downsize(targetMaxSaturation: float): FuzzySet</TD></TR>
<TR><TD ALIGN="LEFT" >+ getEstimatedNumberUniqueValuesAllowingForCollisions(setSize: int, numRecordedBits: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNearestSetSize(maxNumberOfBits: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNearestSetSize(maxNumberOfValuesExpected: int, desiredSaturation: float): int</TD></TR>
<TR><TD ALIGN="LEFT" >- mayContainValue(aHash: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ serialize(out: DataOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

FuzzyTermsEnum536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)FuzzyTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   actualEnum: TermsEnum [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   atts: AttributeSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   automata: CompiledAutomaton[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   boostAtt: BoostAttribute [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bottom: float [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bottomTerm: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxBoostAtt: MaxNonCompetitiveBoostAttribute [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxEdits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queuedBottom: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   term: Term [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   terms: Terms [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ attributes(): AttributeSource</TD></TR>
<TR><TD ALIGN="LEFT" >- bottomChanged(lastTerm: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getAutomatonEnum(editDistance: int, lastTerm: BytesRef): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- matches(termIn: BytesRef, k: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GlobalOrdinalsQuery1521700474[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GlobalOrdinalsQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   foundOrds: LongBitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fromQuery: Query [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   globalOrds: OrdinalMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexReaderContextId: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   joinField: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   toQuery: Query [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsTo(other: GlobalOrdinalsQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GlobalOrdinalsWithScoreQuery1521700474[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GlobalOrdinalsWithScoreQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   collector: GlobalOrdinalsWithScoreCollector [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fromQuery: Query [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   globalOrds: OrdinalMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexReaderContextId: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   joinField: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   max: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   min: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scoreMode: ScoreMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   toQuery: Query [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsTo(other: GlobalOrdinalsWithScoreQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

GrowableWriter611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)GrowableWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   acceptableOverheadRatio: float [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   current: Mutable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentMask: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureCapacity(value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ fill(fromIndex: int, toIndex: int, val: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int, arr: long[], off: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- mask(bitsPerValue: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ resize(newSize: int): GrowableWriter</TD></TR>
<TR><TD ALIGN="LEFT" >+ set(index: int, arr: long[], off: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

HighCompressionCompressingCodec673666990[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)HighCompressionCompressingCodec</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

HighFreqTerm181433766[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)HighFreqTerm</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   docIDs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   freqs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   payloads: byte[][][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   positions: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   totalTermFreq: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

HighFrequencyIterator1689880614[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)HighFrequencyIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   freq: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minNumDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   spare: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termsEnum: TermsEnum [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ contexts(): Set&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isFrequent(freq: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ payload(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ weight(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IDVersionPostingsFormat1085677175[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IDVersionPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   maxTermsInBlock: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minTermsInBlock: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bytesToLong(bytes: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ longToBytes(v: long, bytes: BytesRef)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IDVersionSegmentTermsEnum1085677175[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IDVersionSegmentTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   arcs: Arc&lt;Pair&lt;BytesRef, Long&gt;&gt;[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentFrame: IDVersionSegmentTermsEnumFrame [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eof: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fr: VersionFieldReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstReader: BytesReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchReader: ByteArrayDataInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stack: IDVersionSegmentTermsEnumFrame[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   staticFrame: IDVersionSegmentTermsEnumFrame [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   targetBeforeCurrentLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   term: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termExists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   validIndexPrefix: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># brToString(b: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >- clearEOF(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getArc(ord: int): Arc&lt;Pair&lt;BytesRef, Long&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getFrame(ord: int): IDVersionSegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" ># initIndexInput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- printSeekState(out: PrintStream)</TD></TR>
<TR><TD ALIGN="LEFT" ># pushFrame(arc: Arc&lt;Pair&lt;BytesRef, Long&gt;&gt;, frameData: Pair&lt;BytesRef, Long&gt;, length: int): IDVersionSegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" ># pushFrame(arc: Arc&lt;Pair&lt;BytesRef, Long&gt;&gt;, fp: long, length: int): IDVersionSegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(target: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(target: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(target: BytesRef, minIDVersion: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(target: BytesRef, otherState: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- setEOF(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IOUtils2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IOUtils</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ applyToAll(collection: Collection&lt;T&gt;, consumer: IOConsumer&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(objects: Closeable...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close(objects: Iterable&lt;? extends Closeable&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeWhileHandlingException(objects: Closeable...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeWhileHandlingException(objects: Iterable&lt;? extends Closeable&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFiles(dir: Directory, names: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFilesIfExist(files: Path...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFilesIfExist(files: Collection&lt;? extends Path&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFilesIgnoringExceptions(dir: Directory, files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFilesIgnoringExceptions(dir: Directory, files: String...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFilesIgnoringExceptions(files: Path...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFilesIgnoringExceptions(files: Collection&lt;? extends Path&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ fsync(fileToSync: Path, isDir: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDecodingReader(stream: InputStream, charSet: Charset): Reader</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDecodingReader(clazz: Class&lt;?&gt;, resource: String, charSet: Charset): Reader</TD></TR>
<TR><TD ALIGN="LEFT" >+ requireResourceNonNull(resource: T, name: String): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ rethrowAlways(th: Throwable): Error</TD></TR>
<TR><TD ALIGN="LEFT" >+ rm(locations: Path...)</TD></TR>
<TR><TD ALIGN="LEFT" >- rm(unremoved: LinkedHashMap&lt;Path, Throwable&gt;, locations: Path...): LinkedHashMap&lt;Path, Throwable&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ useOrSuppress(first: T, second: T): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexFileDeleter250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexFileDeleter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   commits: List&lt;CommitPoint&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   commitsToDelete: List&lt;CommitPoint&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directoryOrig: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fileDeleter: FileDeleter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastFiles: List&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSegmentInfos: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   policy: IndexDeletionPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   startingCommitDeleted: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: IndexWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># assertCommitsAreNotDeleted(commits: List&lt;CommitPoint&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkpoint(segmentInfos: SegmentInfos, isCommit: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># decRef(files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># decRef(segmentInfos: SegmentInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteCommits()</TD></TR>
<TR><TD ALIGN="LEFT" ># deleteNewFiles(files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" >+ exists(fileName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># incRef(segmentInfos: SegmentInfos, isCommit: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># incRef(files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># inflateGens(infos: SegmentInfos, files: Collection&lt;String&gt;, infoStream: InfoStream)</TD></TR>
<TR><TD ALIGN="LEFT" >- locked(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- logInfo(msgType: MsgType, msg: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># refresh()</TD></TR>
<TR><TD ALIGN="LEFT" ># revisitPolicy()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexFileNames250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexFileNames</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fileNameFromGeneration(base: String, ext: String, gen: long): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getExtension(filename: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >- indexOfSegmentName(filename: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ matchesExtension(filename: String, ext: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseGeneration(filename: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseSegmentName(filename: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentFileName(segmentName: String, segmentSuffix: String, ext: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ stripExtension(filename: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ stripSegmentName(filename: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexInput260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexInput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   resourceDescription: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># getFullSliceDescription(sliceDescription: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomAccessSlice(offset: long, length: long): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(pos: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ skipBytes(numBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ slice(sliceDescription: String, offset: long, length: long): IndexInput</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexOutput260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexOutput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   resourceDescription: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ alignFilePointer(alignmentBytes: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ alignOffset(offset: long, alignmentBytes: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexReader250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closedByChild: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   parentReaders: Set&lt;IndexReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   refCount: AtomicInteger [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ decRef()</TD></TR>
<TR><TD ALIGN="LEFT" ># doClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(term: Term): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int): Document</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, fieldsToLoad: Set&lt;String&gt;): Document</TD></TR>
<TR><TD ALIGN="LEFT" ># ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocCount(field: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSumDocFreq(field: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSumTotalTermFreq(field: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTermVector(docID: int, field: String): Terms</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTermVectors(docID: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" >+ incRef()</TD></TR>
<TR><TD ALIGN="LEFT" >+ leaves(): List&lt;LeafReaderContext&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyReaderClosedListeners()</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDeletedDocs(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDocs(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ registerParentReader(reader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >- reportCloseToParentReaders()</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFields(): StoredFields</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectors(): TermVectors</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(term: Term): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryIncRef(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexRearranger1397736262[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexRearranger</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   config: IndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   documentSelectors: List&lt;DocumentSelector&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   input: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   output: Directory [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addOneSegment(writer: IndexWriter, reader: IndexReader, selector: DocumentSelector)</TD></TR>
<TR><TD ALIGN="LEFT" >+ execute()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexSplitter1397736262[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexSplitter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dir: Path [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fsDir: FSDirectory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   infos: SegmentInfos [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- getInfo(name: String): SegmentCommitInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ listSegments()</TD></TR>
<TR><TD ALIGN="LEFT" >+ main(args: String[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(segs: String[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ split(destDir: Path, segs: String[])</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexUpgrader250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexUpgrader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   deletePriorCommits: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   iwc: IndexWriterConfig [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ main(args: String[])</TD></TR>
<TR><TD ALIGN="LEFT" ># parseArgs(args: String[]): IndexUpgrader</TD></TR>
<TR><TD ALIGN="LEFT" >- printUsage()</TD></TR>
<TR><TD ALIGN="LEFT" >+ upgrade()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexWriter250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   addIndexesMergeSource: AddIndexesMergeSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bufferedUpdatesStream: BufferedUpdatesStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   changeCount: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closing: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   commitLock: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   commitUserData: Iterable&lt;Entry&lt;String, String&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: LiveIndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   deleter: IndexFileDeleter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   didMessageState: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directoryOrig: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docWriter: DocumentsWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   enableTestPoints: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eventListener: IndexWriterEventListener [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eventQueue: EventQueue [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   filesToCommit: Collection&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushCount: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushDeletesCount: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushNotifications: FlushNotifications [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fullFlushLock: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   globalFieldNumberMap: FieldNumbers [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastCommitChangeCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maybeMerge: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeExceptions: List&lt;OneMerge&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeFinishedGen: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeMaxNumSegments: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeScheduler: MergeScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeSource: MergeSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merges: Merges [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergingSegments: HashSet&lt;SegmentCommitInfo&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingCommit: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingCommitChangeCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingMerges: Deque&lt;OneMerge&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingNumDocs: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingSeqNo: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readerPool: ReaderPool [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   rollbackSegments: List&lt;SegmentCommitInfo&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   runningAddIndexesMerges: Set&lt;SegmentMerger&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   runningMerges: Set&lt;OneMerge&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfos: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   softDeletesEnabled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startCommitTime: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tragedy: AtomicReference&lt;Throwable&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeDocValuesLock: ReentrantLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeLock: Lock [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _mergeInit(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >- abortMerges()</TD></TR>
<TR><TD ALIGN="LEFT" >- abortOneMerge(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >- acquireWriteLocks(dirs: Directory...): List&lt;Lock&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ addDocument(doc: Iterable&lt;? extends IndexableField&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ addDocuments(docs: Iterable&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexes(dirs: Directory...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexes(readers: CodecReader...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexesReaderMerge(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >- addMergeException(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >- adjustPendingNumDocs(numDocs: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceSegmentInfosVersion(newVersion: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- applyAllDeletesAndUpdates()</TD></TR>
<TR><TD ALIGN="LEFT" >- assertSoftDeletesCount(reader: CodecReader, expectedCount: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- buildDocValuesUpdate(term: Term, updates: Field[]): DocValuesUpdate[]</TD></TR>
<TR><TD ALIGN="LEFT" >- carryOverHardDeletes(mergedReadersAndUpdates: ReadersAndUpdates, maxDoc: int, mergeLiveDocs: Bits, prevHardLiveDocs: Bits, currentHardLiveDocs: Bits, segDocMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- changed()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkpoint()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkpointNoSIS()</TD></TR>
<TR><TD ALIGN="LEFT" ># cloneSegmentInfos(): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- closeMergeReaders(merge: OneMerge, suppressExceptions: boolean, droppedSegment: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- closeSegmentStates(segStates: SegmentState[], success: boolean): ApplyDeletesResult</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- commitInternal(mergePolicy: MergePolicy): long</TD></TR>
<TR><TD ALIGN="LEFT" >- commitMerge(merge: OneMerge, mergeState: MergeState): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- commitMergedDeletesAndUpdates(merge: OneMerge, mergeState: MergeState): ReadersAndUpdates</TD></TR>
<TR><TD ALIGN="LEFT" >- copySegmentAsIs(info: SegmentCommitInfo, segName: String, context: IOContext): SegmentCommitInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- countSoftDeletes(reader: CodecReader, wrappedLiveDocs: Bits, hardLiveDocs: Bits, softDeleteCounter: Counter, hardDeleteCounter: Counter)</TD></TR>
<TR><TD ALIGN="LEFT" ># createCompoundFile(infoStream: InfoStream, directory: TrackingDirectoryWrapper, info: SegmentInfo, context: IOContext, deleteFiles: IOConsumer&lt;Collection&lt;String&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ decRefDeleter(segmentInfos: SegmentInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteAll(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteDocuments(terms: Term...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteDocuments(queries: Query...): long</TD></TR>
<TR><TD ALIGN="LEFT" >- deleteNewFiles(files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteUnusedFiles()</TD></TR>
<TR><TD ALIGN="LEFT" ># doAfterFlush()</TD></TR>
<TR><TD ALIGN="LEFT" ># doBeforeFlush()</TD></TR>
<TR><TD ALIGN="LEFT" >- doFlush(applyAllDeletes: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- doWait()</TD></TR>
<TR><TD ALIGN="LEFT" >- dropDeletedSegment(info: SegmentCommitInfo)</TD></TR>
<TR><TD ALIGN="LEFT" ># ensureOpen(failIfClosing: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureValidMerge(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" ># executeMerge(trigger: MergeTrigger)</TD></TR>
<TR><TD ALIGN="LEFT" >- filesExist(toSync: SegmentInfos): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- finishApply(segStates: SegmentState[], success: boolean, delFiles: Set&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- finishCommit()</TD></TR>
<TR><TD ALIGN="LEFT" >- finishGetReaderMerge(stopCollectingMergedReaders: AtomicBoolean, mergedReaders: Map&lt;String, SegmentReader&gt;, openedReadOnlyClones: Map&lt;String, SegmentReader&gt;, openingSegmentInfos: SegmentInfos, applyAllDeletes: boolean, writeAllDeletes: boolean, pointInTimeMerges: MergeSpecification, maxCommitMergeWaitMillis: long): StandardDirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush()</TD></TR>
<TR><TD ALIGN="LEFT" ># flush(triggerMerge: boolean, applyAllDeletes: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- flushFailed(info: SegmentInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flushNextBuffer(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># forceApply(updates: FrozenBufferedUpdates)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forceMerge(maxNumSegments: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forceMerge(maxNumSegments: int, doWait: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forceMergeDeletes(doWait: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forceMergeDeletes()</TD></TR>
<TR><TD ALIGN="LEFT" >- getInfosToApply(updates: FrozenBufferedUpdates): List&lt;SegmentCommitInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getPooledInstance(info: SegmentCommitInfo, create: boolean): ReadersAndUpdates</TD></TR>
<TR><TD ALIGN="LEFT" ># getReader(applyAllDeletes: boolean, writeAllDeletes: boolean): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" >- handleMergeException(t: Throwable, merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >+ incRefDeleter(segmentInfos: SegmentInfos)</TD></TR>
<TR><TD ALIGN="LEFT" ># isCongruentSort(indexSort: Sort, otherSort: Sort): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isFullyDeleted(readersAndUpdates: ReadersAndUpdates): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># maxDoc(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- maxNumSegmentsMergesPending(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeCloseOnTragicEvent()</TD></TR>
<TR><TD ALIGN="LEFT" >+ maybeMerge()</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeMerge(mergePolicy: MergePolicy, trigger: MergeTrigger, maxNumSegments: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeProcessEvents(seqNo: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeReopenMergedNRTReader(mergedReaders: Map&lt;String, SegmentReader&gt;, openedReadOnlyClones: Map&lt;String, SegmentReader&gt;, openingSegmentInfos: SegmentInfos, applyAllDeletes: boolean, writeAllDeletes: boolean): StandardDirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># merge(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeFinish(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" ># mergeInit(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeMiddle(merge: OneMerge, mergePolicy: MergePolicy): int</TD></TR>
<TR><TD ALIGN="LEFT" ># mergeSuccess(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >- messageState()</TD></TR>
<TR><TD ALIGN="LEFT" >- newSegmentName(): String</TD></TR>
<TR><TD ALIGN="LEFT" ># newestSegment(): SegmentCommitInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- noDupDirs(dirs: Directory...)</TD></TR>
<TR><TD ALIGN="LEFT" ># nrtIsCurrent(infos: SegmentInfos): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDeletedDocs(info: SegmentCommitInfo): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDeletesToMerge(info: SegmentCommitInfo): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ numRamDocs(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ onTragicEvent(tragedy: Throwable, location: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- openSegmentStates(infos: List&lt;SegmentCommitInfo&gt;, alreadySeenSegments: Set&lt;SegmentCommitInfo&gt;, delGen: long): SegmentState[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ prepareCommit(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- prepareCommitInternal(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- preparePointInTimeMerge(mergingSegmentInfos: SegmentInfos, stopCollectingMergeResults: BooleanSupplier, trigger: MergeTrigger, mergeFinished: IOConsumer&lt;SegmentCommitInfo&gt;): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >- processEvents(triggerMerge: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- publishFlushedSegment(newSegment: SegmentCommitInfo, fieldInfos: FieldInfos, packet: FrozenBufferedUpdates, globalPacket: FrozenBufferedUpdates, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- publishFlushedSegments(forced: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- publishFrozenUpdates(packet: FrozenBufferedUpdates): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readFieldInfos(si: SegmentCommitInfo): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >- registerMerge(merge: OneMerge): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># release(readersAndUpdates: ReadersAndUpdates)</TD></TR>
<TR><TD ALIGN="LEFT" >- release(readersAndUpdates: ReadersAndUpdates, assertLiveInfo: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- reserveDocs(addedNumDocs: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- resetMergeExceptions()</TD></TR>
<TR><TD ALIGN="LEFT" >+ rollback()</TD></TR>
<TR><TD ALIGN="LEFT" >- rollbackInternal()</TD></TR>
<TR><TD ALIGN="LEFT" >- rollbackInternalNoCommit()</TD></TR>
<TR><TD ALIGN="LEFT" ># segString(): String</TD></TR>
<TR><TD ALIGN="LEFT" ># segString(infos: Iterable&lt;SegmentCommitInfo&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" >- segString(info: SegmentCommitInfo): String</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldClose(waitForClose: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- shutdown()</TD></TR>
<TR><TD ALIGN="LEFT" >+ softUpdateDocument(term: Term, doc: Iterable&lt;? extends IndexableField&gt;, softDeletes: Field...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ softUpdateDocuments(term: Term, docs: Iterable&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;, softDeletes: Field...): long</TD></TR>
<TR><TD ALIGN="LEFT" >- startCommit(toSync: SegmentInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- testPoint(message: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- testReserveDocs(addedNumDocs: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># toLiveInfos(sis: SegmentInfos): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" >- tooManyDocs(addedNumDocs: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- tragicEvent(tragedy: Throwable, location: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># tryApply(updates: FrozenBufferedUpdates): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryDeleteDocument(readerIn: IndexReader, docID: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >- tryModifyDocument(readerIn: IndexReader, docID: int, toApply: DocModifier): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ tryUpdateDocValue(readerIn: IndexReader, docID: int, fields: Field...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateBinaryDocValue(term: Term, field: String, value: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDocValues(term: Term, updates: Field...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDocument(term: Term, doc: Iterable&lt;? extends IndexableField&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDocuments(delTerm: Term, docs: Iterable&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >- updateDocuments(delNode: Node&lt;?&gt;, docs: Iterable&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateNumericDocValue(term: Term, field: String, value: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- updatePendingMerges(mergePolicy: MergePolicy, trigger: MergeTrigger, maxNumSegments: int): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >- validate(info: SegmentCommitInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >- validateIndexSort()</TD></TR>
<TR><TD ALIGN="LEFT" >- validateMergeReader(leaf: CodecReader)</TD></TR>
<TR><TD ALIGN="LEFT" ># waitForMerges()</TD></TR>
<TR><TD ALIGN="LEFT" >- writeReaderPool(writeDeletes: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeSomeDocValuesUpdates()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexWriterConfig250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexWriterConfig</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   writer: SetOnce&lt;IndexWriter&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ setCheckPendingFlushUpdate(checkPendingFlushOnUpdate: boolean): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCodec(codec: Codec): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setCommitOnClose(commitOnClose: boolean): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" ># setFlushPolicy(flushPolicy: FlushPolicy): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndexCommit(commit: IndexCommit): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndexCreatedVersionMajor(indexCreatedVersionMajor: int): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndexDeletionPolicy(delPolicy: IndexDeletionPolicy): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndexSort(sort: Sort): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" ># setIndexWriter(writer: IndexWriter): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setIndexWriterEventListener(eventListener: IndexWriterEventListener): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInfoStream(infoStream: InfoStream): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setInfoStream(printStream: PrintStream): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setLeafSorter(leafSorter: Comparator&lt;LeafReader&gt;): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxBufferedDocs(maxBufferedDocs: int): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxFullFlushMergeWaitMillis(maxFullFlushMergeWaitMillis: long): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMergePolicy(mergePolicy: MergePolicy): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMergeScheduler(mergeScheduler: MergeScheduler): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMergedSegmentWarmer(mergeSegmentWarmer: IndexReaderWarmer): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setOpenMode(openMode: OpenMode): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRAMBufferSizeMB(ramBufferSizeMB: double): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRAMPerThreadHardLimitMB(perThreadHardLimitMB: int): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setReaderPooling(readerPooling: boolean): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSimilarity(similarity: Similarity): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSoftDeletesField(softDeletesField: String): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUseCompoundFile(useCompoundFile: boolean): IndexWriterConfig</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexWriterMergeSource104941043[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexWriterMergeSource</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   writer: IndexWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ merge(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" >+ onMergeFinished(merge: OneMerge)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexedDISI961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexedDISI</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   block: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockEnd: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cost: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseBitmapOffset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseOrigoIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseRankPower: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseRankTable: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   doc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   exists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   gap: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   index: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   jumpTable: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   jumpTableEntryCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   method: Method [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nextBlockIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numberOfOnes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   slice: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   word: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   wordIndex: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addJumps(jumps: int[], offset: long, index: int, startBlock: int, endBlock: int): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- advanceBlock(targetBlock: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ createBlockSlice(slice: IndexInput, sliceDescription: String, offset: long, length: long, jumpTableEntryCount: int): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ createJumpTable(slice: IndexInput, offset: long, length: long, jumpTableEntryCount: int): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >- createRank(buffer: FixedBitSet, denseRankPower: byte): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- flush(block: int, buffer: FixedBitSet, cardinality: int, denseRankPower: byte, out: IndexOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- flushBlockJumps(jumps: int[], blockCount: int, out: IndexOutput): short</TD></TR>
<TR><TD ALIGN="LEFT" >+ index(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- rankSkip(disi: IndexedDISI, targetInBlock: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- readBlockHeader()</TD></TR>
<TR><TD ALIGN="LEFT" ># writeBitSet(it: DocIdSetIterator, out: IndexOutput): short</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeBitSet(it: DocIdSetIterator, out: IndexOutput, denseRankPower: byte): short</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexedDISI965738438[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexedDISI</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   block: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockEnd: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cost: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   doc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   exists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   gap: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   index: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   method: Method [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextBlockIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numberOfOnes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   slice: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   word: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   wordIndex: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- advanceBlock(targetBlock: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- flush(block: int, buffer: FixedBitSet, cardinality: int, out: IndexOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ index(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readBlockHeader()</TD></TR>
<TR><TD ALIGN="LEFT" ># writeBitSet(it: DocIdSetIterator, out: IndexOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexedDISI965738469[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexedDISI</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   block: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockEnd: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cost: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseBitmapOffset: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseOrigoIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseRankPower: byte [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   denseRankTable: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   doc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   exists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   gap: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   index: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   jumpTable: RandomAccessInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   jumpTableEntryCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   method: Method [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nextBlockIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numberOfOnes: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   slice: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   word: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   wordIndex: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addJumps(jumps: int[], offset: long, index: int, startBlock: int, endBlock: int): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- advanceBlock(targetBlock: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ createBlockSlice(slice: IndexInput, sliceDescription: String, offset: long, length: long, jumpTableEntryCount: int): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ createJumpTable(slice: IndexInput, offset: long, length: long, jumpTableEntryCount: int): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >- createRank(buffer: FixedBitSet, denseRankPower: byte): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- flush(block: int, buffer: FixedBitSet, cardinality: int, denseRankPower: byte, out: IndexOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- flushBlockJumps(jumps: int[], blockCount: int, out: IndexOutput): short</TD></TR>
<TR><TD ALIGN="LEFT" >+ index(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- rankSkip(disi: IndexedDISI, targetInBlock: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- readBlockHeader()</TD></TR>
<TR><TD ALIGN="LEFT" ># writeBitSet(it: DocIdSetIterator, out: IndexOutput): short</TD></TR>
<TR><TD ALIGN="LEFT" ># writeBitSet(it: DocIdSetIterator, out: IndexOutput, denseRankPower: byte): short</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IndexingChain250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IndexingChain</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   abortingExceptionConsumer: Consumer&lt;Throwable&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   byteBlockAllocator: Allocator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bytesUsed: Counter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docFields: PerField[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docValuesBytePool: ByteBlockPool [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldHash: PerField[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldInfos: Builder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fields: PerField[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasHitAbortingException: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hashMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexCreatedVersionMajor: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexWriterConfig: LiveIndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextFieldGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   storedFieldsConsumer: StoredFieldsConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termVectorsWriter: TermVectorsConsumer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termsHash: TermsHash [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalFieldCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorValuesConsumer: VectorValuesConsumer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># abort()</TD></TR>
<TR><TD ALIGN="LEFT" >- finishStoredFields()</TD></TR>
<TR><TD ALIGN="LEFT" ># flush(state: SegmentWriteState): DocMap</TD></TR>
<TR><TD ALIGN="LEFT" ># getHasDocValues(field: String): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >- getOrAddPerField(fieldName: String): PerField</TD></TR>
<TR><TD ALIGN="LEFT" >- getPerField(name: String): PerField</TD></TR>
<TR><TD ALIGN="LEFT" >- indexDocValue(docID: int, fp: PerField, dvType: DocValuesType, field: IndexableField)</TD></TR>
<TR><TD ALIGN="LEFT" >- indexVectorValue(docID: int, pf: PerField, vectorEncoding: VectorEncoding, field: IndexableField)</TD></TR>
<TR><TD ALIGN="LEFT" >- initializeFieldInfo(pf: PerField)</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeSortSegment(state: SegmentWriteState): DocMap</TD></TR>
<TR><TD ALIGN="LEFT" >- onAbortingException(th: Throwable)</TD></TR>
<TR><TD ALIGN="LEFT" >- oversizeDocFields()</TD></TR>
<TR><TD ALIGN="LEFT" ># processDocument(docID: int, document: Iterable&lt;? extends IndexableField&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- processField(docID: int, field: IndexableField, pf: PerField): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- rehash()</TD></TR>
<TR><TD ALIGN="LEFT" >- startStoredFields(docID: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- updateDocFieldSchema(fieldName: String, schema: FieldSchema, fieldType: IndexableFieldType)</TD></TR>
<TR><TD ALIGN="LEFT" >- validateIndexSortDVType(indexSort: Sort, fieldToValidate: String, dvType: DocValuesType)</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyUnIndexedFieldType(name: String, ft: IndexableFieldType)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeDocValues(state: SegmentWriteState, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeNorms(state: SegmentWriteState, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- writePoints(state: SegmentWriteState, sortMap: DocMap)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InfoStream2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InfoStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ isEnabled(component: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ message(component: String, message: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

InputIteratorWrapper258807294[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)InputIteratorWrapper</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   wrapped: BytesRefIterator [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ contexts(): Set&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ payload(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ weight(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IntArrayDocIdSet2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IntArrayDocIdSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   length: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IntBag2016300173[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IntBag</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   freqs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   keys: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mask: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># add(key: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># asMap(): Map&lt;Integer, Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- between(chainStart: int, chainEnd: int, slot: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># frequency(key: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- relocateAdjacentKeys(freeSlot: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># remove(key: int): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IntSorter12078005[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IntSorter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   missingValue: Integer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   providerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reverseMul: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valuesProvider: NumericDocValuesProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getComparableProviders(readers: List&lt;? extends LeafReader&gt;): ComparableProvider[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocComparator(reader: LeafReader, maxDoc: int): DocComparator</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

IntersectTermsEnum1104727281[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)IntersectTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   arcs: Arc&lt;BytesRef&gt;[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   automaton: Automaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   commonSuffix: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentFrame: IntersectTermsEnumFrame [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentTransition: Transition [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fr: FieldReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstReader: BytesReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   runAutomaton: RunAutomaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   savedStartTerm: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   stack: IntersectTermsEnumFrame[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   term: BytesRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" ># brToString(b: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >- copyTerm()</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getArc(ord: int): Arc&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getFrame(ord: int): IntersectTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- popPushNext(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- pushFrame(state: int): IntersectTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- seekToStartTerm(target: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >- setSavedStartTerm(startTerm: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Iterator1098935144[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Iterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># asBinaryDocValues(iterator: Iterator): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" ># asNumericDocValues(iterator: Iterator): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" ># binaryValue(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># delGen(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Iterator55156406[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Iterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   currentCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentValues: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pOff: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vOff: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- fillBlock()</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JavaLoggingInfoStream2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JavaLoggingInfoStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: Map&lt;String, Logger&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   componentToLoggerName: Function&lt;String, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   level: Level [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getLogger(component: String): Logger</TD></TR>
<TR><TD ALIGN="LEFT" >+ isEnabled(component: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ message(component: String, message: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

JavaUtilBitSet2098602577[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)JavaUtilBitSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bitSet: BitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBits: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ approximateCardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ cardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(index: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(startIndex: int, endIndex: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAndSet(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextSetBit(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ prevSetBit(index: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KnnFieldVectorsWriter985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KnnFieldVectorsWriter&lt;T&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addValue(docID: int, vectorValue: T)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyValue(vectorValue: T): T</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KnnVectorsFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KnnVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
<TR><TD ALIGN="LEFT" >+ forName(name: String): KnnVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KnnVectorsReader985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KnnVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

KnnVectorsWriter985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)KnnVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addField(fieldInfo: FieldInfo): KnnFieldVectorsWriter&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush(maxDoc: int, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeOneField(fieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LRUQueryCache536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LRUQueryCache</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: Map&lt;CacheKey, LeafCache&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hitCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leavesToCache: Predicate&lt;LeafReaderContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lock: ReentrantLock [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxRamBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   missCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mostRecentlyUsedQueries: Set&lt;Query&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   skipCacheFactor: float [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   uniqueQueries: Map&lt;Query, Query&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># assertConsistent()</TD></TR>
<TR><TD ALIGN="LEFT" ># cacheImpl(scorer: BulkScorer, maxDoc: int): CacheAndCount</TD></TR>
<TR><TD ALIGN="LEFT" >- cacheIntoBitSet(scorer: BulkScorer, maxDoc: int): CacheAndCount</TD></TR>
<TR><TD ALIGN="LEFT" >- cacheIntoRoaringDocIdSet(scorer: BulkScorer, maxDoc: int): CacheAndCount</TD></TR>
<TR><TD ALIGN="LEFT" ># cachedQueries(): List&lt;Query&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearCoreCacheKey(coreKey: Object)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clearQuery(query: Query)</TD></TR>
<TR><TD ALIGN="LEFT" >+ doCache(weight: Weight, policy: QueryCachingPolicy): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >- evictIfNecessary()</TD></TR>
<TR><TD ALIGN="LEFT" ># get(key: Query, cacheHelper: CacheHelper): CacheAndCount</TD></TR>
<TR><TD ALIGN="LEFT" ># onClear()</TD></TR>
<TR><TD ALIGN="LEFT" ># onDocIdSetCache(readerCoreKey: Object, ramBytesUsed: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># onDocIdSetEviction(readerCoreKey: Object, numEntries: int, sumRamBytesUsed: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- onEviction(singleton: Query)</TD></TR>
<TR><TD ALIGN="LEFT" ># onHit(readerCoreKey: Object, query: Query)</TD></TR>
<TR><TD ALIGN="LEFT" ># onMiss(readerCoreKey: Object, query: Query)</TD></TR>
<TR><TD ALIGN="LEFT" ># onQueryCache(query: Query, ramBytesUsed: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># onQueryEviction(query: Query, ramBytesUsed: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- putIfAbsent(query: Query, cached: CacheAndCount, cacheHelper: CacheHelper)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># requiresEviction(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LZ41930041880[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LZ4</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- commonBytes(b: byte[], o1: int, o2: int, limit: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ compress(bytes: byte[], off: int, len: int, out: DataOutput, ht: HashTable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ compressWithDictionary(bytes: byte[], dictOff: int, dictLen: int, len: int, out: DataOutput, ht: HashTable)</TD></TR>
<TR><TD ALIGN="LEFT" >+ decompress(compressed: DataInput, decompressedLen: int, dest: byte[], dOff: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeLastLiterals(bytes: byte[], anchor: int, literalLen: int, out: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeLen(l: int, out: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeLiterals(bytes: byte[], token: int, anchor: int, literalLen: int, out: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeSequence(bytes: byte[], anchor: int, matchRef: int, matchOff: int, matchLen: int, out: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- hash(i: int, hashBits: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- hashHC(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readInt(buf: byte[], i: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LZ4WithPresetCompressingCodec673666990[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LZ4WithPresetCompressingCodec</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LeafCache915011271[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LeafCache</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cache: Map&lt;Query, CacheAndCount&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   key: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># get(query: Query): CacheAndCount</TD></TR>
<TR><TD ALIGN="LEFT" >- onDocIdSetCache(ramBytesUsed: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- onDocIdSetEviction(ramBytesUsed: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># putIfAbsent(query: Query, cached: CacheAndCount)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># remove(query: Query)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LeafMetaData250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LeafMetaData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   createdVersionMajor: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minVersion: Version [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sort: Sort [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LeafReader250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LeafReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   readerContext: LeafReaderContext [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(term: Term): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinaryDocValues(field: String): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocCount(field: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNormValues(field: String): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumericDocValues(field: String): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPointValues(field: String): PointValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedDocValues(field: String): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumericDocValues(field: String): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSetDocValues(field: String): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSumDocFreq(field: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSumTotalTermFreq(field: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(term: Term, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(term: Term): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ searchNearestVectors(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ searchNearestVectors(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(term: Term): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LeafReaderContext250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LeafReaderContext</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   docBase: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   leaves: List&lt;LeafReaderContext&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   ord: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: LeafReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ children(): List&lt;IndexReaderContext&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ leaves(): List&lt;LeafReaderContext&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ reader(): LeafReader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LegacyDirectMonotonicReader86183421[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LegacyDirectMonotonicReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   avgs: float[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bpvs: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mins: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nonZeroBpvs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readers: LongValues[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ binarySearch(fromIndex: long, toIndex: long, key: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getBounds(index: long): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInstance(meta: Meta, data: RandomAccessInput): LegacyDirectMonotonicReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ loadMeta(metaIn: IndexInput, numValues: long, blockShift: int): Meta</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LegacyDirectMonotonicWriter86183421[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LegacyDirectMonotonicWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   baseDataPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   buffer: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bufferSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   data: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   finished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   meta: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numValues: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   previous: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(v: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >- flush()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInstance(metaOut: IndexOutput, dataOut: IndexOutput, numValues: long, blockShift: int): LegacyDirectMonotonicWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LegacyDirectWriter86183421[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LegacyDirectWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bitsPerValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   encoder: Encoder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   finished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   iterations: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nextBlocks: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nextValues: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numValues: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   off: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   output: DataOutput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(l: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ bitsRequired(maxValue: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >- computeIterations(encoder: Encoder, valueCount: int, ramBudget: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >- flush()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getInstance(output: DataOutput, numValues: long, bitsPerValue: int): LegacyDirectWriter</TD></TR>
<TR><TD ALIGN="LEFT" >- roundBits(bitsRequired: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ unsignedBitsRequired(maxValue: long): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LegacyPacked6486183421[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LegacyPacked64</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bitsPerValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blocks: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bpvMinusBlockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maskRight: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   valueCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int, arr: long[], off: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LegacyPacked64SingleBlock86183421[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LegacyPacked64SingleBlock</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bitsPerValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blocks: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   valueCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ create(in: DataInput, valueCount: int, bitsPerValue: int): LegacyPacked64SingleBlock</TD></TR>
<TR><TD ALIGN="LEFT" >- create(valueCount: int, bitsPerValue: int): LegacyPacked64SingleBlock</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int, arr: long[], off: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSupported(bitsPerValue: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- requiredCapacity(valueCount: int, valuesPerBlock: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LiveDocsFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LiveDocsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ files(info: SegmentCommitInfo, files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLiveDocs(dir: Directory, info: SegmentCommitInfo, context: IOContext): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLiveDocs(bits: Bits, dir: Directory, info: SegmentCommitInfo, newDelCount: int, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LiveIndexWriterConfig250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LiveIndexWriterConfig</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   analyzer: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   checkPendingFlushOnUpdate: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   commit: IndexCommit [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   commitOnClose: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   createdVersionMajor: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   delPolicy: IndexDeletionPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   eventListener: IndexWriterEventListener [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   flushPolicy: FlushPolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexSort: Sort [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexSortFields: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   leafSorter: Comparator&lt;LeafReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxBufferedDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxFullFlushMergeWaitMillis: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergePolicy: MergePolicy [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergeScheduler: MergeScheduler [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergedSegmentWarmer: IndexReaderWarmer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   openMode: OpenMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   perThreadHardLimitMB: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBufferSizeMB: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readerPooling: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   similarity: Similarity [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   softDeletesField: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   useCompoundFile: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ setCheckPendingFlushUpdate(checkPendingFlushOnUpdate: boolean): LiveIndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxBufferedDocs(maxBufferedDocs: int): LiveIndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMergePolicy(mergePolicy: MergePolicy): LiveIndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMergedSegmentWarmer(mergeSegmentWarmer: IndexReaderWarmer): LiveIndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setRAMBufferSizeMB(ramBufferSizeMB: double): LiveIndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ setUseCompoundFile(useCompoundFile: boolean): LiveIndexWriterConfig</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lock260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lock</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ ensureValid()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LogByteSizeMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LogByteSizeMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># size(info: SegmentCommitInfo, mergeContext: MergeContext): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LogDocMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LogDocMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># size(info: SegmentCommitInfo, mergeContext: MergeContext): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LogMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LogMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   calibrateSizeByDeletes: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxMergeDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxMergeSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxMergeSizeForForcedMerge: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergeFactor: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   minMergeSize: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findForcedDeletesMerges(segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedMerges(infos: SegmentInfos, maxNumSegments: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >- findForcedMergesMaxNumSegments(infos: SegmentInfos, maxNumSegments: int, last: int, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >- findForcedMergesSizeLimit(infos: SegmentInfos, last: int, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, infos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" ># isMerged(infos: SegmentInfos, maxNumSegments: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># maxFullFlushMergeSize(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># sizeBytes(info: SegmentCommitInfo, mergeContext: MergeContext): long</TD></TR>
<TR><TD ALIGN="LEFT" ># sizeDocs(info: SegmentCommitInfo, mergeContext: MergeContext): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LongBitSet2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LongBitSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bits: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBits: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numWords: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ and(other: LongBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >+ andNot(other: LongBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >+ bits2words(numBits: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ cardinality(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(index: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(startIndex: long, endIndex: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): LongBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ ensureCapacity(bits: LongBitSet, numBits: long): LongBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ flip(startIndex: long, endIndex: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flip(index: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAndClear(index: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAndSet(index: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ intersects(other: LongBitSet): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextSetBit(index: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ or(other: LongBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >+ prevSetBit(index: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ scanIsEmpty(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyGhostBitsClear(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ xor(other: LongBitSet)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LongHashSet14040943[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LongHashSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   hasMissingValue: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxValue: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   minValue: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   size: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   table: long[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- add(l: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># contains(l: long): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># size(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># stream(): LongStream</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LongSorter12078005[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LongSorter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   missingValue: Long [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   providerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reverseMul: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valuesProvider: NumericDocValuesProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getComparableProviders(readers: List&lt;? extends LeafReader&gt;): ComparableProvider[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocComparator(reader: LeafReader, maxDoc: int): DocComparator</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LongValues2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LongValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lookup833569740[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lookup</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(dict: Dictionary)</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(inputIterator: InputIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(input: InputStream): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(input: DataInput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, onlyMorePopular: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, onlyMorePopular: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contextFilerQuery: BooleanQuery, num: int, allTermsRequired: boolean, doHighlight: boolean): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ store(output: OutputStream): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ store(output: DataOutput): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LowFreqTerm181433766[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LowFreqTerm</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   docFreq: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   payloads: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   postings: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   totalTermFreq: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene40BlockTreeTermsReader873722522[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene40BlockTreeTermsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fieldList: List&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldMap: Map&lt;String, FieldReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsReader: PostingsReaderBase [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segment: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termsIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># brToString(b: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readBytesRef(in: IndexInput): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >- seekDir(input: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50CompoundFormat965738376[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50CompoundFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getCompoundReader(dir: Directory, si: SegmentInfo, context: IOContext): CompoundDirectory</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50CompressingStoredFieldsFormat1265304538[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50CompressingStoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blockShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   formatName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDocsPerChunk: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segmentSuffix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50CompressingStoredFieldsReader1265304538[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50CompressingStoredFieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   decompressor: Decompressor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldsStream: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexReader: FieldsIndex [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packedIntsVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: BlockState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" >- readField(in: DataInput, visitor: StoredFieldVisitor, info: FieldInfo, bits: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># readTLong(in: DataInput): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readZDouble(in: DataInput): double</TD></TR>
<TR><TD ALIGN="LEFT" ># readZFloat(in: DataInput): float</TD></TR>
<TR><TD ALIGN="LEFT" ># serializedDocument(docID: int): SerializedDocument</TD></TR>
<TR><TD ALIGN="LEFT" >- skipField(in: DataInput, bits: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50CompressingTermVectorsFormat1265304538[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50CompressingTermVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   formatName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDocsPerChunk: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segmentSuffix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ vectorsReader(directory: Directory, segmentInfo: SegmentInfo, fieldInfos: FieldInfos, context: IOContext): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorsWriter(directory: Directory, segmentInfo: SegmentInfo, context: IOContext): TermVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50CompressingTermVectorsReader1265304538[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50CompressingTermVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   decompressor: Decompressor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexReader: FieldsIndex [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packedIntsVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: BlockPackedReaderIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorsStream: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(doc: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" >- positionIndex(skip: int, numFields: int, numTerms: Reader, termFreqs: int[]): int[][]</TD></TR>
<TR><TD ALIGN="LEFT" >- readPositions(skip: int, numFields: int, flags: Reader, numTerms: Reader, termFreqs: int[], flag: int, totalPositions: int, positionIndex: int[][]): int[][]</TD></TR>
<TR><TD ALIGN="LEFT" >- sum(arr: int[]): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50LiveDocsFormat965738376[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50LiveDocsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ files(info: SegmentCommitInfo, files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- readFixedBitSet(input: IndexInput, length: int): FixedBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLiveDocs(dir: Directory, info: SegmentCommitInfo, context: IOContext): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >- writeBits(output: IndexOutput, bits: Bits): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLiveDocs(bits: Bits, dir: Directory, info: SegmentCommitInfo, newDelCount: int, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50PostingsFormat965738376[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50StoredFieldsFormat965738376[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50StoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   mode: Mode [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
<TR><TD ALIGN="LEFT" ># impl(mode: Mode): StoredFieldsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene50TermVectorsFormat965738376[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene50TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene60FieldInfosFormat965738407[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene60FieldInfosFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- docValuesByte(type: DocValuesType): byte</TD></TR>
<TR><TD ALIGN="LEFT" >- getDocValuesType(input: IndexInput, b: byte): DocValuesType</TD></TR>
<TR><TD ALIGN="LEFT" >- getIndexOptions(input: IndexInput, b: byte): IndexOptions</TD></TR>
<TR><TD ALIGN="LEFT" >- indexOptionsByte(indexOptions: IndexOptions): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, context: IOContext): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >- readFieldInfos(input: IndexInput, version: int): FieldInfo[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, infos: FieldInfos, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene60PointsFormat965738407[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene60PointsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): PointsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): PointsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene60PointsReader965738407[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene60PointsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dataIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readState: SegmentReadState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readers: Map&lt;Integer, PointValues&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getValues(fieldName: String): PointValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene70Codec965738438[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene70Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene70DocValuesConsumer965738438[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene70DocValuesConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   data: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   meta: IndexOutput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedSetField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- addTermsDict(values: SortedSetDocValues)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- doAddSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeBlock(values: long[], length: int, gcd: long, buffer: ByteBuffersDataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeTermsIndex(values: SortedSetDocValues)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValues(field: FieldInfo, valuesProducer: DocValuesProducer): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValuesMultipleBlocks(values: SortedNumericDocValues, gcd: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValuesSingleBlock(values: SortedNumericDocValues, numValues: long, numBitsPerValue: int, min: long, gcd: long, encode: Map&lt;Long, Integer&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene70DocValuesFormat965738438[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene70DocValuesFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): DocValuesProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene70DocValuesProducer965738438[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene70DocValuesProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   binaries: Map&lt;String, BinaryEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numerics: Map&lt;String, NumericEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sorted: Map&lt;String, SortedEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sortedNumerics: Map&lt;String, SortedNumericEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sortedSets: Map&lt;String, SortedSetEntry&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(field: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumeric(entry: NumericEntry): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumericValues(entry: NumericEntry): LongValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(field: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getSorted(entry: SortedEntry): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(field: FieldInfo): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- readBinary(meta: ChecksumIndexInput): BinaryEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: ChecksumIndexInput, infos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- readNumeric(meta: ChecksumIndexInput): NumericEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readNumeric(meta: ChecksumIndexInput, entry: NumericEntry)</TD></TR>
<TR><TD ALIGN="LEFT" >- readSorted(meta: ChecksumIndexInput): SortedEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readSortedNumeric(meta: ChecksumIndexInput): SortedNumericEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readSortedSet(meta: ChecksumIndexInput): SortedSetEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readTermDict(meta: ChecksumIndexInput, entry: TermsDictEntry)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene70NormsFormat965738438[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene70NormsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ normsConsumer(state: SegmentWriteState): NormsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsProducer(state: SegmentReadState): NormsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene70NormsProducer965738438[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene70NormsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataInputs: Map&lt;Integer, RandomAccessInput&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   disiInputs: Map&lt;Integer, IndexInput&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   norms: Map&lt;Integer, NormsEntry&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getDataInput(field: FieldInfo, entry: NormsEntry): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >- getDisiInput(field: FieldInfo, entry: NormsEntry): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNorms(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: IndexInput, infos: FieldInfos)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene70SegmentInfoFormat965738438[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene70SegmentInfoFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- parseSegmentInfo(dir: Directory, input: DataInput, segment: String, segmentID: byte[]): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(dir: Directory, segment: String, segmentID: byte[], context: IOContext): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, ioContext: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene80Codec965738469[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene80Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene80DocValuesConsumer965738469[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene80DocValuesConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   data: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   meta: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mode: Mode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: SegmentWriteState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termsDictBuffer: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedSetField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- addTermsDict(values: SortedSetDocValues)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- compressAndGetTermsDictBlockLength(bufferedOutput: ByteArrayDataOutput, ht: FastCompressionHashTable): int</TD></TR>
<TR><TD ALIGN="LEFT" >- doAddCompressedBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- doAddSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- doAddUncompressedBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeGrowBuffer(bufferedOutput: ByteArrayDataOutput, termLength: int): ByteArrayDataOutput</TD></TR>
<TR><TD ALIGN="LEFT" >- writeBlock(values: long[], length: int, gcd: long, buffer: ByteBuffersDataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeTermsIndex(values: SortedSetDocValues)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValues(field: FieldInfo, valuesProducer: DocValuesProducer): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValuesMultipleBlocks(values: SortedNumericDocValues, gcd: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValuesSingleBlock(values: SortedNumericDocValues, numValues: long, numBitsPerValue: int, min: long, gcd: long, encode: Map&lt;Long, Integer&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene80DocValuesFormat965738469[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene80DocValuesFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   mode: Mode [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): DocValuesProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene80DocValuesProducer965738469[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene80DocValuesProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   binaries: Map&lt;String, BinaryEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numerics: Map&lt;String, NumericEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sorted: Map&lt;String, SortedEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sortedNumerics: Map&lt;String, SortedNumericEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sortedSets: Map&lt;String, SortedSetEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(field: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getCompressedBinary(entry: BinaryEntry): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumeric(entry: NumericEntry): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumericValues(entry: NumericEntry): LongValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(field: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getSorted(entry: SortedEntry): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(field: FieldInfo): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getUncompressedBinary(entry: BinaryEntry): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- readBinary(meta: IndexInput, compressed: boolean): BinaryEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(segmentName: String, meta: IndexInput, infos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- readNumeric(meta: IndexInput): NumericEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readNumeric(meta: IndexInput, entry: NumericEntry)</TD></TR>
<TR><TD ALIGN="LEFT" >- readSorted(meta: IndexInput): SortedEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readSortedNumeric(meta: IndexInput): SortedNumericEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readSortedSet(meta: IndexInput): SortedSetEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readTermDict(meta: IndexInput, entry: TermsDictEntry)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene80NormsFormat965738469[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene80NormsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ normsConsumer(state: SegmentWriteState): NormsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsProducer(state: SegmentReadState): NormsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene80NormsProducer965738469[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene80NormsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataInputs: Map&lt;Integer, RandomAccessInput&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   disiInputs: Map&lt;Integer, IndexInput&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   disiJumpTables: Map&lt;Integer, RandomAccessInput&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   norms: Map&lt;Integer, NormsEntry&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getDataInput(field: FieldInfo, entry: NormsEntry): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >- getDisiInput(field: FieldInfo, entry: NormsEntry): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >- getDisiJumpTable(field: FieldInfo, entry: NormsEntry): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNorms(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: IndexInput, infos: FieldInfos)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene84Codec965738473[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene84Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene84PostingsFormat965738473[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene84PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene86Codec965738475[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene86Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointsFormat: PointsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene86PointsFormat965738475[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene86PointsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): PointsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): PointsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene86PointsReader965738475[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene86PointsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dataIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readState: SegmentReadState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readers: Map&lt;Integer, PointValues&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getValues(fieldName: String): PointValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene86SegmentInfoFormat965738475[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene86SegmentInfoFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- parseSegmentInfo(dir: Directory, input: DataInput, segment: String, segmentID: byte[]): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(dir: Directory, segment: String, segmentID: byte[], context: IOContext): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, ioContext: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene87Codec965738476[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene87Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointsFormat: PointsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene87StoredFieldsFormat965738476[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene87StoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   mode: Mode [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
<TR><TD ALIGN="LEFT" ># impl(mode: Mode): StoredFieldsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90BlockTreeTermsReader1104727281[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90BlockTreeTermsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fieldList: List&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldMap: Map&lt;String, FieldReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsReader: PostingsReaderBase [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segment: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termsIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># brToString(b: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readBytesRef(in: IndexInput): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90Codec965738500[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultKnnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultPostingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   knnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKnnVectorsFormatForField(field: String): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90CompoundFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90CompoundFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getCompoundReader(dir: Directory, si: SegmentInfo, context: IOContext): CompoundDirectory</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, context: IOContext)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeCompoundFile(entries: IndexOutput, data: IndexOutput, dir: Directory, si: SegmentInfo)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90CompressingStoredFieldsFormat390611718[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90CompressingStoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   formatName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDocsPerChunk: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentSuffix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90CompressingStoredFieldsReader390611718[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90CompressingStoredFieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   decompressor: Decompressor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldsStream: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexReader: FieldsIndex [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numChunks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDirtyChunks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDirtyDocs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: BlockState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" ># isLoaded(docID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- readField(in: DataInput, visitor: StoredFieldVisitor, info: FieldInfo, bits: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># readTLong(in: DataInput): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readZDouble(in: DataInput): double</TD></TR>
<TR><TD ALIGN="LEFT" ># readZFloat(in: DataInput): float</TD></TR>
<TR><TD ALIGN="LEFT" ># serializedDocument(docID: int): SerializedDocument</TD></TR>
<TR><TD ALIGN="LEFT" >- skipField(in: DataInput, bits: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90CompressingStoredFieldsWriter390611718[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90CompressingStoredFieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bufferedDocs: ByteBuffersDataOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressor: Compressor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docBase: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endOffsets: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldsStream: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexWriter: FieldsIndexWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDocsPerChunk: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metaStream: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBufferedDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numChunks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDirtyChunks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDirtyDocs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numStoredFields: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numStoredFieldsInDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segment: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- copyChunks(mergeState: MergeState, sub: CompressingStoredFieldsMergeSub, fromDocID: int, toDocID: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- copyOneDoc(reader: Lucene90CompressingStoredFieldsReader, docID: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >- flush(force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- getMergeStrategy(mergeState: MergeState, matchingReaders: MatchingReaders, readerIndex: int): MergeStrategy</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- saveInts(values: int[], length: int, out: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument()</TD></TR>
<TR><TD ALIGN="LEFT" ># tooDirty(candidate: Lucene90CompressingStoredFieldsReader): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- triggerFlush(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: float)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: double)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeHeader(docBase: int, numBufferedDocs: int, numStoredFields: int[], lengths: int[], sliced: boolean, dirtyChunk: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeTLong(out: DataOutput, l: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeZDouble(out: DataOutput, d: double)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeZFloat(out: DataOutput, f: float)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90CompressingTermVectorsFormat390611718[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90CompressingTermVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   formatName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDocsPerChunk: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentSuffix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ vectorsReader(directory: Directory, segmentInfo: SegmentInfo, fieldInfos: FieldInfos, context: IOContext): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorsWriter(directory: Directory, segmentInfo: SegmentInfo, context: IOContext): TermVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90CompressingTermVectorsReader390611718[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90CompressingTermVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockState: BlockState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   decompressor: Decompressor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexReader: FieldsIndex [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numChunks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDirtyChunks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDirtyDocs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packedIntsVersion: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: BlockPackedReaderIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorsStream: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureOpen()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(doc: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" ># isLoaded(docID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- positionIndex(skip: int, numFields: int, numTerms: LongValues, termFreqs: int[]): int[][]</TD></TR>
<TR><TD ALIGN="LEFT" >- readPositions(skip: int, numFields: int, flags: LongValues, numTerms: LongValues, termFreqs: int[], flag: int, totalPositions: int, positionIndex: int[][]): int[][]</TD></TR>
<TR><TD ALIGN="LEFT" >- slice(in: IndexInput): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >- sum(arr: int[]): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90CompressingTermVectorsWriter390611718[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90CompressingTermVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   chunkSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressionMode: CompressionMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   compressor: Compressor [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   curDoc: DocData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   curField: FieldData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexWriter: FieldsIndexWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastTerm: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lengthsBuf: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDocsPerChunk: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metaStream: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numChunks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDirtyChunks: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDirtyDocs: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadBytes: ByteBuffersDataOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadLengthsBuf: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingDocs: Deque&lt;DocData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positionsBuf: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchBuffer: ByteBuffersDataOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segment: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startOffsetsBuf: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termSuffixes: ByteBuffersDataOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsStream: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: BlockPackedWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addDocData(numVectorFields: int): DocData</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPosition(position: int, startOffset: int, endOffset: int, payload: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProx(numProx: int, positions: DataInput, offsets: DataInput)</TD></TR>
<TR><TD ALIGN="LEFT" >- canPerformBulkMerge(mergeState: MergeState, matchingReaders: MatchingReaders, readerIndex: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- copyChunks(mergeState: MergeState, sub: CompressingTermVectorsSub, fromDocID: int, toDocID: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishField()</TD></TR>
<TR><TD ALIGN="LEFT" >- flush(force: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- flushFieldNums(): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >- flushFields(totalFields: int, fieldNums: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >- flushFlags(totalFields: int, fieldNums: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >- flushNumFields(chunkDocs: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- flushNumTerms(totalFields: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- flushOffsets(fieldNums: int[])</TD></TR>
<TR><TD ALIGN="LEFT" >- flushPayloadLengths()</TD></TR>
<TR><TD ALIGN="LEFT" >- flushPositions()</TD></TR>
<TR><TD ALIGN="LEFT" >- flushTermFreqs()</TD></TR>
<TR><TD ALIGN="LEFT" >- flushTermLengths()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument(numVectorFields: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startField(info: FieldInfo, numTerms: int, positions: boolean, offsets: boolean, payloads: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startTerm(term: BytesRef, freq: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># tooDirty(candidate: Lucene90CompressingTermVectorsReader): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- triggerFlush(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90DocValuesConsumer961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90DocValuesConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   data: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   meta: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termsDictBuffer: byte[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedSetField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- addTermsDict(values: SortedSetDocValues)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- compressAndGetTermsDictBlockLength(bufferedOutput: ByteArrayDataOutput, dictLength: int, ht: FastCompressionHashTable): int</TD></TR>
<TR><TD ALIGN="LEFT" >- doAddSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- doAddSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer, ords: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- isSingleValued(values: SortedSetDocValues): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeGrowBuffer(bufferedOutput: ByteArrayDataOutput, termLength: int): ByteArrayDataOutput</TD></TR>
<TR><TD ALIGN="LEFT" >- writeBlock(values: long[], length: int, gcd: long, buffer: ByteBuffersDataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeTermsIndex(values: SortedSetDocValues)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValues(field: FieldInfo, valuesProducer: DocValuesProducer, ords: boolean): long[]</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValuesMultipleBlocks(values: SortedNumericDocValues, gcd: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- writeValuesSingleBlock(values: SortedNumericDocValues, numValues: long, numBitsPerValue: int, min: long, gcd: long, encode: Map&lt;Long, Integer&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90DocValuesFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90DocValuesFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): DocValuesProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90DocValuesProducer961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90DocValuesProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   binaries: Map&lt;String, BinaryEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numerics: Map&lt;String, NumericEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sorted: Map&lt;String, SortedEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sortedNumerics: Map&lt;String, SortedNumericEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sortedSets: Map&lt;String, SortedSetEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(field: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getDirectReaderInstance(slice: RandomAccessInput, bitsPerValue: int, offset: long, numValues: long): LongValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumeric(entry: NumericEntry): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumericValues(entry: NumericEntry): LongValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(field: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getSorted(entry: SortedEntry): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getSortedNumeric(entry: SortedNumericEntry): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(field: FieldInfo): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- readBinary(meta: IndexInput): BinaryEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: IndexInput, infos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- readNumeric(meta: IndexInput): NumericEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readNumeric(meta: IndexInput, entry: NumericEntry)</TD></TR>
<TR><TD ALIGN="LEFT" >- readSorted(meta: IndexInput): SortedEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readSortedNumeric(meta: IndexInput): SortedNumericEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readSortedNumeric(meta: IndexInput, entry: SortedNumericEntry): SortedNumericEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readSortedSet(meta: IndexInput): SortedSetEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readTermDict(meta: IndexInput, entry: TermsDictEntry)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90FieldInfosFormat965738500[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90FieldInfosFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- docValuesByte(type: DocValuesType): byte</TD></TR>
<TR><TD ALIGN="LEFT" >- getDistFunc(input: IndexInput, b: byte): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >- getDocValuesType(input: IndexInput, b: byte): DocValuesType</TD></TR>
<TR><TD ALIGN="LEFT" >- getIndexOptions(input: IndexInput, b: byte): IndexOptions</TD></TR>
<TR><TD ALIGN="LEFT" >- indexOptionsByte(indexOptions: IndexOptions): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, context: IOContext): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, infos: FieldInfos, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90HnswVectorsFormat965738500[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90HnswVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   beamWidth: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxConn: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90HnswVectorsReader965738500[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90HnswVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   checksumSeed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, FieldEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorData: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorIndex: IndexInput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getAcceptOrds(acceptDocs: Bits, fieldEntry: FieldEntry): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getGraphValues(entry: FieldEntry): HnswGraph</TD></TR>
<TR><TD ALIGN="LEFT" >- getOffHeapVectorValues(fieldEntry: FieldEntry): OffHeapFloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >- openDataInput(state: SegmentReadState, versionMeta: int, fileExtension: String, codecName: String, checksumRef: long[]): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readField(input: DataInput): FieldEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: ChecksumIndexInput, infos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- readMetadata(state: SegmentReadState): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readSimilarityFunction(input: DataInput): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >- validateFieldEntry(info: FieldInfo, fieldEntry: FieldEntry)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90LiveDocsFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90LiveDocsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ files(info: SegmentCommitInfo, files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- readFixedBitSet(input: IndexInput, length: int): FixedBitSet</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLiveDocs(dir: Directory, info: SegmentCommitInfo, context: IOContext): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >- writeBits(output: IndexOutput, bits: Bits): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLiveDocs(bits: Bits, dir: Directory, info: SegmentCommitInfo, newDelCount: int, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90NormsFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90NormsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ normsConsumer(state: SegmentWriteState): NormsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsProducer(state: SegmentReadState): NormsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90NormsProducer961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90NormsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dataInputs: Map&lt;Integer, RandomAccessInput&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   disiInputs: Map&lt;Integer, IndexInput&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   disiJumpTables: Map&lt;Integer, RandomAccessInput&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   merging: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   norms: Map&lt;Integer, NormsEntry&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getDataInput(field: FieldInfo, entry: NormsEntry): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >- getDisiInput(field: FieldInfo, entry: NormsEntry): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >- getDisiJumpTable(field: FieldInfo, entry: NormsEntry): RandomAccessInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNorms(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: IndexInput, infos: FieldInfos)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90PointsFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90PointsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): PointsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): PointsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90PointsReader961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90PointsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dataIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readState: SegmentReadState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readers: Map&lt;Integer, PointValues&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getValues(fieldName: String): PointValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90PointsWriter961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90PointsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dataOut: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   finished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexOut: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxMBSortInHeap: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxPointsInLeafNode: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   metaOut: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writeState: SegmentWriteState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(fieldInfo: FieldInfo, reader: PointsReader)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90PostingsFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   maxTermBlockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minTermBlockSize: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90SegmentInfoFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90SegmentInfoFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- parseSegmentInfo(dir: Directory, input: DataInput, segment: String, segmentID: byte[]): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(dir: Directory, segment: String, segmentID: byte[], context: IOContext): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, ioContext: IOContext)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeSegmentInfo(output: DataOutput, si: SegmentInfo)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90StoredFieldsFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90StoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   mode: Mode [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
<TR><TD ALIGN="LEFT" ># impl(mode: Mode): StoredFieldsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene90TermVectorsFormat961650868[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene90TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene91Codec965738501[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene91Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultKnnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultPostingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   knnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKnnVectorsFormatForField(field: String): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene91HnswVectorsFormat965738501[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene91HnswVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   beamWidth: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxConn: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene91HnswVectorsReader965738501[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene91HnswVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, FieldEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorData: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorIndex: IndexInput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getAcceptOrds(acceptDocs: Bits, fieldEntry: FieldEntry): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getGraph(entry: FieldEntry): HnswGraph</TD></TR>
<TR><TD ALIGN="LEFT" >- getOffHeapVectorValues(fieldEntry: FieldEntry): OffHeapFloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >- openDataInput(state: SegmentReadState, versionMeta: int, fileExtension: String, codecName: String): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readField(input: DataInput): FieldEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: ChecksumIndexInput, infos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- readMetadata(state: SegmentReadState): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readSimilarityFunction(input: DataInput): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >- validateFieldEntry(info: FieldInfo, fieldEntry: FieldEntry)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene92Codec965738502[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene92Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultKnnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultPostingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   knnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKnnVectorsFormatForField(field: String): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene92HnswVectorsFormat965738502[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene92HnswVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   beamWidth: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxConn: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene92HnswVectorsReader965738502[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene92HnswVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, FieldEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorData: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorIndex: IndexInput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getGraph(entry: FieldEntry): HnswGraph</TD></TR>
<TR><TD ALIGN="LEFT" >- openDataInput(state: SegmentReadState, versionMeta: int, fileExtension: String, codecName: String): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readField(input: IndexInput): FieldEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: ChecksumIndexInput, infos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- readMetadata(state: SegmentReadState): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readSimilarityFunction(input: DataInput): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >- validateFieldEntry(info: FieldInfo, fieldEntry: FieldEntry)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene94Codec965738504[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene94Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultKnnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultPostingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   knnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKnnVectorsFormatForField(field: String): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene94FieldInfosFormat961650872[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene94FieldInfosFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- docValuesByte(type: DocValuesType): byte</TD></TR>
<TR><TD ALIGN="LEFT" >- getDistFunc(input: IndexInput, b: byte): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >- getDocValuesType(input: IndexInput, b: byte): DocValuesType</TD></TR>
<TR><TD ALIGN="LEFT" >- getIndexOptions(input: IndexInput, b: byte): IndexOptions</TD></TR>
<TR><TD ALIGN="LEFT" >- getVectorEncoding(input: IndexInput, b: byte): VectorEncoding</TD></TR>
<TR><TD ALIGN="LEFT" >- indexOptionsByte(indexOptions: IndexOptions): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, context: IOContext): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, infos: FieldInfos, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene94HnswVectorsFormat965738504[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene94HnswVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   beamWidth: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxConn: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene94HnswVectorsReader965738504[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene94HnswVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, FieldEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorData: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorIndex: IndexInput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getGraph(entry: FieldEntry): HnswGraph</TD></TR>
<TR><TD ALIGN="LEFT" >- openDataInput(state: SegmentReadState, versionMeta: int, fileExtension: String, codecName: String): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readField(input: IndexInput): FieldEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: ChecksumIndexInput, infos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- readMetadata(state: SegmentReadState): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readSimilarityFunction(input: DataInput): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >- readVectorEncoding(input: DataInput): VectorEncoding</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >- validateFieldEntry(info: FieldInfo, fieldEntry: FieldEntry)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene95Codec961650873[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene95Codec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultDVFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultKnnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   defaultPostingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   knnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocsFormat: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postingsFormat: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfosFormat: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFieldsFormat: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKnnVectorsFormatForField(field: String): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene95HnswVectorsFormat961650873[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene95HnswVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   beamWidth: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxConn: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene95HnswVectorsReader961650873[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene95HnswVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, FieldEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorData: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorIndex: IndexInput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getGraph(field: String): HnswGraph</TD></TR>
<TR><TD ALIGN="LEFT" >- getGraph(entry: FieldEntry): HnswGraph</TD></TR>
<TR><TD ALIGN="LEFT" >- openDataInput(state: SegmentReadState, versionMeta: int, fileExtension: String, codecName: String): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readField(input: IndexInput): FieldEntry</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(meta: ChecksumIndexInput, infos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- readMetadata(state: SegmentReadState): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readSimilarityFunction(input: DataInput): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >- readVectorEncoding(input: DataInput): VectorEncoding</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >- validateFieldEntry(info: FieldInfo, fieldEntry: FieldEntry)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Lucene95HnswVectorsWriter961650873[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Lucene95HnswVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   M: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   beamWidth: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fields: List&lt;FieldWriter&lt;?&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   finished: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   meta: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentWriteState: SegmentWriteState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorData: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorIndex: IndexOutput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addField(fieldInfo: FieldInfo): KnnFieldVectorsWriter&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- allMatch(bits: Bits): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- createHnswGraphBuilder(mergeState: MergeState, fieldInfo: FieldInfo, floatVectorValues: RandomAccessVectorValues&lt;T&gt;, initializerIndex: int): HnswGraphBuilder&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush(maxDoc: int, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- getHnswGraphFromReader(fieldName: String, knnVectorsReader: KnnVectorsReader): HnswGraph</TD></TR>
<TR><TD ALIGN="LEFT" >- getOldToNewOrdinalMap(mergeState: MergeState, fieldInfo: FieldInfo, initializerIndex: int): Map&lt;Integer, Integer&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- isCurrentVectorNull(docIdSetIterator: DocIdSetIterator): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeOneField(fieldInfo: FieldInfo, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- reconstructAndWriteGraph(graph: OnHeapHnswGraph, newToOldMap: int[], oldToNewMap: int[], levelNodeOffsets: int[][]): HnswGraph</TD></TR>
<TR><TD ALIGN="LEFT" >- reconstructAndWriteNeigbours(neighbors: NeighborArray, oldToNewMap: int[], maxConnOnLevel: int, maxOrd: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- selectGraphForInitialization(mergeState: MergeState, fieldInfo: FieldInfo): int</TD></TR>
<TR><TD ALIGN="LEFT" >- writeByteVectorData(output: IndexOutput, byteVectorValues: ByteVectorValues): DocsWithFieldSet</TD></TR>
<TR><TD ALIGN="LEFT" >- writeByteVectors(fieldData: FieldWriter&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeField(fieldData: FieldWriter&lt;?&gt;, maxDoc: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeFloat32Vectors(fieldData: FieldWriter&lt;?&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeGraph(graph: OnHeapHnswGraph): int[][]</TD></TR>
<TR><TD ALIGN="LEFT" >- writeMeta(field: FieldInfo, maxDoc: int, vectorDataOffset: long, vectorDataLength: long, vectorIndexOffset: long, vectorIndexLength: long, docsWithField: DocsWithFieldSet, graph: HnswGraph, graphLevelNodeOffsets: int[][])</TD></TR>
<TR><TD ALIGN="LEFT" >- writeSortedByteVectors(fieldData: FieldWriter&lt;?&gt;, ordMap: int[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >- writeSortedFloat32Vectors(fieldData: FieldWriter&lt;?&gt;, ordMap: int[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >- writeSortingField(fieldData: FieldWriter&lt;?&gt;, maxDoc: int, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeVectorData(output: IndexOutput, floatVectorValues: FloatVectorValues): DocsWithFieldSet</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LuceneFixedGap979182648[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LuceneFixedGap</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   termIndexInterval: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LuceneTestCase1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LuceneTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   parentChainCallRule: TestRuleSetupTeardownChained [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   ruleChain: TestRule [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   testFailureMarker: TestRuleMarkFailure [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   threadAndTestNameRule: TestRuleThreadAndTestName [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- _expectThrows(expectedTypes: List&lt;? extends Class&lt;?&gt;&gt;, runnable: ThrowingRunnable): Throwable</TD></TR>
<TR><TD ALIGN="LEFT" >+ addVirusChecker(path: Path): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ asSet(args: T...): Set&lt;T&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertDeletedDocsEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertDocValuesEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertDocValuesEquals(info: String, num: int, leftDocValues: NumericDocValues, rightDocValues: NumericDocValues)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertDocsAndPositionsEnumEquals(info: String, leftDocs: PostingsEnum, rightDocs: PostingsEnum)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertDocsEnumEquals(info: String, leftDocs: PostingsEnum, rightDocs: PostingsEnum, hasFreqs: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertDocsSkippingEquals(info: String, leftReader: IndexReader, docFreq: int, leftDocs: PostingsEnum, rightDocs: PostingsEnum, hasFreqs: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertFieldInfosEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertNormsEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertPointsEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertPositionsSkippingEquals(info: String, leftReader: IndexReader, docFreq: int, leftDocs: PostingsEnum, rightDocs: PostingsEnum)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertReaderEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertReaderStatisticsEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertStoredFieldEquals(info: String, leftField: IndexableField, rightField: IndexableField)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertStoredFieldsEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTermStatsEquals(info: String, leftTermsEnum: TermsEnum, rightTermsEnum: TermsEnum)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTermVectorsEquals(info: String, leftReader: IndexReader, rightReader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTermsEnumEquals(info: String, leftReader: IndexReader, leftTermsEnum: TermsEnum, rightTermsEnum: TermsEnum, deep: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTermsEquals(info: String, leftReader: IndexReader, rightReader: IndexReader, deep: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTermsEquals(info: String, leftReader: IndexReader, leftTerms: Terms, rightTerms: Terms, deep: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- assertTermsSeekingEquals(info: String, leftTerms: Terms, rightTerms: Terms)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertTermsStatisticsEquals(info: String, leftTerms: Terms, rightTerms: Terms)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assumeFalse(msg: String, condition: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assumeNoException(msg: String, e: Exception)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assumeTrue(msg: String, condition: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assumeWorkingMMapOnWindows()</TD></TR>
<TR><TD ALIGN="LEFT" >+ atLeast(random: Random, i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ atLeast(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ callStackContains(clazz: Class&lt;?&gt;, methodName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ callStackContains(clazz: Class&lt;?&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ callStackContainsAnyOf(methodNames: String...): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAfterSuite(resource: T): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ closeAfterTest(resource: T): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ collate(collator: Collator, s1: String, s2: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >- configureRandom(r: Random, mergePolicy: MergePolicy)</TD></TR>
<TR><TD ALIGN="LEFT" >- createField(name: String, value: Object, fieldType: FieldType): Field</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempDir(): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempDir(prefix: String): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempFile(prefix: String, suffix: String): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempFile(): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ dumpArray(label: String, objs: Object[], stream: PrintStream)</TD></TR>
<TR><TD ALIGN="LEFT" >+ dumpIterator(label: String, iter: Iterator&lt;?&gt;, stream: PrintStream)</TD></TR>
<TR><TD ALIGN="LEFT" ># ensureSaneIWCOnNightly(conf: IndexWriterConfig): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ expectThrows(expectedType: Class&lt;T&gt;, runnable: ThrowingRunnable): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ expectThrows(expectedType: Class&lt;T&gt;, noExceptionMessage: String, runnable: ThrowingRunnable): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ expectThrows(expectedOuterType: Class&lt;TO&gt;, expectedWrappedType: Class&lt;TW&gt;, runnable: ThrowingRunnable): TW</TD></TR>
<TR><TD ALIGN="LEFT" >+ expectThrowsAnyOf(expectedTypes: List&lt;Class&lt;? extends T&gt;&gt;, runnable: ThrowingRunnable): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ expectThrowsAnyOf(expectedOuterToWrappedTypes: LinkedHashMap&lt;Class&lt;? extends TO&gt;, List&lt;Class&lt;? extends TW&gt;&gt;&gt;, runnable: ThrowingRunnable): TO</TD></TR>
<TR><TD ALIGN="LEFT" >- getDVFields(reader: IndexReader): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># getDataInputStream(name: String): InputStream</TD></TR>
<TR><TD ALIGN="LEFT" ># getDataPath(name: String): Path</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOnlyLeafReader(reader: IndexReader): LeafReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ localeForLanguageTag(languageTag: String): Locale</TD></TR>
<TR><TD ALIGN="LEFT" >+ maybeChangeLiveIndexWriterConfig(r: Random, c: LiveIndexWriterConfig)</TD></TR>
<TR><TD ALIGN="LEFT" >+ maybeWrapReader(r: IndexReader): IndexReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAlcoholicMergePolicy(): AlcoholicMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newAlcoholicMergePolicy(r: Random, tz: TimeZone): AlcoholicMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBytesRef(s: String): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBytesRef(b: BytesRef): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBytesRef(b: byte[]): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBytesRef(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBytesRef(byteLength: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ newBytesRef(bytesIn: byte[], offset: int, length: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDirectory(): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDirectory(r: Random): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDirectory(r: Random, lf: LockFactory): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDirectory(d: Directory): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newDirectory(r: Random, d: Directory): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" ># newDirectoryImpl(random: Random, clazzName: String): Directory</TD></TR>
<TR><TD ALIGN="LEFT" ># newDirectoryImpl(random: Random, clazzName: String, lf: LockFactory): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >+ newFSDirectory(f: Path): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newFSDirectory(f: Path, lf: LockFactory): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >- newFSDirectory(f: Path, lf: LockFactory, bare: boolean): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >- newFSDirectoryImpl(clazz: Class&lt;? extends FSDirectory&gt;, path: Path, lf: LockFactory): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >+ newField(name: String, value: String, type: FieldType): Field</TD></TR>
<TR><TD ALIGN="LEFT" >+ newField(random: Random, name: String, value: Object, type: FieldType): Field</TD></TR>
<TR><TD ALIGN="LEFT" >- newFileSwitchDirectory(random: Random, dir1: Directory, dir2: Directory): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >+ newIOContext(random: Random): IOContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ newIOContext(random: Random, oldContext: IOContext): IOContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ newIndexWriterConfig(): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ newIndexWriterConfig(a: Analyzer): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ newIndexWriterConfig(r: Random, a: Analyzer): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLogMergePolicy(): LogMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLogMergePolicy(r: Random): LogMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLogMergePolicy(useCFS: boolean): MergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLogMergePolicy(useCFS: boolean, mergeFactor: int): MergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newLogMergePolicy(mergeFactor: int): MergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMaybeVirusCheckingDirectory(): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMaybeVirusCheckingFSDirectory(f: Path): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMergePolicy(r: Random): MergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMergePolicy(r: Random, includeMockMP: boolean): MergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMergePolicy(): MergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMockDirectory(): MockDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMockDirectory(r: Random): MockDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMockDirectory(r: Random, lf: LockFactory): MockDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMockFSDirectory(f: Path): MockDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newMockFSDirectory(f: Path, lf: LockFactory): MockDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSearcher(r: IndexReader): IndexSearcher</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSearcher(r: IndexReader, maybeWrap: boolean): IndexSearcher</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSearcher(r: IndexReader, maybeWrap: boolean, wrapWithAssertions: boolean): IndexSearcher</TD></TR>
<TR><TD ALIGN="LEFT" >+ newSearcher(r: IndexReader, maybeWrap: boolean, wrapWithAssertions: boolean, useThreads: boolean): IndexSearcher</TD></TR>
<TR><TD ALIGN="LEFT" >+ newStringField(name: String, value: String, stored: Store): Field</TD></TR>
<TR><TD ALIGN="LEFT" >+ newStringField(name: String, value: BytesRef, stored: Store): Field</TD></TR>
<TR><TD ALIGN="LEFT" >+ newStringField(random: Random, name: String, value: String, stored: Store): Field</TD></TR>
<TR><TD ALIGN="LEFT" >+ newStringField(random: Random, name: String, value: BytesRef, stored: Store): Field</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTextField(name: String, value: String, stored: Store): Field</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTextField(random: Random, name: String, value: String, stored: Store): Field</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTieredMergePolicy(): TieredMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTieredMergePolicy(r: Random): TieredMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ overrideDefaultQueryCache()</TD></TR>
<TR><TD ALIGN="LEFT" >+ overrideTestDefaultQueryCache()</TD></TR>
<TR><TD ALIGN="LEFT" >+ random(): Random</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomLocale(random: Random): Locale</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomTimeZone(random: Random): TimeZone</TD></TR>
<TR><TD ALIGN="LEFT" >+ rarely(random: Random): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ rarely(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ replaceMaxFailureRule(newValue: TestRuleIgnoreAfterMaxFailures): TestRuleIgnoreAfterMaxFailures</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetDefaultQueryCache()</TD></TR>
<TR><TD ALIGN="LEFT" >+ restoreCPUCoreCount()</TD></TR>
<TR><TD ALIGN="LEFT" >+ restoreIndexWriterMaxDocs()</TD></TR>
<TR><TD ALIGN="LEFT" >+ runWithRestrictedPermissions(action: PrivilegedExceptionAction&lt;T&gt;, permissions: Permission...): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ slowFileExists(dir: Directory, fileName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ tearDown()</TD></TR>
<TR><TD ALIGN="LEFT" >- uninvert(fieldName: String, reader: IndexReader): Map&lt;Integer, Set&lt;BytesRef&gt;&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ usually(random: Random): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ usually(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- wrapDirectory(random: Random, directory: Directory, bare: boolean, filesystem: boolean): BaseDirectoryWrapper</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrapReader(r: IndexReader): IndexReader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LuceneVarGapDocFreqInterval979182648[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LuceneVarGapDocFreqInterval</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   docFreqThreshold: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termIndexInterval: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

LuceneVarGapFixedInterval979182648[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)LuceneVarGapFixedInterval</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   termIndexInterval: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MappedMultiFields250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MappedMultiFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   mergeState: MergeState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MappedMultiTerms1126399149[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MappedMultiTerms</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergeState: MergeState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MappedMultiTermsEnum1126399149[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MappedMultiTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergeState: MergeState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MatchAllBits259943716[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MatchAllBits</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   len: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MatchNoBits259943716[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MatchNoBits</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   len: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MatchesTestBase1349913227[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MatchesTestBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   reader: IndexReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   searcher: IndexSearcher [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># assertIsLeafMatch(q: Query, field: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># checkFieldMatches(it: MatchesIterator, expected: int[])</TD></TR>
<TR><TD ALIGN="LEFT" ># checkLabelCount(q: Query, field: String, expected: int[])</TD></TR>
<TR><TD ALIGN="LEFT" ># checkMatches(q: Query, field: String, expected: int[][])</TD></TR>
<TR><TD ALIGN="LEFT" ># checkNoPositionsMatches(q: Query, field: String, expected: boolean[])</TD></TR>
<TR><TD ALIGN="LEFT" ># checkSubMatches(q: Query, expectedNames: String[][])</TD></TR>
<TR><TD ALIGN="LEFT" ># checkTermMatches(q: Query, field: String, expected: TermMatch[][][])</TD></TR>
<TR><TD ALIGN="LEFT" >- checkTerms(expected: TermMatch[][], it: MatchesIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >+ tearDown()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MathUtil2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MathUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ acosh(a: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ asinh(a: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ atanh(a: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ gcd(a: long, b: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ log(x: long, base: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ log(base: double, x: double): double</TD></TR>
<TR><TD ALIGN="LEFT" >+ sumRelativeErrorBound(numValues: int): double</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MaxValue2012450828[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MaxValue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedSetDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ord: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MaxValue438825503[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MaxValue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedNumericDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MemoryFields2001513788[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MemoryFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: Map&lt;String, Info&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MemoryTermsEnum2001513788[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MemoryTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   br: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   info: Info [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termUpto: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- binarySearch(b: BytesRef, bytesRef: BytesRef, low: int, high: int, hash: BytesRefHash, ords: int[]): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergeOnFlushMergePolicy1230525131[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergeOnFlushMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   smallSegmentThresholdBytes: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findFullFlushMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   maxCFSSegmentSize: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   noCFSRatio: double [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># assertDelCount(delCount: int, info: SegmentCommitInfo): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedDeletesMerges(segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedMerges(segmentInfos: SegmentInfos, maxSegmentCount: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findFullFlushMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(readers: CodecReader...): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" ># isMerged(infos: SegmentInfos, info: SegmentCommitInfo, mergeContext: MergeContext): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ keepFullyDeletedSegment(readerIOSupplier: IOSupplier&lt;CodecReader&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># maxFullFlushMergeSize(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># message(message: String, mergeContext: MergeContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDeletesToMerge(info: SegmentCommitInfo, delCount: int, readerSupplier: IOSupplier&lt;CodecReader&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" ># segString(mergeContext: MergeContext, infos: Iterable&lt;SegmentCommitInfo&gt;): String</TD></TR>
<TR><TD ALIGN="LEFT" ># size(info: SegmentCommitInfo, mergeContext: MergeContext): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ useCompoundFile(infos: SegmentInfos, mergedInfo: SegmentCommitInfo, mergeContext: MergeContext): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># verbose(mergeContext: MergeContext): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergeReader1248977512[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergeReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   codecReader: CodecReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   hardLiveDocs: Bits [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   reader: SegmentReader [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergeScheduler250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergeScheduler</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   infoStream: InfoStream [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># initialize(infoStream: InfoStream, directory: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeSource: MergeSource, trigger: MergeTrigger)</TD></TR>
<TR><TD ALIGN="LEFT" ># message(message: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># verbose(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrapForMerge(merge: OneMerge, in: Directory): Directory</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergeSpecification1248977512[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergeSpecification</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   merges: List&lt;OneMerge&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(merge: OneMerge)</TD></TR>
<TR><TD ALIGN="LEFT" ># await(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># await(timeout: long, unit: TimeUnit): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ segString(dir: Directory): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergeState250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergeState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   docMaps: DocMap[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   docValuesProducers: DocValuesProducer[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   fieldInfos: FieldInfos[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   fieldsProducers: FieldsProducer[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   knnVectorsReaders: KnnVectorsReader[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   liveDocs: Bits[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   maxDocs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   mergeFieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   needsIndexSort: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   normsProducers: NormsProducer[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   pointsReaders: PointsReader[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segmentInfo: SegmentInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   storedFieldsReaders: StoredFieldsReader[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   termVectorsReaders: TermVectorsReader[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- buildDeletionDocMaps(readers: List&lt;CodecReader&gt;): DocMap[]</TD></TR>
<TR><TD ALIGN="LEFT" >- buildDocMaps(readers: List&lt;CodecReader&gt;, indexSort: Sort): DocMap[]</TD></TR>
<TR><TD ALIGN="LEFT" ># removeDeletes(maxDoc: int, liveDocs: Bits): PackedLongValues</TD></TR>
<TR><TD ALIGN="LEFT" >- verifyIndexSort(readers: List&lt;CodecReader&gt;, segmentInfo: SegmentInfo)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergeThread320686676[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergeThread</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   merge: OneMerge [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergeSource: MergeSource [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   rateLimiter: MergeRateLimiter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(other: MergeThread): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ run()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergedDocValues957810353[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergedDocValues&lt;DocValuesInstance extends DocValuesIterator&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   currentValuesSupplier: DocValuesInstance [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docIDOnDisk: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docIDOut: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   onDiskDocValues: DocValuesInstance [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   updateDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   updateDocValues: DocValuesInstance [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   updateIterator: Iterator [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MergedTermsEnum1257536853[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MergedTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ord: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ordinalMap: OrdinalMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subs: TermsEnum[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   term: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valueCount: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ attributes(): AttributeSource</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Merges104941043[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Merges</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   mergesEnabled: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># areEnabled(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># disable()</TD></TR>
<TR><TD ALIGN="LEFT" ># enable()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Meta1170552560[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Meta</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   avgs: float[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bpvs: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mins: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numBlocks: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   offsets: long[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MiddleMaxValue2012450828[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MiddleMaxValue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedSetDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ord: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MiddleMinValue2012450828[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MiddleMinValue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedSetDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ord: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MinMaxTracker1727860355[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MinMaxTracker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   max: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   min: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numValues: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   spaceInBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># finish()</TD></TR>
<TR><TD ALIGN="LEFT" ># nextBlock()</TD></TR>
<TR><TD ALIGN="LEFT" >- reset()</TD></TR>
<TR><TD ALIGN="LEFT" ># update(v: long)</TD></TR>
<TR><TD ALIGN="LEFT" ># update(other: MinMaxTracker)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MinMaxTracker405642323[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MinMaxTracker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   max: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   min: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numValues: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   spaceInBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># finish()</TD></TR>
<TR><TD ALIGN="LEFT" ># nextBlock()</TD></TR>
<TR><TD ALIGN="LEFT" >- reset()</TD></TR>
<TR><TD ALIGN="LEFT" ># update(v: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MinMaxTracker693566093[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MinMaxTracker</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   max: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   min: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numValues: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   spaceInBits: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># finish()</TD></TR>
<TR><TD ALIGN="LEFT" ># nextBlock()</TD></TR>
<TR><TD ALIGN="LEFT" >- reset()</TD></TR>
<TR><TD ALIGN="LEFT" ># update(v: long)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MinValue2012450828[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MinValue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedSetDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ord: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MinValue438825503[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MinValue</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   in: SortedNumericDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MockFileSystemTestCase1344450007[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MockFileSystemTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- implTestURI(fileName: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDirectoryStreamFiltered()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testDirectoryStreamGlobFiltered()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testHashCodeEquals()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testURI()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testURIchinese()</TD></TR>
<TR><TD ALIGN="LEFT" >+ testURIumlaute()</TD></TR>
<TR><TD ALIGN="LEFT" ># wrap(path: Path): Path</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MockIndexWriterEventListener450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MockIndexWriterEventListener</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   beginMergeCalled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   endMergeCalled: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ beginMergeOnFullFlush(merge: MergeSpecification)</TD></TR>
<TR><TD ALIGN="LEFT" >+ endMergeOnFullFlush(merge: MergeSpecification)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MockMergeContext372938628[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MockMergeContext</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergingSegments: Set&lt;SegmentCommitInfo&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDeletesFunc: ToIntFunction&lt;SegmentCommitInfo&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ numDeletedDocs(info: SegmentCommitInfo): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDeletesToMerge(info: SegmentCommitInfo): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MockRandomMergePolicy450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MockRandomMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   doNonBulkMerges: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   random: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findForcedDeletesMerges(segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedMerges(segmentInfos: SegmentInfos, maxSegmentCount: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findFullFlushMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ useCompoundFile(infos: SegmentInfos, mergedInfo: SegmentCommitInfo, mergeContext: MergeContext): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MockRandomOneMerge1417707806[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MockRandomOneMerge</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   r: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ wrapForMerge(reader: CodecReader): CodecReader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MockRandomPostingsFormat718940805[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MockRandomPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   seedRandom: Random [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MonotonicBlockPackedReader611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MonotonicBlockPackedReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   averages: float[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   minValues: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   subReaders: LongValues[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sumBPV: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   totalByteCount: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   valueCount: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># expected(origin: long, average: float, index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ of(in: IndexInput, packedIntsVersion: int, blockSize: int, valueCount: long): MonotonicBlockPackedReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiBits250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiBits</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   defaultValue: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   starts: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subs: Bits[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- checkLength(reader: int, doc: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(doc: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLiveDocs(reader: IndexReader): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiFieldNormValues692532526[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiFieldNormValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   current: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsArr: NumericDocValues[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   weightArr: float[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiFields250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   subSlices: ReaderSlice[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subs: Fields[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   terms: Map&lt;String, Terms&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiSortedDocValues267023757[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiSortedDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentDocStart: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentValues: SortedDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   docStarts: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   mapping: OrdinalMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextLeaf: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalCost: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   values: SortedDocValues[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(targetDocID: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(targetDocID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiSortedSetDocValues267023757[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiSortedSetDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentDocStart: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentValues: SortedSetDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   docStarts: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   mapping: OrdinalMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextLeaf: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalCost: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   values: SortedSetDocValues[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(targetDocID: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(targetDocID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextOrd(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MultiTermsEnum250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MultiTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   current: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentSubs: TermsEnumWithSlice[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSeek: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSeekExact: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastSeekScratch: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numSubs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numTop: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queue: TermMergeQueue [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subDocs: EnumWithSlice[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subs: TermsEnumWithSlice[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   top: TermsEnumWithSlice[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- pullTop()</TD></TR>
<TR><TD ALIGN="LEFT" >- pushTop()</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset(termsEnumsIndex: TermsEnumIndex[]): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(term: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MutablePointTree985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MutablePointTree</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): PointTree</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteAt(i: int, k: int): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocID(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getValue(i: int, packedValue: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToChild(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToParent(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToSibling(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ restore(i: int, j: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ save(i: int, j: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ swap(i: int, j: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocIDs(visitor: IntersectVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

MutableSortingPointValues978767219[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)MutableSortingPointValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docMap: DocMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: MutablePointTree [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getByteAt(i: int, k: int): byte</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocID(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getValue(i: int, packedValue: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ restore(i: int, j: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ save(i: int, j: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ swap(i: int, j: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocValues(visitor: IntersectVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NRTCachingDirectory260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NRTCachingDirectory</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cacheDirectory: ByteBuffersDirectory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheSize: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   closed: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxCachedBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMergeSizeBytes: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ createOutput(name: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempOutput(prefix: String, suffix: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFile(name: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># doCacheWrite(name: String, context: IOContext): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ fileLength(name: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ listAll(): String[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ listCachedFiles(): String[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ openInput(name: String, context: IOContext): IndexInput</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ rename(source: String, dest: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># slowFileExists(dir: Directory, fileName: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ sync(fileNames: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- unCache(fileName: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NRTSuggester1319730795[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NRTSuggester</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fst: FST&lt;Pair&lt;Long, BytesRef&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxAnalyzedPathsPerOutput: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadSep: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- calculateLiveDocRatio(numDocs: int, maxDocs: int): double</TD></TR>
<TR><TD ALIGN="LEFT" ># decode(output: long): long</TD></TR>
<TR><TD ALIGN="LEFT" ># encode(input: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getMaxTopNSearcherQueueSize(topN: int, numDocs: int, liveDocsRatio: double, filterEnabled: boolean): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(input: IndexInput, fstLoadMode: FSTLoadMode): NRTSuggester</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(scorer: CompletionScorer, acceptDocs: Bits, collector: TopSuggestDocsCollector)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldLoadFSTOffHeap(input: IndexInput, fstLoadMode: FSTLoadMode): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NamedSPILoader2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NamedSPILoader&lt;S extends NamedSPILoader.NamedSPI&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   clazz: Class&lt;S&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   services: Map&lt;String, S&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ availableServices(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkServiceName(name: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- isLetterOrDigit(c: char): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;S&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(name: String): S</TD></TR>
<TR><TD ALIGN="LEFT" >+ reload(classloader: ClassLoader)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NoMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NoMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findForcedDeletesMerges(segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedMerges(segmentInfos: SegmentInfos, maxSegmentCount: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findFullFlushMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(readers: CodecReader...): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ keepFullyDeletedSegment(readerIOSupplier: IOSupplier&lt;CodecReader&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDeletesToMerge(info: SegmentCommitInfo, delCount: int, readerSupplier: IOSupplier&lt;CodecReader&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" ># size(info: SegmentCommitInfo, context: MergeContext): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ useCompoundFile(segments: SegmentInfos, newSegment: SegmentCommitInfo, mergeContext: MergeContext): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NoOutput890247972[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NoOutput</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ isEnabled(component: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ message(component: String, message: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NormsFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NormsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ normsConsumer(state: SegmentWriteState): NormsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsProducer(state: SegmentReadState): NormsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NormsProducer985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NormsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNorms(field: FieldInfo): NumericDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NotDocIdSet2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NotDocIdSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: DocIdSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bits(): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NullInfoStream1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NullInfoStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ isEnabled(component: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ message(component: String, message: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NullReader126344284[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NullReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   valueCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int, arr: long[], off: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NumDV941996959[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NumDV</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   iter: ToParentDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   selection: Type [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   value: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: NumericDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(targetParentDocID: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(targetParentDocID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ increment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

NumericDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)NumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OffHeapFSTStore146897711[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OffHeapFSTStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offset: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ init(in: DataInput, numBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(out: DataOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OnHeapFSTStore146897711[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OnHeapFSTStore</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytes: BytesStore [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesArray: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxBlockBits: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ init(in: DataInput, numBytes: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTo(out: DataOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OnHeapHnswGraph258806880[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OnHeapHnswGraph</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cur: NeighborArray [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   entryNode: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   graphLevel0: List&lt;NeighborArray&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   graphUpperLevels: List&lt;TreeMap&lt;Integer, NeighborArray&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nsize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nsize0: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numLevels: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   upto: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addNode(level: int, node: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ entryNode(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNeighbors(level: int, node: int): NeighborArray</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNodesOnLevel(level: int): NodesIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextNeighbor(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ numLevels(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ seek(level: int, targetNode: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OneMerge1248977512[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OneMerge</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   error: Throwable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   estimatedMergeBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   info: SegmentCommitInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   isExternal: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxNumSegments: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeCompleted: CompletableFuture&lt;Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergeGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeProgress: OneMergeProgress [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergeReaders: List&lt;MergeReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergeStartNS: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   registerDone: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segments: List&lt;SegmentCommitInfo&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   totalMaxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   totalMergeBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   usesPooledReaders: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># await(timeout: long, timeUnit: TimeUnit): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkAborted()</TD></TR>
<TR><TD ALIGN="LEFT" ># close(success: boolean, segmentDropped: boolean, readerConsumer: IOConsumer&lt;MergeReader&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># initMergeReaders(readerFactory: IOFunction&lt;SegmentCommitInfo, MergeReader&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFinished(success: boolean, segmentDropped: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeInit()</TD></TR>
<TR><TD ALIGN="LEFT" ># onMergeComplete()</TD></TR>
<TR><TD ALIGN="LEFT" >+ segString(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalBytesSize(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalNumDocs(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ wrapForMerge(reader: CodecReader): CodecReader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OneMergeWrappingMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OneMergeWrappingMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   wrapOneMerge: UnaryOperator&lt;OneMerge&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findForcedDeletesMerges(segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedMerges(segmentInfos: SegmentInfos, maxSegmentCount: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findFullFlushMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >- wrapSpec(spec: MergeSpecification): MergeSpecification</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Options1334058346[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Options</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   config: IndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexPaths: String[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxSegments: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergedIndexPath: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># parse(args: String[]): Options</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OrdinalMap250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OrdinalMap</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   firstSegments: LongValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   globalOrdDeltas: LongValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   owner: CacheKey [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segmentMap: SegmentMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segmentToGlobalOrds: LongValues[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   valueCount: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(owner: CacheKey, values: SortedDocValues[], acceptableOverheadRatio: float): OrdinalMap</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(owner: CacheKey, values: SortedSetDocValues[], acceptableOverheadRatio: float): OrdinalMap</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(owner: CacheKey, subs: TermsEnum[], weights: long[], acceptableOverheadRatio: float): OrdinalMap</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFirstSegmentNumber(globalOrd: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFirstSegmentOrd(globalOrd: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getGlobalOrds(segmentIndex: int): LongValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OrdinalMappingBinaryDocValues1344004654[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OrdinalMappingBinaryDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   ordinals: IntsRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ordsReader: OrdinalsSegmentReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ binaryValue(): BytesRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OrdsBlockTreeTermsReader679407426[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OrdsBlockTreeTermsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: TreeMap&lt;String, OrdsFieldReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsReader: PostingsReaderBase [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># brToString(b: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readBytesRef(in: IndexInput): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >- seekDir(input: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OrdsIntersectTermsEnum679407426[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OrdsIntersectTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   arcs: Arc&lt;Output&gt;[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   compiledAutomaton: CompiledAutomaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentFrame: OrdsIntersectTermsEnumFrame [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fr: OrdsFieldReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstReader: BytesReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   runAutomaton: RunAutomaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   savedStartTerm: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stack: OrdsIntersectTermsEnumFrame[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   term: BytesRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- copyTerm()</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getArc(ord: int): Arc&lt;Output&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getFrame(ord: int): OrdsIntersectTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- pushFrame(state: int): OrdsIntersectTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- seekToStartTerm(target: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >- setSavedStartTerm(startTerm: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

OrdsSegmentTermsEnum679407426[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)OrdsSegmentTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   arc: Arc&lt;Output&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   arcs: Arc&lt;Output&gt;[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentFrame: OrdsSegmentTermsEnumFrame [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eof: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fr: OrdsFieldReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstReader: BytesReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   positioned: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchReader: ByteArrayDataInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stack: OrdsSegmentTermsEnumFrame[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   staticFrame: OrdsSegmentTermsEnumFrame [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   targetBeforeCurrentLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   term: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termExists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   validIndexPrefix: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># brToString(b: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >- clearEOF(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getArc(ord: int): Arc&lt;Output&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getByOutput(targetOrd: long): InputOutput</TD></TR>
<TR><TD ALIGN="LEFT" >- getFrame(ord: int): OrdsSegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" ># initIndexInput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- printSeekState(out: PrintStream)</TD></TR>
<TR><TD ALIGN="LEFT" ># pushFrame(arc: Arc&lt;Output&gt;, frameData: Output, length: int): OrdsSegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" ># pushFrame(arc: Arc&lt;Output&gt;, fp: long, length: int, termOrd: long): OrdsSegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(target: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(target: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(target: BytesRef, otherState: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(targetOrd: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- setEOF(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PKIndexSplitter1397736262[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PKIndexSplitter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   config1: IndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config2: IndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dir1: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dir2: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docsInFirstIndex: Query [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   input: Directory [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- createIndex(config: IndexWriterConfig, target: Directory, reader: DirectoryReader, preserveFilter: Query, negateFilter: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- newDefaultConfig(): IndexWriterConfig</TD></TR>
<TR><TD ALIGN="LEFT" >+ split()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Packed64611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Packed64</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blocks: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bpvMinusBlockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maskRight: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ fill(fromIndex: int, toIndex: int, val: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- gcd(a: int, b: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int, arr: long[], off: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ set(index: int, arr: long[], off: int, len: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Packed64SingleBlock611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Packed64SingleBlock</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blocks: long[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ create(valueCount: int, bitsPerValue: int): Packed64SingleBlock</TD></TR>
<TR><TD ALIGN="LEFT" >+ fill(fromIndex: int, toIndex: int, val: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int, arr: long[], off: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ isSupported(bitsPerValue: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- requiredCapacity(valueCount: int, valuesPerBlock: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ set(index: int, arr: long[], off: int, len: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PackedLongValues611233966[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PackedLongValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   pageMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pageShift: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   size: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   values: Reader[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># decodeBlock(block: int, dest: long[]): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ deltaPackedBuilder(pageSize: int, acceptableOverheadRatio: float): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ deltaPackedBuilder(acceptableOverheadRatio: float): Builder</TD></TR>
<TR><TD ALIGN="LEFT" ># get(block: int, element: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ monotonicBuilder(pageSize: int, acceptableOverheadRatio: float): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ monotonicBuilder(acceptableOverheadRatio: float): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ packedBuilder(pageSize: int, acceptableOverheadRatio: float): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ packedBuilder(acceptableOverheadRatio: float): Builder</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PagedBytes2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PagedBytes</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   blockBits: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockMask: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blockSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   blocks: byte[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesUsedPerBlock: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   currentBlock: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   didSkipBytes: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   frozen: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numBlocks: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   upto: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addBlock(block: byte[])</TD></TR>
<TR><TD ALIGN="LEFT" >+ copy(in: IndexInput, byteCount: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copy(bytes: BytesRef, out: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyUsingLengthPrefix(bytes: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ freeze(trim: boolean): Reader</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ParallelFields156833114[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ParallelFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fields: Map&lt;String, Terms&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addField(fieldName: String, terms: Terms)</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PendingDeletes250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PendingDeletes</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   info: SegmentCommitInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocs: Bits [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   liveDocsInitialized: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingDeleteCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeableLiveDocs: FixedBitSet [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- assertCheckLiveDocs(bits: Bits, expectedLength: int, expectedDeleteCount: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># delete(docID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># dropChanges()</TD></TR>
<TR><TD ALIGN="LEFT" ># isFullyDeleted(readerIOSupplier: IOSupplier&lt;CodecReader&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># mustInitOnDelete(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># needsRefresh(reader: CodecReader): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># numDeletesToMerge(policy: MergePolicy, readerIOSupplier: IOSupplier&lt;CodecReader&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" ># numDocs(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># numPendingDeletes(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># onDocValuesUpdate(info: FieldInfo, iterator: Iterator)</TD></TR>
<TR><TD ALIGN="LEFT" ># onNewReader(reader: CodecReader, info: SegmentCommitInfo)</TD></TR>
<TR><TD ALIGN="LEFT" ># verifyDocCounts(reader: CodecReader): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># writeLiveDocs(dir: Directory): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PendingSoftDeletes250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PendingSoftDeletes</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dvGeneration: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hardDeletes: PendingDeletes [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># applySoftDeletes(iterator: DocIdSetIterator, bits: FixedBitSet): int</TD></TR>
<TR><TD ALIGN="LEFT" >- assertPendingDeletes(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># countSoftDeletes(softDeletedDocs: DocIdSetIterator, hardDeletes: Bits): int</TD></TR>
<TR><TD ALIGN="LEFT" ># delete(docID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># dropChanges()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureInitialized(readerIOSupplier: IOSupplier&lt;CodecReader&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># isFullyDeleted(readerIOSupplier: IOSupplier&lt;CodecReader&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># mustInitOnDelete(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># numDeletesToMerge(policy: MergePolicy, readerIOSupplier: IOSupplier&lt;CodecReader&gt;): int</TD></TR>
<TR><TD ALIGN="LEFT" ># numPendingDeletes(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># onDocValuesUpdate(info: FieldInfo, iterator: Iterator)</TD></TR>
<TR><TD ALIGN="LEFT" ># onNewReader(reader: CodecReader, info: SegmentCommitInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >- readFieldInfos(): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" ># writeLiveDocs(dir: Directory): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PerFieldDocValuesFormat1541985928[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PerFieldDocValuesFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): DocValuesProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(field: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" ># getFullSegmentSuffix(outerSegmentSuffix: String, segmentSuffix: String): String</TD></TR>
<TR><TD ALIGN="LEFT" ># getSuffix(formatName: String, suffix: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PerFieldKnnVectorsFormat1541985928[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PerFieldKnnVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
<TR><TD ALIGN="LEFT" ># getFullSegmentSuffix(outerSegmentSuffix: String, segmentSuffix: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getKnnVectorsFormatForField(field: String): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" ># getSuffix(formatName: String, suffix: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PerFieldMergeState1541985928[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PerFieldMergeState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: MergeState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   orgFieldInfos: FieldInfos[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   orgFieldsProducers: FieldsProducer[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   orgMergeFieldInfos: FieldInfos [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># apply(fields: Collection&lt;String&gt;): MergeState</TD></TR>
<TR><TD ALIGN="LEFT" ># reset(): MergeState</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PerFieldPostingsFormat1541985928[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PerFieldPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" ># getFullSegmentSuffix(fieldName: String, outerSegmentSuffix: String, segmentSuffix: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(field: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" ># getSuffix(formatName: String, suffix: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PointInGeo3DShapeQuery1841925665[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PointInGeo3DShapeQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   shape: GeoShape [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   shapeBounds: XYZBounds [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsTo(other: PointInGeo3DShapeQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PointInSetIncludingScoreQuery1521700474[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PointInSetIncludingScoreQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   aggregatedJoinScores: List&lt;Float&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bytesPerDim: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   multipleValuesPerDocument: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   originalQuery: Query [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scoreMode: ScoreMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedPackedPoints: PrefixCodedTerms [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedPackedPointsHashCode: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsTo(other: PointInSetIncludingScoreQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PointInSetQuery536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PointInSetQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bytesPerDim: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numDims: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedPackedPoints: PrefixCodedTerms [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedPackedPointsHashCode: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsTo(other: PointInSetQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PointsFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PointsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): PointsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): PointsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PointsReader985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PointsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getValues(field: String): PointValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PointsWriter985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PointsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" ># mergeOneField(mergeState: MergeState, fieldInfo: FieldInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(fieldInfo: FieldInfo, values: PointsReader)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PostingsFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ availablePostingsFormats(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ forName(name: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ reloadPostingsFormats(classloader: ClassLoader)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PostingsReaderBase985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PostingsReaderBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ decodeTerm(in: DataInput, fieldInfo: FieldInfo, state: BlockTermState, absolute: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(fieldInfo: FieldInfo, state: BlockTermState, flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ init(termsIn: IndexInput, state: SegmentReadState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ newTermState(): BlockTermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(fieldInfo: FieldInfo, state: BlockTermState, reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PostingsWriterBase985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PostingsWriterBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ encodeTerm(out: DataOutput, fieldInfo: FieldInfo, state: BlockTermState, absolute: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ init(termsOut: IndexOutput, state: SegmentWriteState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeTerm(term: BytesRef, termsEnum: TermsEnum, docsSeen: FixedBitSet, norms: NormsProducer): BlockTermState</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PreCopyMergedSegmentWarmer1813495465[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PreCopyMergedSegmentWarmer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   primary: PrimaryNode [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ warm(reader: LeafReader)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PrefixCodedTerms250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PrefixCodedTerms</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   content: List&lt;ByteBuffer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lazyHash: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   size: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): TermIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PrimaryNode1813495465[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PrimaryNode</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   copyState: CopyState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   copyingCount: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   curInfos: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   finishedMergedFiles: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   primaryGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   remoteCloseTimeoutMs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writer: IndexWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit()</TD></TR>
<TR><TD ALIGN="LEFT" >- ensureOpen(allowClosing: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ flushAndRefresh(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># isClosed(allowClosing: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># preCopyMergedSegmentFiles(info: SegmentCommitInfo, files: Map&lt;String, FileMetaData&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ releaseCopyState(copyState: CopyState)</TD></TR>
<TR><TD ALIGN="LEFT" >- setCurrentInfos(completedMergeFiles: Set&lt;String&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- waitForAllRemotesToClose()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

PrintStreamInfoStream2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)PrintStreamInfoStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   messageID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   stream: PrintStream [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ isEnabled(component: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ message(component: String, message: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Provider575826809[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Provider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ readSortField(in: DataInput): SortField</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeSortField(sf: SortField, out: DataOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RAMDoc402540384[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RAMDoc</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   payloads: byte[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   positions: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RAMFieldsConsumer402540384[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RAMFieldsConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   postings: RAMPostings [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: SegmentWriteState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termsConsumer: RAMTermsConsumer [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fields: Fields, norms: NormsProducer)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RAMOnlyPostingsFormat1504362276[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RAMOnlyPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   RAM_ONLY_NAME: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextID: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   state: Map&lt;Integer, RAMPostings&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(writeState: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(readState: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RAMPostings402540384[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RAMPostings</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fieldToTerms: Map&lt;String, RAMField&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RAMTermsEnum402540384[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RAMTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   current: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   it: Iterator&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramField: RAMField [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(term: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RandomCodec450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RandomCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   avoidCodecs: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bkdSplitRandomSeed: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   dvFormatNames: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dvFormats: List&lt;DocValuesFormat&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   formatNames: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   formats: List&lt;PostingsFormat&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMBSortInHeap: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPointsInLeafNode: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   perFieldSeed: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   previousDVMappings: Map&lt;String, DocValuesFormat&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   previousMappings: Map&lt;String, PostingsFormat&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- add(avoidCodecs: Set&lt;String&gt;, postings: PostingsFormat...)</TD></TR>
<TR><TD ALIGN="LEFT" >- addDocValues(avoidCodecs: Set&lt;String&gt;, docvalues: DocValuesFormat...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormatForField(name: String): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatForField(name: String): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RandomIndexWriter450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RandomIndexWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   analyzer: Analyzer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   config: LiveIndexWriterConfig [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   doRandomForceMerge: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   doRandomForceMergeAssert: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   flushAt: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   flushAtFactor: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   getReaderCalled: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   r: Random [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   softDeletesRatio: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   w: IndexWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addDocument(doc: Iterable&lt;T&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ addDocuments(docs: Iterable&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexes(dirs: Directory...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ addIndexes(readers: CodecReader...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit(flushConcurrently: boolean): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteAll(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteDocuments(term: Term): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteDocuments(q: Query): long</TD></TR>
<TR><TD ALIGN="LEFT" >- doRandomForceMerge()</TD></TR>
<TR><TD ALIGN="LEFT" >+ flush()</TD></TR>
<TR><TD ALIGN="LEFT" >- flushAllBuffersSequentially()</TD></TR>
<TR><TD ALIGN="LEFT" >+ forceMerge(maxSegmentCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forceMergeDeletes(doWait: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ forceMergeDeletes()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReader(applyDeletions: boolean, writeAllDeletes: boolean): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" >- maybeFlushOrCommit()</TD></TR>
<TR><TD ALIGN="LEFT" >+ mockIndexWriter(dir: Directory, conf: IndexWriterConfig, r: Random): IndexWriter</TD></TR>
<TR><TD ALIGN="LEFT" >+ mockIndexWriter(r: Random, dir: Directory, conf: IndexWriterConfig, testPoint: TestPoint): IndexWriter</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateBinaryDocValue(term: Term, field: String, value: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDocValues(term: Term, updates: Field...): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDocument(t: Term, doc: Iterable&lt;T&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateDocuments(delTerm: Term, docs: Iterable&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateNumericDocValue(term: Term, field: String, value: Long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- useSoftDeletes(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Reader126344284[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Reader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int, arr: long[], off: int, len: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReaderPool250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReaderPool</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   closed: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   completedDelGenSupplier: LongSupplier [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldNumbers: FieldNumbers [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalDirectory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   poolReaders: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readerMap: Map&lt;SegmentCommitInfo, ReadersAndUpdates&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfos: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   softDeletesField: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># anyDeletions(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># anyDocValuesChanges(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># assertInfoIsLive(info: SegmentCommitInfo): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># commit(infos: SegmentInfos): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># drop(info: SegmentCommitInfo): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># dropAll()</TD></TR>
<TR><TD ALIGN="LEFT" ># enableReaderPooling()</TD></TR>
<TR><TD ALIGN="LEFT" ># get(info: SegmentCommitInfo, create: boolean): ReadersAndUpdates</TD></TR>
<TR><TD ALIGN="LEFT" >- newPendingDeletes(info: SegmentCommitInfo): PendingDeletes</TD></TR>
<TR><TD ALIGN="LEFT" >- newPendingDeletes(reader: SegmentReader, info: SegmentCommitInfo): PendingDeletes</TD></TR>
<TR><TD ALIGN="LEFT" >- noDups(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># release(rld: ReadersAndUpdates, assertInfoLive: boolean): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># writeAllDocValuesUpdates(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># writeDocValuesUpdatesForMerge(infos: List&lt;SegmentCommitInfo&gt;): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReaderUtil250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReaderUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getTopLevelContext(context: IndexReaderContext): IndexReaderContext</TD></TR>
<TR><TD ALIGN="LEFT" >+ subIndex(n: int, docStarts: int[]): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ subIndex(n: int, leaves: List&lt;LeafReaderContext&gt;): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ReadersAndUpdates250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ReadersAndUpdates</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   indexCreatedVersionMajor: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   info: SegmentCommitInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isMerging: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   mergingDVUpdates: Map&lt;String, List&lt;DocValuesFieldUpdates&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingDVUpdates: Map&lt;String, List&lt;DocValuesFieldUpdates&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pendingDeletes: PendingDeletes [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ramBytesUsed: AtomicLong [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: SegmentReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   refCount: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortMap: DocMap [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addDVUpdate(update: DocValuesFieldUpdates)</TD></TR>
<TR><TD ALIGN="LEFT" >- assertNoDupGen(fieldUpdates: List&lt;DocValuesFieldUpdates&gt;, update: DocValuesFieldUpdates): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- cloneFieldInfo(fi: FieldInfo, fieldNumber: int): FieldInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- createNewReaderWithLatestLiveDocs(reader: SegmentReader): SegmentReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ decRef()</TD></TR>
<TR><TD ALIGN="LEFT" >+ delete(docID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ dropChanges()</TD></TR>
<TR><TD ALIGN="LEFT" >+ dropMergingUpdates()</TD></TR>
<TR><TD ALIGN="LEFT" >+ dropReaders()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReadOnlyClone(context: IOContext): SegmentReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ getReader(context: IOContext): SegmentReader</TD></TR>
<TR><TD ALIGN="LEFT" ># getReaderForMerge(context: IOContext): MergeReader</TD></TR>
<TR><TD ALIGN="LEFT" >- handleDVUpdates(infos: FieldInfos, dir: Directory, dvFormat: DocValuesFormat, reader: SegmentReader, fieldFiles: Map&lt;Integer, Set&lt;String&gt;&gt;, maxDelGen: long, infoStream: InfoStream)</TD></TR>
<TR><TD ALIGN="LEFT" >+ incRef()</TD></TR>
<TR><TD ALIGN="LEFT" ># keepFullyDeletedSegment(mergePolicy: MergePolicy): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># numDeletesToMerge(policy: MergePolicy): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ refCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ release(sr: SegmentReader)</TD></TR>
<TR><TD ALIGN="LEFT" >- swapNewReaderWithLatestLiveDocs()</TD></TR>
<TR><TD ALIGN="LEFT" >- writeFieldInfosGen(fieldInfos: FieldInfos, dir: Directory, infosFormat: FieldInfosFormat): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeFieldUpdates(dir: Directory, fieldNumbers: FieldNumbers, maxDelGen: long, infoStream: InfoStream): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLiveDocs(dir: Directory): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RoaringDocIdSet2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RoaringDocIdSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cardinality: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docIdSets: DocIdSet[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ cardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

RunAutomaton1522148614[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RunAutomaton</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   accept: FixedBitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   alphabetSize: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   automaton: Automaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   classmap: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   points: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   size: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   transitions: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># getCharClass(c: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ isAccept(state: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ step(state: int, c: int): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

STMergingTermsEnum1748595275[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)STMergingTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fieldName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   multiPostingsEnum: MultiSegmentsPostingsEnum [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   term: BytesRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ attributes(): AttributeSource</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" ># reset(term: BytesRef, segmentPostings: List&lt;SegmentPostings&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

STUniformSplitPostingsFormat1748595275[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)STUniformSplitPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># createUniformSplitTermsReader(postingsReader: PostingsReaderBase, state: SegmentReadState, blockDecoder: BlockDecoder): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" ># createUniformSplitTermsWriter(postingsWriter: PostingsWriterBase, state: SegmentWriteState, targetNumBlockLines: int, deltaNumLines: int, blockEncoder: BlockEncoder): FieldsConsumer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

STUniformSplitRot13PostingsFormat1389498984[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)STUniformSplitRot13PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># createFieldsConsumer(segmentWriteState: SegmentWriteState, postingsWriter: PostingsWriterBase): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" ># createFieldsProducer(segmentReadState: SegmentReadState, postingsReader: PostingsReaderBase): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SearchEquivalenceTestBase1349913227[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SearchEquivalenceTestBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ afterClass()</TD></TR>
<TR><TD ALIGN="LEFT" ># assertSameScores(q1: Query, q2: Query)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertSameScores(q1: Query, q2: Query, filter: Query)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertSameSet(q1: Query, q2: Query)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertSubsetOf(q1: Query, q2: Query)</TD></TR>
<TR><TD ALIGN="LEFT" ># assertSubsetOf(q1: Query, q2: Query, filter: Query)</TD></TR>
<TR><TD ALIGN="LEFT" >+ beforeClass()</TD></TR>
<TR><TD ALIGN="LEFT" ># filteredQuery(query: Query, filter: Query): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># randomChar(): char</TD></TR>
<TR><TD ALIGN="LEFT" ># randomFieldContents(): String</TD></TR>
<TR><TD ALIGN="LEFT" ># randomFilter(): Query</TD></TR>
<TR><TD ALIGN="LEFT" ># randomTerm(): Term</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SeedFields1550953042[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SeedFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   allowPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fields: Map&lt;String, SortedMap&lt;BytesRef, SeedAndOrd&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxAllowed: IndexOptions [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SeedTermsEnum1550953042[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SeedTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   allowPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   current: Entry&lt;BytesRef, SeedAndOrd&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   iterator: Iterator&lt;Entry&lt;BytesRef, SeedAndOrd&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxAllowed: IndexOptions [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   terms: SortedMap&lt;BytesRef, SeedAndOrd&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" ># reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentCommitInfo250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentCommitInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bufferedDeletesGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   delGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docValuesGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dvUpdatesFiles: Map&lt;Integer, Set&lt;String&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFiles: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   id: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >+   info: SegmentInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextWriteDelGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextWriteDocValuesGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextWriteFieldInfosGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sizeInBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   softDelCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># advanceDelGen()</TD></TR>
<TR><TD ALIGN="LEFT" ># advanceDocValuesGen()</TD></TR>
<TR><TD ALIGN="LEFT" ># advanceFieldInfosGen()</TD></TR>
<TR><TD ALIGN="LEFT" ># advanceNextWriteDelGen()</TD></TR>
<TR><TD ALIGN="LEFT" ># advanceNextWriteDocValuesGen()</TD></TR>
<TR><TD ALIGN="LEFT" ># advanceNextWriteFieldInfosGen()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): SegmentCommitInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ files(): Collection&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- generationAdvanced()</TD></TR>
<TR><TD ALIGN="LEFT" ># getDelCount(includeSoftDeletes: boolean): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ sizeInBytes(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentCoreReaders250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentCoreReaders</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cacheHelper: CacheHelper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   cfsReader: CompoundDirectory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   coreClosedListeners: Set&lt;ClosedListener&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   coreFieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fields: FieldsProducer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldsReaderLocal: CloseableThreadLocal&lt;StoredFieldsReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldsReaderOrig: StoredFieldsReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   knnVectorsReader: KnnVectorsReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   normsProducer: NormsProducer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pointsReader: PointsReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ref: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segment: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termVectorsLocal: CloseableThreadLocal&lt;TermVectorsReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termVectorsReaderOrig: TermVectorsReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># decRef()</TD></TR>
<TR><TD ALIGN="LEFT" ># incRef()</TD></TR>
<TR><TD ALIGN="LEFT" >- notifyCoreClosedListeners()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   genDVProducers: Map&lt;Long, RefCount&lt;DocValuesProducer&gt;&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># decRef(dvProducersGens: List&lt;Long&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># getDocValuesProducer(gen: long, si: SegmentCommitInfo, dir: Directory, infos: FieldInfos): DocValuesProducer</TD></TR>
<TR><TD ALIGN="LEFT" >- newDocValuesProducer(si: SegmentCommitInfo, dir: Directory, gen: Long, infos: FieldInfos): RefCount&lt;DocValuesProducer&gt;</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentDocValuesProducer250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentDocValuesProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dvGens: List&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dvProducers: Set&lt;DocValuesProducer&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dvProducersByField: Map&lt;String, DocValuesProducer&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(field: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(field: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(field: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(field: FieldInfo): SortedSetDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentInfo250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentInfo</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   attributes: Map&lt;String, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   diagnostics: Map&lt;String, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   dir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   id: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexSort: Sort [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   isCompoundFile: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   minVersion: Version [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   setFiles: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   version: Version [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addDiagnostics(diagnostics: Map&lt;String, String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addFile(file: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addFiles(files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkFileNames(files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ files(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAttribute(key: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># namedForThisSegment(file: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ putAttribute(key: String, value: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentInfoAndLevel1773705000[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentInfoAndLevel</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   info: SegmentCommitInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   level: float [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compareTo(other: SegmentInfoAndLevel): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentInfoFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentInfoFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentName: String, segmentID: byte[], context: IOContext): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, info: SegmentInfo, ioContext: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentInfoStatus706454884[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentInfoStatus</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   compound: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   deletionsGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   diagnostics: Map&lt;String, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   docValuesStatus: DocValuesStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   error: Throwable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   fieldInfoStatus: FieldInfoStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   fieldNormStatus: FieldNormStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   hasDeletions: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   indexSortStatus: IndexSortStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   liveDocStatus: LiveDocStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   numFiles: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   openReaderPassed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   pointsStatus: PointsStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   sizeMB: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   softDeletesStatus: SoftDeletsStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   storedFieldStatus: StoredFieldStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   termIndexStatus: TermIndexStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   termVectorStatus: TermVectorStatus [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   toLoseDocCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   vectorValuesStatus: VectorValuesStatus [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentInfos250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentInfos</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   counter: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   generation: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   id: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexCreatedVersionMajor: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastGeneration: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   luceneVersion: Version [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minSegmentLuceneVersion: Version [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   pendingCommit: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segments: List&lt;SegmentCommitInfo&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   userData: Map&lt;String, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   version: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(si: SegmentCommitInfo)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addAll(sis: Iterable&lt;SegmentCommitInfo&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># applyMergeChanges(merge: OneMerge, dropSegment: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ asList(): List&lt;SegmentCommitInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ changed()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ commit(dir: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" ># contains(si: SegmentCommitInfo): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># createBackupSegmentInfos(): List&lt;SegmentCommitInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ files(includeSegmentsFile: boolean): Collection&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># finishCommit(dir: Directory): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ generationFromSegmentsFileName(fileName: String): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastCommitGeneration(files: String[]): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastCommitGeneration(directory: Directory): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastCommitSegmentsFileName(files: String[]): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getLastCommitSegmentsFileName(directory: Directory): String</TD></TR>
<TR><TD ALIGN="LEFT" ># indexOf(si: SegmentCommitInfo): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ info(i: int): SegmentCommitInfo</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;SegmentCommitInfo&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- message(message: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- parseSegmentInfos(directory: Directory, input: DataInput, infos: SegmentInfos, format: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># prepareCommit(dir: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >- readCodec(input: DataInput): Codec</TD></TR>
<TR><TD ALIGN="LEFT" >+ readCommit(directory: Directory, segmentFileName: String): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" ># readCommit(directory: Directory, segmentFileName: String, minSupportedMajorVersion: int): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ readCommit(directory: Directory, input: ChecksumIndexInput, generation: long): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" ># readCommit(directory: Directory, input: ChecksumIndexInput, generation: long, minSupportedMajorVersion: int): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLatestCommit(directory: Directory): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" ># readLatestCommit(directory: Directory, minSupportedMajorVersion: int): SegmentInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ remove(si: SegmentCommitInfo): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># remove(index: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># replace(other: SegmentInfos)</TD></TR>
<TR><TD ALIGN="LEFT" ># rollbackCommit(dir: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" ># rollbackSegmentInfos(infos: List&lt;SegmentCommitInfo&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalMaxDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ updateGeneration(other: SegmentInfos)</TD></TR>
<TR><TD ALIGN="LEFT" ># updateGenerationVersionAndCounter(other: SegmentInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >- write(directory: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(out: IndexOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentInfosSearcherManager1813495465[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentInfosSearcherManager</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentInfos: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   node: Node [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   openReaderCount: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   searcherFactory: SearcherFactory [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- addReaderClosedListener(r: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" ># decRef(s: IndexSearcher)</TD></TR>
<TR><TD ALIGN="LEFT" ># getRefCount(s: IndexSearcher): int</TD></TR>
<TR><TD ALIGN="LEFT" ># onReaderClosed()</TD></TR>
<TR><TD ALIGN="LEFT" ># refreshIfNeeded(old: IndexSearcher): IndexSearcher</TD></TR>
<TR><TD ALIGN="LEFT" ># tryIncRef(s: IndexSearcher): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentMap1114888867[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentMap</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   newToOld: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   oldToNew: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- inverse(map: int[]): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >- map(weights: long[]): int[]</TD></TR>
<TR><TD ALIGN="LEFT" ># newToOld(segment: int): int</TD></TR>
<TR><TD ALIGN="LEFT" ># oldToNew(segment: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentMerger250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentMerger</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   context: IOContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosBuilder: Builder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   mergeState: MergeState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># merge(): MergeState</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeDocValues(segmentWriteState: SegmentWriteState, segmentReadState: SegmentReadState)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeFieldInfos(segmentWriteState: SegmentWriteState, segmentReadState: SegmentReadState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ mergeFieldInfos()</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeFields(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeNorms(segmentWriteState: SegmentWriteState, segmentReadState: SegmentReadState)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergePoints(segmentWriteState: SegmentWriteState, segmentReadState: SegmentReadState)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeTermVectors(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeTerms(segmentWriteState: SegmentWriteState, segmentReadState: SegmentReadState)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeVectorValues(segmentWriteState: SegmentWriteState, segmentReadState: SegmentReadState)</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeWithLogging(merger: Merger, formatName: String): int</TD></TR>
<TR><TD ALIGN="LEFT" >- mergeWithLogging(merger: VoidMerger, segmentWriteState: SegmentWriteState, segmentReadState: SegmentReadState, formatName: String, numMerged: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># shouldMerge(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentReadState250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentReadState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   context: IOContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segmentInfo: SegmentInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segmentSuffix: String [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentReader250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   core: SegmentCoreReaders [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   coreCacheHelper: CacheHelper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docValuesProducer: DocValuesProducer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hardLiveDocs: Bits [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   isNRT: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocs: Bits [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   metaData: LeafMetaData [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   originalSi: SegmentCommitInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readerCacheHelper: CacheHelper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readerClosedListeners: Set&lt;ClosedListener&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segDocValues: SegmentDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   si: SegmentCommitInfo [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- assertLiveDocs(isNRT: boolean, hardLiveDocs: Bits, liveDocs: Bits): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ directory(): Directory</TD></TR>
<TR><TD ALIGN="LEFT" ># doClose()</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ getTermVectors(docID: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" >- initDocValuesProducer(): DocValuesProducer</TD></TR>
<TR><TD ALIGN="LEFT" >- initFieldInfos(): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >+ maxDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyReaderClosedListeners()</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDocs(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentSizeAndDocs1744242089[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentSizeAndDocs</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   delCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   name: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segInfo: SegmentCommitInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sizeInBytes: long [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentState1951225561[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   delGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   onClose: IOConsumer&lt;ReadersAndUpdates&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsEnum: PostingsEnum [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   reader: SegmentReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   rld: ReadersAndUpdates [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   startDelCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   term: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termsEnum: TermsEnum [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentTermsEnum1104727281[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   arcs: Arc&lt;BytesRef&gt;[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentFrame: SegmentTermsEnumFrame [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   eof: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fr: FieldReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstReader: BytesReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchReader: ByteArrayDataInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   stack: SegmentTermsEnumFrame[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   staticFrame: SegmentTermsEnumFrame [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   targetBeforeCurrentLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   term: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   termExists: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   validIndexPrefix: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- clearEOF(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ computeBlockStats(): Stats</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getArc(ord: int): Arc&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- getFrame(ord: int): SegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" ># initIndexInput()</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- printSeekState(out: PrintStream)</TD></TR>
<TR><TD ALIGN="LEFT" ># pushFrame(arc: Arc&lt;BytesRef&gt;, frameData: BytesRef, length: int): SegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" ># pushFrame(arc: Arc&lt;BytesRef&gt;, fp: long, length: int): SegmentTermsEnumFrame</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(target: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(target: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(target: BytesRef, otherState: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- setEOF(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SegmentWriteState250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SegmentWriteState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   context: IOContext [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   delCountOnFlush: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   liveDocs: FixedBitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segUpdates: BufferedUpdates [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segmentInfo: SegmentInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segmentSuffix: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   softDelCountOnFlush: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- assertSegmentSuffix(segmentSuffix: String): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SequentialDocIDMerger1353062267[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SequentialDocIDMerger&lt;T extends DocIDMerger.Sub&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   current: T [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   nextIndex: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subs: List&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ next(): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Serializer639060940[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Serializer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   currentTerm: BytesRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># numBitsToEncode(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># readBytes(input: DataInput, bytes: BytesRef, offset: int, length: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># readIncrementallyEncodedTerm(blockInput: DataInput, isIncrementalEncodingSeed: boolean, reuse: TermBytes): TermBytes</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLine(blockInput: DataInput, isIncrementalEncodingSeed: boolean, reuse: BlockLine): BlockLine</TD></TR>
<TR><TD ALIGN="LEFT" ># writeIncrementallyEncodedTerm(termBytes: TermBytes, previousTermBytes: TermBytes, isIncrementalEncodingSeed: boolean, blockOutput: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLine(blockOutput: DataOutput, line: BlockLine, previousLine: BlockLine, termStateRelativeOffset: int, isIncrementalEncodingSeed: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeLineTermState(termStatesOutput: DataOutput, line: BlockLine, fieldInfo: FieldInfo, encoder: DeltaBaseTermStateSerializer)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ShardSearchingTestBase1349913227[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ShardSearchingTestBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   changeIndicesThread: Thread [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   endTimeNanos: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldsToShare: String[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxSearcherAgeSeconds: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nodes: NodeState[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># broadcastNodeReopen(nodeID: int, version: long, newSearcher: IndexSearcher)</TD></TR>
<TR><TD ALIGN="LEFT" ># finish()</TD></TR>
<TR><TD ALIGN="LEFT" ># getNodeTermStats(terms: Set&lt;Term&gt;, nodeID: int, version: long): Map&lt;Term, TermStatistics&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># searchNode(nodeID: int, nodeVersions: long[], q: Query, sort: Sort, numHits: int, searchAfter: ScoreDoc): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" ># start(numNodes: int, runTimeSec: double, maxSearcherAgeSeconds: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ShortArrayDocIdSet1694690669[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ShortArrayDocIdSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docIDs: short[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleMergedSegmentWarmer250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleMergedSegmentWarmer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ warm(reader: LeafReader)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTVFields2046628276[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTVFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: SortedMap&lt;String, SimpleTVTerms&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTVTermsEnum2046628276[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTVTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   current: Entry&lt;BytesRef, SimpleTVPostings&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   iterator: Iterator&lt;Entry&lt;BytesRef, SimpleTVPostings&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   terms: SortedMap&lt;BytesRef, SimpleTVPostings&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextBits748878065[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextBits</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bits: BitSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   size: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextCodec932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextCodec</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   compoundFormat: CompoundFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dvFormat: DocValuesFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfosFormat: FieldInfosFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   knnVectorsFormat: KnnVectorsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   liveDocs: LiveDocsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   normsFormat: NormsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pointsFormat: PointsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   postings: PostingsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfos: SegmentInfoFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   storedFields: StoredFieldsFormat [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   vectorsFormat: TermVectorsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ compoundFormat(): CompoundFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesFormat(): DocValuesFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldInfosFormat(): FieldInfosFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ knnVectorsFormat(): KnnVectorsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ liveDocsFormat(): LiveDocsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsFormat(): NormsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ pointsFormat(): PointsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ postingsFormat(): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ segmentInfoFormat(): SegmentInfoFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ storedFieldsFormat(): StoredFieldsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ termVectorsFormat(): TermVectorsFormat</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextCompoundFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextCompoundFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getCompoundReader(dir: Directory, si: SegmentInfo, context: IOContext): CompoundDirectory</TD></TR>
<TR><TD ALIGN="LEFT" >- stripPrefix(scratch: BytesRefBuilder, prefix: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextDocValuesFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextDocValuesFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): DocValuesConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): DocValuesProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextDocValuesReader932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextDocValuesReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   data: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fields: Map&lt;String, OneField&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getBinary(fieldInfo: FieldInfo): BinaryDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getBinaryDocsWithField(fieldInfo: FieldInfo): DocValuesIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNumeric(fieldInfo: FieldInfo): NumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumericDocsWithField(fieldInfo: FieldInfo): DocValuesIterator</TD></TR>
<TR><TD ALIGN="LEFT" ># getNumericNonIterator(fieldInfo: FieldInfo): IntFunction&lt;Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSorted(fieldInfo: FieldInfo): SortedDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedNumeric(field: FieldInfo): SortedNumericDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getSortedSet(fieldInfo: FieldInfo): SortedSetDocValues</TD></TR>
<TR><TD ALIGN="LEFT" >- readLine()</TD></TR>
<TR><TD ALIGN="LEFT" >- startsWith(prefix: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- stripPrefix(prefix: BytesRef): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextDocValuesWriter932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextDocValuesWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   data: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldsSeen: Set&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   numDocs: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedNumericField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addSortedSetField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- doAddBinaryField(field: FieldInfo, valuesProducer: DocValuesProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- fieldSeen(field: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- writeFieldEntry(field: FieldInfo, type: DocValuesType)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextFieldInfosFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextFieldInfosFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ distanceFunction(scoreFunction: String): VectorSimilarityFunction</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValuesType(dvType: String): DocValuesType</TD></TR>
<TR><TD ALIGN="LEFT" >- getDocValuesType(type: DocValuesType): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, iocontext: IOContext): FieldInfos</TD></TR>
<TR><TD ALIGN="LEFT" >- readString(offset: int, scratch: BytesRefBuilder): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorEncoding(vectorEncoding: String): VectorEncoding</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(directory: Directory, segmentInfo: SegmentInfo, segmentSuffix: String, infos: FieldInfos, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextFieldsReader932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextFieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fields: TreeMap&lt;String, Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termsCache: Map&lt;String, SimpleTextTerms&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readFields(in: IndexInput): TreeMap&lt;String, Long&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextFieldsWriter932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextFieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   competitiveImpactAccumulator: CompetitiveImpactAccumulator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDocFilePointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   out: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segment: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   skipWriter: SimpleTextSkipWriter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeState: SegmentWriteState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >- getNorm(doc: int, norms: NumericDocValues): long</TD></TR>
<TR><TD ALIGN="LEFT" >- newline()</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fields: Fields, norms: NormsProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fieldInfos: FieldInfos, fields: Fields, normsProducer: NormsProducer)</TD></TR>
<TR><TD ALIGN="LEFT" >- write(s: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- write(b: BytesRef)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextKnnVectorsFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextKnnVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): KnnVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): KnnVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextKnnVectorsReader932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextKnnVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dataIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldEntries: Map&lt;String, FieldEntry&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readState: SegmentReadState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getByteVectorValues(field: String): ByteVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFloatVectorValues(field: String): FloatVectorValues</TD></TR>
<TR><TD ALIGN="LEFT" >- parseInt(prefix: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >- parseLong(prefix: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readInt(in: IndexInput, field: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readLong(in: IndexInput, field: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readString(in: IndexInput, field: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: float[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >+ search(field: String, target: byte[], k: int, acceptDocs: Bits, visitedLimit: int): TopDocs</TD></TR>
<TR><TD ALIGN="LEFT" >- startsWith(prefix: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- stripPrefix(prefix: BytesRef): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextLiveDocsFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextLiveDocsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ files(info: SegmentCommitInfo, files: Collection&lt;String&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >- parseIntAt(bytes: BytesRef, offset: int, scratch: CharsRefBuilder): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLiveDocs(dir: Directory, info: SegmentCommitInfo, context: IOContext): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeLiveDocs(bits: Bits, dir: Directory, info: SegmentCommitInfo, newDelCount: int, context: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextNormsFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextNormsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ normsConsumer(state: SegmentWriteState): NormsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ normsProducer(state: SegmentReadState): NormsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextNormsProducer1974852379[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextNormsProducer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   impl: SimpleTextDocValuesReader [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getNorms(field: FieldInfo): NumericDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextPointTree1344420139[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextPointTree</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   level: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   minPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nodeID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   rootNode: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratchDocIDs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratchPackedValue: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   splitDimValueStack: byte[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   splitDims: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAll(visitor: IntersectVisitor, grown: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- balanceTreeNodePosition(minNode: int, maxNode: int, node: int, position: int, level: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): PointTree</TD></TR>
<TR><TD ALIGN="LEFT" >- getNumLeavesSlow(node: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getTreeDepth(numLeaves: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToChild(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToParent(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToSibling(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- parseInt(scratch: BytesRefBuilder, prefix: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >- pop(isLeft: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- pushLeft()</TD></TR>
<TR><TD ALIGN="LEFT" >- pushRight()</TD></TR>
<TR><TD ALIGN="LEFT" ># readDocIDs(in: IndexInput, blockFP: long, docIDs: int[]): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readLine(in: IndexInput, scratch: BytesRefBuilder)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- sizeFromBalancedTree(leftMostLeafNode: int, rightMostLeafNode: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >- startsWith(scratch: BytesRefBuilder, prefix: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- stripPrefix(scratch: BytesRefBuilder, prefix: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocIDs(visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocValues(visitor: IntersectVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextPointsFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextPointsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(state: SegmentReadState): PointsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(state: SegmentWriteState): PointsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextPointsReader932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextPointsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dataIn: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readState: SegmentReadState [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   readers: Map&lt;String, SimpleTextBKDReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getValues(fieldName: String): PointValues</TD></TR>
<TR><TD ALIGN="LEFT" >- initReader(fp: long): SimpleTextBKDReader</TD></TR>
<TR><TD ALIGN="LEFT" >- parseInt(prefix: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >- parseLong(prefix: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readLine(in: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >- startsWith(prefix: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- stripPrefix(prefix: BytesRef): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextPointsWriter932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextPointsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   dataOut: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexFPs: Map&lt;String, Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   scratch: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writeState: SegmentWriteState [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >- newline(out: IndexOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >- write(out: IndexOutput, s: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- write(out: IndexOutput, b: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(fieldInfo: FieldInfo, reader: PointsReader)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextPostingsFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" ># getPostingsFileName(segment: String, segmentSuffix: String): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextSegmentInfoFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextSegmentInfoFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ read(directory: Directory, segmentName: String, segmentID: byte[], context: IOContext): SegmentInfo</TD></TR>
<TR><TD ALIGN="LEFT" >- readString(offset: int, scratch: BytesRefBuilder): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(dir: Directory, si: SegmentInfo, ioContext: IOContext)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextStoredFieldsFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextStoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextStoredFieldsReader932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextStoredFieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offsets: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchUTF16: CharsRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(n: int, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsAt(a: BytesRef, b: BytesRef, bOffset: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- parseIntAt(offset: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readField(type: BytesRef, fieldInfo: FieldInfo, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >- readIndex(size: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- readLine()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextStoredFieldsWriter932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextStoredFieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   numDocsWritten: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   out: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- newLine()</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >- write(s: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- write(bytes: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: float)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: double)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- writeField(info: FieldInfo)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextTermVectorsFormat932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextTermVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ vectorsReader(directory: Directory, segmentInfo: SegmentInfo, fieldInfos: FieldInfos, context: IOContext): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorsWriter(directory: Directory, segmentInfo: SegmentInfo, context: IOContext): TermVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextTermVectorsReader932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextTermVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offsets: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchUTF16: CharsRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(doc: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" >- parseIntAt(offset: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- readIndex(maxDoc: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- readLine()</TD></TR>
<TR><TD ALIGN="LEFT" >- readString(offset: int, scratch: BytesRefBuilder): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextTermVectorsWriter932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextTermVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   numDocsWritten: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   offsets: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   out: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positions: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addPosition(position: int, startOffset: int, endOffset: int, payload: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- newLine()</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument(numVectorFields: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startField(info: FieldInfo, numTerms: int, positions: boolean, offsets: boolean, payloads: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startTerm(term: BytesRef, freq: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- write(s: String)</TD></TR>
<TR><TD ALIGN="LEFT" >- write(bytes: BytesRef)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextTerms1909808529[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextTerms</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldInfo: FieldInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fst: FST&lt;Pair&lt;Pair&lt;Long, Long&gt;, Pair&lt;Long, Long&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratchUTF16: CharsRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sumDocFreq: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sumTotalTermFreq: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termsStart: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- loadTerms()</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextTermsEnum1909808529[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docFreq: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docsStart: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ended: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstEnum: BytesRefFSTEnum&lt;Pair&lt;Pair&lt;Long, Long&gt;, Pair&lt;Long, Long&gt;&gt;&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexOptions: IndexOptions [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   skipPointer: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   totalTermFreq: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SimpleTextUtil932932250[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SimpleTextUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkFooter(input: ChecksumIndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ fromBytesRefString(s: String): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ readLine(in: DataInput, scratch: BytesRefBuilder)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(out: DataOutput, s: String, scratch: BytesRefBuilder)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(out: DataOutput, b: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeChecksum(out: IndexOutput, scratch: BytesRefBuilder)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeNewline(out: DataOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SingletonSortedNumericDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SingletonSortedNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: NumericDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextValue(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SingletonSortedSetDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SingletonSortedSetDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: SortedDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ord: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextOrd(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ termsEnum(): TermsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SmallDocSet406107357[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SmallDocSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   intSet: SentinelIntSet [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxInt: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bits(): Bits</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): DocIdSetIterator</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ union(other: SmallDocSet): SmallDocSet</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SoftDeletesRetentionMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SoftDeletesRetentionMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   retentionQuerySupplier: Supplier&lt;Query&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># applyRetentionQuery(softDeleteField: String, retentionQuery: Query, reader: CodecReader): CodecReader</TD></TR>
<TR><TD ALIGN="LEFT" >- getScorer(query: Query, reader: CodecReader): Scorer</TD></TR>
<TR><TD ALIGN="LEFT" >+ keepFullyDeletedSegment(readerIOSupplier: IOSupplier&lt;CodecReader&gt;): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ numDeletesToMerge(info: SegmentCommitInfo, delCount: int, readerSupplier: IOSupplier&lt;CodecReader&gt;): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortFieldProvider250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortFieldProvider</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   name: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ availableSortFieldProviders(): Set&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ forName(name: String): SortFieldProvider</TD></TR>
<TR><TD ALIGN="LEFT" >+ readSortField(in: DataInput): SortField</TD></TR>
<TR><TD ALIGN="LEFT" >+ reloadSortFieldProviders(classLoader: ClassLoader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(sf: SortField, output: DataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeSortField(sf: SortField, out: DataOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortState1927379451[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   indices: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedDVs941996959[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedDVs</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   iter: ToParentDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ord: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   selection: Type [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: SortedDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(targetParentDocID: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ increment()</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedDocIDMerger1353062267[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedDocIDMerger&lt;T extends DocIDMerger.Sub&gt;</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   current: T [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queue: PriorityQueue&lt;T&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   queueMinDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   subs: List&lt;T&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ next(): T</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ intersect(automaton: CompiledAutomaton): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ termsEnum(): TermsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedDocValuesTermsEnum250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedDocValuesTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentOrd: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: SortedDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedInputIterator833569740[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedInputIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   comparator: Comparator&lt;BytesRef&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   contexts: Set&lt;BytesRef&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   done: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasContexts: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasPayloads: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payload: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reader: ByteSequencesReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   source: InputIterator [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempDir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempFileNamePrefix: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempInput: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempSortedFileName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tieBreakByCostComparator: Comparator&lt;BytesRef&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   weight: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ contexts(): Set&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># decode(scratch: BytesRef, tmpInput: ByteArrayDataInput): long</TD></TR>
<TR><TD ALIGN="LEFT" ># decodeContexts(scratch: BytesRef, tmpInput: ByteArrayDataInput): Set&lt;BytesRef&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># decodePayload(scratch: BytesRef, tmpInput: ByteArrayDataInput): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" ># encode(writer: ByteSequencesWriter, output: ByteArrayDataOutput, buffer: byte[], spare: BytesRef, payload: BytesRef, contexts: Set&lt;BytesRef&gt;, weight: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ payload(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >- sort(): ByteSequencesReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ weight(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedNumericDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextValue(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedNumericDocValuesSetQuery14040943[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedNumericDocValuesSetQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numbers: LongHashSet [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ rewrite(indexReader: IndexReader): Query</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedSetDocValues250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedSetDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ intersect(automaton: CompiledAutomaton): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupTerm(key: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextOrd(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ termsEnum(): TermsEnum</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedSetDocValuesReaderState1241185064[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedSetDocValuesReaderState</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getDimTree(dim: String): DimTree</TD></TR>
<TR><TD ALIGN="LEFT" >+ getOrdRange(dim: String): OrdRange</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedSetDocValuesTermsEnum250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedSetDocValuesTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   currentOrd: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scratch: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: SortedSetDocValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortedSetSelector536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortedSetSelector</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ wrap(sortedSet: SortedSetDocValues, selector: Type): SortedDocValues</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortingBinaryDocValues815682522[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortingBinaryDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dvs: BinaryDVs [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   spare: BytesRefBuilder [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ binaryValue(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortingBits1402395001[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortingBits</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docMap: DocMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: Bits [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortingNumericDocValues647795726[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortingNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   cost: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   dvs: NumericDVs [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ longValue(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortingPointTree1402395001[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortingPointTree</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docMap: DocMap [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexTree: PointTree [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   sortingIntersectVisitor: SortingIntersectVisitor [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clone(): PointTree</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToChild(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToParent(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ moveToSibling(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocIDs(visitor: IntersectVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ visitDocValues(visitor: IntersectVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortingSortedDocValues1468564066[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortingSortedDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: SortedDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ords: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ordValue(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortingSortedNumericDocValues1976607119[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortingSortedNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: SortedNumericDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   limit: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numValues: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   upto: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   values: LongValues [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextValue(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SortingSortedSetDocValues1314305254[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SortingSortedSetDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   count: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   docID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   in: SortedSetDocValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   limit: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ordUpto: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ords: DocOrds [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ docValueCount(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- initCount()</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookupOrd(ord: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextOrd(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SparseBinaryDocValues841633975[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SparseBinaryDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   disi: IndexedDISI [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SparseFixedBitSet2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SparseFixedBitSet</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bits: long[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indices: long[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   length: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   nonZeroLongCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ramBytesUsed: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- and(i4096: int, i64: int, mask: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ approximateCardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- blockCount(length: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ cardinality(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(i: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear(from: int, to: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- clearWithinBlock(i4096: int, from: int, to: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- consistent(index: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- firstDoc(i4096: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(i: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getAndSet(i: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- insertBlock(i4096: int, i64bit: long, i: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- insertLong(i4096: int, i64bit: long, i: int, index: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- lastDoc(i4096: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ length(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- longBits(index: long, bits: long[], i64: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >- mask(from: int, to: int): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextSetBit(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >- or(i4096: int, index: long, bits: long[], nonZeroLongCount: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- or(other: SparseFixedBitSet)</TD></TR>
<TR><TD ALIGN="LEFT" >+ or(it: DocIdSetIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >- orDense(it: DocIdSetIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >- oversize(s: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ prevSetBit(i: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- removeLong(i4096: int, i64: int, index: long, o: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SparseNormsIterator371244166[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SparseNormsIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   disi: IndexedDISI [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

SparseNumericDocValues841633975[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)SparseNumericDocValues</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   disi: IndexedDISI [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ advance(target: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ advanceExact(target: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ cost(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ docID(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextDoc(): int</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StandardDirectoryReader250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StandardDirectoryReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   applyAllDeletes: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   cacheHelper: CacheHelper [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   readerClosedListeners: Set&lt;ClosedListener&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   segmentInfos: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writeAllDeletes: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writer: IndexWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- decRefWhileHandlingException(readers: SegmentReader[])</TD></TR>
<TR><TD ALIGN="LEFT" ># doClose()</TD></TR>
<TR><TD ALIGN="LEFT" >- doOpenFromCommit(commit: IndexCommit): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" >- doOpenFromWriter(commit: IndexCommit): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># doOpenIfChanged(): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># doOpenIfChanged(commit: IndexCommit): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># doOpenIfChanged(writer: IndexWriter, applyAllDeletes: boolean): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># doOpenIfChanged(infos: SegmentInfos): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" >- doOpenNoWriter(commit: IndexCommit): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># notifyReaderClosedListeners()</TD></TR>
<TR><TD ALIGN="LEFT" ># open(directory: Directory, commit: IndexCommit, leafSorter: Comparator&lt;LeafReader&gt;): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># open(directory: Directory, minSupportedMajorVersion: int, commit: IndexCommit, leafSorter: Comparator&lt;LeafReader&gt;): DirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" ># open(writer: IndexWriter, readerFunction: IOFunction&lt;SegmentCommitInfo, SegmentReader&gt;, infos: SegmentInfos, applyAllDeletes: boolean, writeAllDeletes: boolean): StandardDirectoryReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ open(directory: Directory, infos: SegmentInfos, oldReaders: List&lt;? extends LeafReader&gt;, leafSorter: Comparator&lt;LeafReader&gt;): DirectoryReader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Status1552233252[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Status</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   clean: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   dir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   maxSegmentName: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   missingSegments: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   newSegments: SegmentInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   numBadSegments: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   numSegments: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   partial: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segmentInfos: List&lt;SegmentInfoStatus&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segmentsChecked: List&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   segmentsFileName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   toolOutOfDate: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   totLoseDocCount: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   userData: Map&lt;String, String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   validCounter: boolean [1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StoredFields250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StoredFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ document(docID: int): Document</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, visitor: StoredFieldVisitor)</TD></TR>
<TR><TD ALIGN="LEFT" >+ document(docID: int, fieldsToLoad: Set&lt;String&gt;): Document</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StoredFieldsConsumer250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StoredFieldsConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   accountable: Accountable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   info: SegmentInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lastDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writer: StoredFieldsWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># abort()</TD></TR>
<TR><TD ALIGN="LEFT" ># finish(maxDoc: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" ># flush(state: SegmentWriteState, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" ># initStoredFieldsWriter()</TD></TR>
<TR><TD ALIGN="LEFT" ># startDocument(docID: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeField(info: FieldInfo, value: StoredValue)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StoredFieldsFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StoredFieldsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsReader(directory: Directory, si: SegmentInfo, fn: FieldInfos, context: IOContext): StoredFieldsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsWriter(directory: Directory, si: SegmentInfo, context: IOContext): StoredFieldsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StoredFieldsReader985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StoredFieldsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): StoredFieldsReader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StoredFieldsWriter985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StoredFieldsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: float)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: double)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ writeField(info: FieldInfo, value: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Stream543217653[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Stream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StringHelper2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StringHelper</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bytesDifference(priorTerm: BytesRef, currentTerm: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ endsWith(ref: BytesRef, suffix: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ idToString(id: byte[]): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ intsRefToBytesRef(ints: IntsRef): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ murmurhash3_x86_32(data: byte[], offset: int, len: int, seed: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ murmurhash3_x86_32(bytes: BytesRef, seed: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomId(): byte[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ sortKeyLength(priorTerm: BytesRef, currentTerm: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ startsWith(ref: byte[], prefix: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ startsWith(ref: BytesRef, prefix: BytesRef): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

StringSorter12078005[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)StringSorter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   missingValue: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   providerName: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   reverseMul: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   valuesProvider: SortedDocValuesProvider [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ getComparableProviders(readers: List&lt;? extends LeafReader&gt;): ComparableProvider[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocComparator(reader: LeafReader, maxDoc: int): DocComparator</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TSTLookup2105135845[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TSTLookup</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   autocomplete: TSTAutocomplete [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   root: TernaryTreeNode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempDir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempFileNamePrefix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ add(key: CharSequence, value: Object): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ build(iterator: InputIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >- charSeqEquals(left: CharSequence, right: CharSequence): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: CharSequence): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(input: DataInput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, onlyMorePopular: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- readRecursively(in: DataInput, node: TernaryTreeNode)</TD></TR>
<TR><TD ALIGN="LEFT" >+ store(output: DataOutput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >- writeRecursively(out: DataOutput, node: TernaryTreeNode)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TVFields1635201816[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TVFields</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fieldFlags: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldLengths: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldNumOffs: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fieldNums: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lengths: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numTerms: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadBytes: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadIndex: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positionIndex: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positions: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   prefixLengths: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startOffsets: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   suffixBytes: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   suffixLengths: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termFreqs: int[][] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TVTermsEnum1121260056[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TVTermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   in: ByteArrayDataInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   lengths: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numTerms: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ord: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloadIndex: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   payloads: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positionIndex: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   positions: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   prefixLengths: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startOffsets: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   startPos: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   suffixLengths: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   term: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termFreqs: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" ># reset(numTerms: int, flags: int, prefixLengths: int[], suffixLengths: int[], termFreqs: int[], positionIndex: int[], positions: int[], startOffsets: int[], lengths: int[], payloadIndex: int[], payloads: BytesRef, in: ByteArrayDataInput)</TD></TR>
<TR><TD ALIGN="LEFT" ># reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TaxonomyIndexArrays91058461[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TaxonomyIndexArrays</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   children: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initializedChildren: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   parents: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   siblings: int[] [0..*]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># add(ordinal: int, parentOrdinal: int): TaxonomyIndexArrays</TD></TR>
<TR><TD ALIGN="LEFT" >+ children(): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >- computeChildrenSiblings(first: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- getMajorVersion(reader: IndexReader): int</TD></TR>
<TR><TD ALIGN="LEFT" >- initChildrenSiblings(copyFrom: TaxonomyIndexArrays)</TD></TR>
<TR><TD ALIGN="LEFT" >- initParents(reader: IndexReader, first: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- loadParentUsingTermPosition(reader: IndexReader, first: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ parents(): int[]</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ siblings(): int[]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Term250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Term</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bytes: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   field: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ bytes(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ compareTo(other: Term): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ field(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ text(): String</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermAndSkip181433766[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermAndSkip</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   skips: int[] [0..*]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermAutomatonQuery786328997[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermAutomatonQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   anyTermID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   builder: Builder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   det: Automaton [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   idToTerm: Map&lt;Integer, BytesRef&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termToID: Map&lt;BytesRef, Integer&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addAnyTransition(source: int, dest: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addTransition(source: int, dest: int, term: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addTransition(source: int, dest: int, term: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkFinished(q: TermAutomatonQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ createState(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsTo(other: TermAutomatonQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(determinizeWorkLimit: int)</TD></TR>
<TR><TD ALIGN="LEFT" >- getTermID(term: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ rewrite(reader: IndexReader): Query</TD></TR>
<TR><TD ALIGN="LEFT" >+ toDot(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermBytes157807647[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermBytes</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   mdpLength: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   term: BytesRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ computeMdpLength(previousTerm: BytesRef, currentTerm: BytesRef): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset(mdpLength: int, term: BytesRef): TermBytes</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermData784942383[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermData</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   bytes: byte[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   docFreq: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   totalTermFreq: long [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermInSetQuery536298850[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermInSetQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termData: PrefixCodedTerms [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   termDataHashCode: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- asByteRunAutomaton(): ByteRunAutomaton</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsTo(other: TermInSetQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" ># getTermsEnum(terms: Terms, atts: AttributeSource): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- packTerms(field: String, terms: Collection&lt;BytesRef&gt;): PrefixCodedTerms</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermIterator1195435668[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermIterator</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   builder: BytesRefBuilder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bytes: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   delGen: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   end: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   field: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   input: ByteBuffersDataInput [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ delGen(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ field(): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >- readTermBytes(prefix: int, suffix: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermVectors250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermVectors</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ get(doc: int): Fields</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(doc: int, field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermVectorsConsumer250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermVectorsConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   accountable: Accountable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   flushTerm: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   hasVectors: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   info: SegmentInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   lastDocID: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   numVectorFields: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   perFields: TermVectorsConsumerPerField[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorSliceReaderOff: ByteSliceReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   vectorSliceReaderPos: ByteSliceReader [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writer: TermVectorsWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ abort()</TD></TR>
<TR><TD ALIGN="LEFT" >+ addField(invertState: FieldInvertState, fieldInfo: FieldInfo): TermsHashPerField</TD></TR>
<TR><TD ALIGN="LEFT" ># addFieldToFlush(fieldToFlush: TermVectorsConsumerPerField)</TD></TR>
<TR><TD ALIGN="LEFT" ># fill(docID: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># finishDocument(docID: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># flush(fieldsToFlush: Map&lt;String, TermsHashPerField&gt;, state: SegmentWriteState, sortMap: DocMap, norms: NormsProducer)</TD></TR>
<TR><TD ALIGN="LEFT" ># initTermVectorsWriter()</TD></TR>
<TR><TD ALIGN="LEFT" ># resetFields()</TD></TR>
<TR><TD ALIGN="LEFT" ># startDocument()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermVectorsFormat985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermVectorsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ vectorsReader(directory: Directory, segmentInfo: SegmentInfo, fieldInfos: FieldInfos, context: IOContext): TermVectorsReader</TD></TR>
<TR><TD ALIGN="LEFT" >+ vectorsWriter(directory: Directory, segmentInfo: SegmentInfo, context: IOContext): TermVectorsWriter</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermVectorsReader985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermVectorsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ clone(): TermVectorsReader</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermVectorsWriter985053165[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermVectorsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addAllDocVectors(vectors: Fields, mergeState: MergeState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addPosition(position: int, startOffset: int, endOffset: int, payload: BytesRef)</TD></TR>
<TR><TD ALIGN="LEFT" >+ addProx(numProx: int, positions: DataInput, offsets: DataInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finish(numDocs: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishDocument()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishField()</TD></TR>
<TR><TD ALIGN="LEFT" >+ finishTerm()</TD></TR>
<TR><TD ALIGN="LEFT" >+ merge(mergeState: MergeState): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ startDocument(numVectorFields: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startField(info: FieldInfo, numTerms: int, positions: boolean, offsets: boolean, payloads: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ startTerm(term: BytesRef, freq: int)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermsDict2131115289[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermsDict</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blockAddresses: LongValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockBuffer: BytesRef [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockInput: ByteArrayDataInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockMask: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   bytes: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentCompressedBlockEnd: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   currentCompressedBlockStart: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   entry: TermsDictEntry [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexAddresses: LongValues [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   indexBytes: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   ord: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   term: BytesRef [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- decompressBlock()</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- getFirstTermFromBlock(block: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >- getTermFromIndex(index: long): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ next(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >- seekBlock(text: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >- seekTermsIndex(text: BytesRef): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermsEnum250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermsEnum</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ attributes(): AttributeSource</TD></TR>
<TR><TD ALIGN="LEFT" >+ docFreq(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ impacts(flags: int): ImpactsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ord(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ postings(reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekCeil(text: BytesRef): SeekStatus</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(text: BytesRef): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(ord: long)</TD></TR>
<TR><TD ALIGN="LEFT" >+ seekExact(term: BytesRef, state: TermState)</TD></TR>
<TR><TD ALIGN="LEFT" >+ term(): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ termState(): TermState</TD></TR>
<TR><TD ALIGN="LEFT" >+ totalTermFreq(): long</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermsIncludingScoreQuery1521700474[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermsIncludingScoreQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fromField: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fromQuery: Query [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   multipleValuesPerDocument: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ords: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scoreMode: ScoreMode [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   scores: float[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   terms: BytesRefHash [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   toField: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   topReaderContextId: Object [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ createWeight(searcher: IndexSearcher, scoreMode: ScoreMode, boost: float): Weight</TD></TR>
<TR><TD ALIGN="LEFT" >- equalsTo(other: TermsIncludingScoreQuery): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermsIndexReaderBase625905195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermsIndexReaderBase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFieldEnum(fieldInfo: FieldInfo): FieldIndexEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportsOrd(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TermsQuery1521700474[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TermsQuery</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fromField: String [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fromQuery: Query [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   indexReaderContextId: Object [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ords: int[] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   terms: BytesRefHash [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># getTermsEnum(terms: Terms, atts: AttributeSource): TermsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ visit(visitor: QueryVisitor)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TestBloomFilteredLucenePostings1669641579[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TestBloomFilteredLucenePostings</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   delegate: BloomFilteringPostingsFormat [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TestPointInfoStream1993680483[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TestPointInfoStream</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   delegate: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   testPoint: TestPoint [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ isEnabled(component: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ message(component: String, message: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TestRuleSetupAndRestoreClassEnv1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TestRuleSetupAndRestoreClassEnv</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   avoidCodecs: HashSet&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   initialized: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   locale: Locale [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   savedCodec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   savedInfoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   savedLocale: Locale [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   savedTimeZone: TimeZone [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   similarity: Similarity [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   timeZone: TimeZone [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># after()</TD></TR>
<TR><TD ALIGN="LEFT" ># before()</TD></TR>
<TR><TD ALIGN="LEFT" >- checkCodecRestrictions(codec: Codec)</TD></TR>
<TR><TD ALIGN="LEFT" >- shouldAvoidCodec(codec: String): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TestRuleSetupAndRestoreInstanceEnv1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TestRuleSetupAndRestoreInstanceEnv</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   savedBoolMaxClauseCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># after()</TD></TR>
<TR><TD ALIGN="LEFT" ># before()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TestUtil1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TestUtil</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ addIndexesSlowly(writer: IndexWriter, readers: DirectoryReader...)</TD></TR>
<TR><TD ALIGN="LEFT" >+ alwaysDocValuesFormat(format: DocValuesFormat): Codec</TD></TR>
<TR><TD ALIGN="LEFT" >+ alwaysPostingsFormat(format: PostingsFormat): Codec</TD></TR>
<TR><TD ALIGN="LEFT" >+ anyFilesExceptWriteLock(dir: Directory): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertAttributeReflection(att: AttributeImpl, reflectedValues: Map&lt;String, T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ assertConsistent(expected: TopDocs, actual: TopDocs)</TD></TR>
<TR><TD ALIGN="LEFT" >+ bytesRefToString(br: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ bytesToCharSequence(ref: BytesRef, random: Random): CharSequence</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIndex(dir: Directory): Status</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIndex(dir: Directory, doSlowChecks: boolean): Status</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIndex(dir: Directory, doSlowChecks: boolean, failFast: boolean, concurrent: boolean, output: ByteArrayOutputStream): Status</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIterator(iterator: Iterator&lt;T&gt;, expectedSize: long, allowNull: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIterator(iterator: Iterator&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkReadOnly(coll: Collection&lt;T&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkReader(reader: IndexReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkReader(reader: LeafReader, doSlowChecks: boolean)</TD></TR>
<TR><TD ALIGN="LEFT" >- checkReaderSanity(reader: LeafReader)</TD></TR>
<TR><TD ALIGN="LEFT" >+ cloneDocument(doc1: Document): Document</TD></TR>
<TR><TD ALIGN="LEFT" >+ disableVirusChecker(in: Directory): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ docs(random: Random, r: IndexReader, field: String, term: BytesRef, reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ docs(random: Random, termsEnum: TermsEnum, reuse: PostingsEnum, flags: int): PostingsEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ enableVirusChecker(in: Directory)</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldSupportsHugeBinaryDocValues(field: String): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDefaultPostingsFormat(minItemsPerBlock: int, maxItemsPerBlock: int): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormat(field: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getDocValuesFormat(codec: Codec, field: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormat(field: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormat(codec: Codec, field: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ getPostingsFormatWithOrds(r: Random): PostingsFormat</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasVirusChecker(dir: Directory): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasVirusChecker(path: Path): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasWindowsFS(dir: Directory): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ hasWindowsFS(path: Path): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextBigInteger(random: Random, maxBytes: int): BigInteger</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextInt(r: Random, start: int, end: int): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ nextLong(r: Random, start: long, end: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramCopyOf(dir: Directory): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomAnalysisString(random: Random, maxLength: int, simple: boolean): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomBinaryTerm(r: Random): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomBinaryTerm(r: Random, length: int): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomFixedByteLengthUnicodeString(r: Random, length: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomFixedLengthUnicodeString(random: Random, chars: char[], offset: int, length: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomHtmlishString(random: Random, numElements: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomPattern(random: Random): Pattern</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomRealisticUnicodeString(r: Random): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomRealisticUnicodeString(r: Random, maxLength: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomRealisticUnicodeString(r: Random, minLength: int, maxLength: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomRegexpishString(r: Random): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomRegexpishString(r: Random, maxLength: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomSimpleString(r: Random, maxLength: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomSimpleString(r: Random, minLength: int, maxLength: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomSimpleString(r: Random): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomSimpleStringRange(r: Random, minChar: char, maxChar: char, maxLength: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomSubString(random: Random, wordLength: int, simple: boolean): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomUnicodeString(r: Random): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomUnicodeString(r: Random, maxLength: int): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ randomlyRecaseCodePoints(random: Random, str: String): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ reduceOpenFiles(w: IndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" >+ shutdownExecutorService(ex: ExecutorService)</TD></TR>
<TR><TD ALIGN="LEFT" >+ stringToCharSequence(string: String, random: Random): CharSequence</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncConcurrentMerges(writer: IndexWriter)</TD></TR>
<TR><TD ALIGN="LEFT" >+ syncConcurrentMerges(ms: MergeScheduler)</TD></TR>
<TR><TD ALIGN="LEFT" >+ unzip(in: InputStream, destDir: Path)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

ThreadedIndexingAndSearchingTestCase450222991[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)ThreadedIndexingAndSearchingTestCase</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   addCount: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   assertMergedSegmentsWarmed: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   delCount: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   failed: AtomicBoolean [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   packCount: AtomicInteger [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   warmed: Map&lt;Object, Boolean&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writer: IndexWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># addDocument(id: Term, doc: Iterable&lt;? extends IndexableField&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># addDocuments(id: Term, docs: List&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># deleteDocuments(term: Term)</TD></TR>
<TR><TD ALIGN="LEFT" ># doAfterIndexingThreadDone()</TD></TR>
<TR><TD ALIGN="LEFT" ># doAfterWriter(es: ExecutorService)</TD></TR>
<TR><TD ALIGN="LEFT" ># doClose()</TD></TR>
<TR><TD ALIGN="LEFT" ># doSearching(es: ExecutorService, maxIterations: int)</TD></TR>
<TR><TD ALIGN="LEFT" ># getDirectory(in: Directory): Directory</TD></TR>
<TR><TD ALIGN="LEFT" >- launchIndexingThreads(docs: LineFileDocs, numThreads: int, maxIterations: int, delIDs: Set&lt;String&gt;, delPackIDs: Set&lt;String&gt;, allSubDocs: List&lt;SubDocs&gt;): Thread[]</TD></TR>
<TR><TD ALIGN="LEFT" ># releaseSearcher(s: IndexSearcher)</TD></TR>
<TR><TD ALIGN="LEFT" >- runQuery(s: IndexSearcher, q: Query): long</TD></TR>
<TR><TD ALIGN="LEFT" ># runSearchThreads(maxIterations: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ runTest(testName: String)</TD></TR>
<TR><TD ALIGN="LEFT" ># smokeTestSearcher(s: IndexSearcher)</TD></TR>
<TR><TD ALIGN="LEFT" ># updateDocument(term: Term, doc: Iterable&lt;? extends IndexableField&gt;)</TD></TR>
<TR><TD ALIGN="LEFT" ># updateDocuments(id: Term, docs: List&lt;? extends Iterable&lt;? extends IndexableField&gt;&gt;)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TieredMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TieredMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   deletesPctAllowed: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   floorSegmentBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   forceMergeDeletesPctAllowed: double [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMergeAtOnce: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   maxMergedSegmentBytes: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segsPerTier: double [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- doFindMerges(sortedEligibleInfos: List&lt;SegmentSizeAndDocs&gt;, maxMergedSegmentBytes: long, mergeFactor: int, allowedSegCount: int, allowedDelCount: int, mergeType: MERGE_TYPE, mergeContext: MergeContext, maxMergeIsRunning: boolean): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedDeletesMerges(infos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findForcedMerges(infos: SegmentInfos, maxSegmentCount: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, infos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >- floorSize(bytes: long): long</TD></TR>
<TR><TD ALIGN="LEFT" >- getSortedBySegmentSize(infos: SegmentInfos, mergeContext: MergeContext): List&lt;SegmentSizeAndDocs&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># maxFullFlushMergeSize(): long</TD></TR>
<TR><TD ALIGN="LEFT" ># score(candidate: List&lt;SegmentCommitInfo&gt;, hitTooLarge: boolean, segmentsSizes: Map&lt;SegmentCommitInfo, SegmentSizeAndDocs&gt;): MergeScore</TD></TR>
<TR><TD ALIGN="LEFT" >+ setDeletesPctAllowed(v: double): TieredMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ setFloorSegmentMB(v: double): TieredMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ setForceMergeDeletesPctAllowed(v: double): TieredMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxMergeAtOnce(v: int): TieredMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ setMaxMergedSegmentMB(v: double): TieredMergePolicy</TD></TR>
<TR><TD ALIGN="LEFT" >+ setSegmentsPerTier(v: double): TieredMergePolicy</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TokenFilter1900207534[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TokenFilter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   input: TokenStream [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ end()</TD></TR>
<TR><TD ALIGN="LEFT" >+ reset()</TD></TR>
<TR><TD ALIGN="LEFT" >+ unwrap(): TokenStream</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

TrackingDirectoryWrapper260255019[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)TrackingDirectoryWrapper</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   createdFileNames: Set&lt;String&gt; [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ clearCreatedFiles()</TD></TR>
<TR><TD ALIGN="LEFT" >+ copyFrom(from: Directory, src: String, dest: String, context: IOContext)</TD></TR>
<TR><TD ALIGN="LEFT" >+ createOutput(name: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ createTempOutput(prefix: String, suffix: String, context: IOContext): IndexOutput</TD></TR>
<TR><TD ALIGN="LEFT" >+ deleteFile(name: String)</TD></TR>
<TR><TD ALIGN="LEFT" >+ rename(source: String, dest: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

UTF8TaxonomyWriterCache1222590879[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)UTF8TaxonomyWriterCache</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   bytes: ThreadLocal&lt;BytesRefBuilder&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   bytesUsed: Counter [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   count: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   map: BytesRefHash [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   ordinals: int[][] [0..*]</TD></TR>
<TR><TD ALIGN="LEFT" >-   pageCount: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- assertSameOrdinal(label: FacetLabel, id: int, ord: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ clear()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(label: FacetLabel): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ put(label: FacetLabel, ord: int): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >- toBytes(label: FacetLabel): BytesRef</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

UniformSplitPostingsFormat157807647[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)UniformSplitPostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blockDecoder: BlockDecoder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockEncoder: BlockEncoder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deltaNumLines: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dictionaryOnHeap: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   targetNumBlockLines: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># createUniformSplitTermsReader(postingsReader: PostingsReaderBase, state: SegmentReadState, blockDecoder: BlockDecoder): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" ># createUniformSplitTermsWriter(postingsWriter: PostingsWriterBase, state: SegmentWriteState, targetNumBlockLines: int, deltaNumLines: int, blockEncoder: BlockEncoder): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(state: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(state: SegmentReadState): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" >- validateBlockEncoder(blockEncoder: BlockEncoder, blockDecoder: BlockDecoder)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

UniformSplitRot13PostingsFormat355023596[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)UniformSplitRot13PostingsFormat</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   dictionaryOnHeap: boolean [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># createFieldsConsumer(segmentWriteState: SegmentWriteState, postingsWriter: PostingsWriterBase): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" ># createFieldsProducer(segmentReadState: SegmentReadState, postingsReader: PostingsReaderBase): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsConsumer(segmentWriteState: SegmentWriteState): FieldsConsumer</TD></TR>
<TR><TD ALIGN="LEFT" >+ fieldsProducer(segmentReadState: SegmentReadState): FieldsProducer</TD></TR>
<TR><TD ALIGN="LEFT" ># recordBlockEncodingCall()</TD></TR>
<TR><TD ALIGN="LEFT" ># recordDictionaryEncodingCall()</TD></TR>
<TR><TD ALIGN="LEFT" ># recordFieldsMetadataEncodingCall()</TD></TR>
<TR><TD ALIGN="LEFT" >+ resetEncodingFlags()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

UniformSplitTermsReader157807647[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)UniformSplitTermsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blockInput: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dictionaryInput: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldToTermsMap: Map&lt;String, UniformSplitTerms&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsReader: PostingsReaderBase [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   sortedFieldNames: Collection&lt;String&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   version: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># createDictionaryBrowserSupplier(state: SegmentReadState, dictionaryInput: IndexInput, fieldMetadata: FieldMetadata, blockDecoder: BlockDecoder, dictionaryOnHeap: boolean): BrowserSupplier</TD></TR>
<TR><TD ALIGN="LEFT" ># fillFieldMap(postingsReader: PostingsReaderBase, state: SegmentReadState, blockDecoder: BlockDecoder, dictionaryOnHeap: boolean, dictionaryInput: IndexInput, blockInput: IndexInput, fieldMetadataCollection: Collection&lt;FieldMetadata&gt;, fieldInfos: FieldInfos)</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># readEncodedFieldsMetadata(numFields: int, metadataInput: DataInput, blockDecoder: BlockDecoder, fieldInfos: FieldInfos, fieldMetadataReader: Serializer, maxNumDocs: int): Collection&lt;FieldMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># readFieldsMetadata(indexInput: IndexInput, blockDecoder: BlockDecoder, fieldInfos: FieldInfos, fieldMetadataReader: Serializer, maxNumDocs: int): Collection&lt;FieldMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># readUnencodedFieldsMetadata(numFields: int, metadataInput: DataInput, fieldInfos: FieldInfos, fieldMetadataReader: Serializer, maxNumDocs: int): Collection&lt;FieldMetadata&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># seekFieldsMetadata(indexInput: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

UniformSplitTermsWriter157807647[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)UniformSplitTermsWriter</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   blockEncoder: BlockEncoder [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   blockOutput: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   deltaNumLines: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   dictionaryOutput: IndexOutput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldInfos: FieldInfos [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   fieldMetadataWriter: Serializer [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   maxDoc: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsWriter: PostingsWriterBase [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   targetNumBlockLines: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" ># validateSettings(targetNumBlockLines: int, deltaNumLines: int)</TD></TR>
<TR><TD ALIGN="LEFT" >+ write(fields: Fields, normsProducer: NormsProducer)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeDictionary(dictionaryBuilder: Builder)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeEncodedFieldsMetadata(fieldsOutput: ByteBuffersDataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" ># writeFieldTerms(blockWriter: BlockWriter, fieldsOutput: DataOutput, termsEnum: TermsEnum, fieldInfo: FieldInfo, normsProducer: NormsProducer): int</TD></TR>
<TR><TD ALIGN="LEFT" ># writeFieldsMetadata(fieldsNumber: int, fieldsOutput: ByteBuffersDataOutput)</TD></TR>
<TR><TD ALIGN="LEFT" ># writePostingLine(termsEnum: TermsEnum, fieldMetadata: FieldMetadata, normsProducer: NormsProducer): BlockTermState</TD></TR>
<TR><TD ALIGN="LEFT" ># writeUnencodedFieldsMetadata(fieldsOutput: ByteBuffersDataOutput)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

UpgradeIndexMergePolicy250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)UpgradeIndexMergePolicy</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ findForcedMerges(segmentInfos: SegmentInfos, maxSegmentCount: int, segmentsToMerge: Map&lt;SegmentCommitInfo, Boolean&gt;, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" >+ findMerges(mergeTrigger: MergeTrigger, segmentInfos: SegmentInfos, mergeContext: MergeContext): MergeSpecification</TD></TR>
<TR><TD ALIGN="LEFT" ># shouldUpgradeSegment(si: SegmentCommitInfo): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

VariableGapTermsIndexReader625905195[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)VariableGapTermsIndexReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   fields: HashMap&lt;String, FieldIndexData&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fstOutputs: PositiveIntOutputs [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ getFieldEnum(fieldInfo: FieldInfo): FieldIndexEnum</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >- seekDir(input: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ supportsOrd(): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

VectorValuesConsumer250830108[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)VectorValuesConsumer</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   accountable: Accountable [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   codec: Codec [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   directory: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   infoStream: InfoStream [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   segmentInfo: SegmentInfo [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   writer: KnnVectorsWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># abort()</TD></TR>
<TR><TD ALIGN="LEFT" >+ addField(fieldInfo: FieldInfo): KnnFieldVectorsWriter&lt;?&gt;</TD></TR>
<TR><TD ALIGN="LEFT" ># flush(state: SegmentWriteState, sortMap: DocMap)</TD></TR>
<TR><TD ALIGN="LEFT" >- initKnnVectorsWriter(fieldName: String)</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

VerifyTestClassNamingConvention1509133915[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)VerifyTestClassNamingConvention</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   namingConvention: Pattern [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   packagePrefix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># before()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

Version2069755272[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)Version</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+   bugfix: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   encodedValue: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   major: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   minor: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >+   prerelease: int [1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >- encodedIsValid(): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ fromBits(major: int, minor: int, bugfix: int): Version</TD></TR>
<TR><TD ALIGN="LEFT" >+ onOrAfter(other: Version): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ parse(version: String): Version</TD></TR>
<TR><TD ALIGN="LEFT" >+ parseLeniently(version: String): Version</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

VersionBlockTreeTermsReader1085677175[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)VersionBlockTreeTermsReader</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   fields: TreeMap&lt;String, VersionFieldReader&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   in: IndexInput [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   postingsReader: PostingsReaderBase [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" ># brToString(b: BytesRef): String</TD></TR>
<TR><TD ALIGN="LEFT" >+ checkIntegrity()</TD></TR>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
<TR><TD ALIGN="LEFT" >+ iterator(): Iterator&lt;String&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- readBytesRef(in: IndexInput): BytesRef</TD></TR>
<TR><TD ALIGN="LEFT" >- seekDir(input: IndexInput)</TD></TR>
<TR><TD ALIGN="LEFT" >+ size(): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ terms(field: String): Terms</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

WFSTCompletionLookup2105149299[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)WFSTCompletionLookup</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >-   count: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   exactFirst: boolean [1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   fst: FST&lt;Long&gt; [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempDir: Directory [0..1]</TD></TR>
<TR><TD ALIGN="LEFT" >-   tempFileNamePrefix: String [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ build(iterator: InputIterator)</TD></TR>
<TR><TD ALIGN="LEFT" >- decodeWeight(encoded: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >- encodeWeight(value: long): int</TD></TR>
<TR><TD ALIGN="LEFT" >+ get(key: CharSequence): Object</TD></TR>
<TR><TD ALIGN="LEFT" >+ load(input: DataInput): boolean</TD></TR>
<TR><TD ALIGN="LEFT" >+ lookup(key: CharSequence, contexts: Set&lt;BytesRef&gt;, onlyMorePopular: boolean, num: int): List&lt;LookupResult&gt;</TD></TR>
<TR><TD ALIGN="LEFT" >- lookupPrefix(scratch: BytesRef, arc: Arc&lt;Long&gt;): Long</TD></TR>
<TR><TD ALIGN="LEFT" >+ ramBytesUsed(): long</TD></TR>
<TR><TD ALIGN="LEFT" >+ store(output: DataOutput): boolean</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];

WriterAndSuffix1327861297[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)WriterAndSuffix</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   suffix: int [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   writer: KnnVectorsWriter [0..1]</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >+ close()</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];
} 
} 

subgraph cluster_1905501234 { 
   	label="no qualified name"
	labeljust=l
	fillcolor="#ececec"
	style=filled
   
   noqualifiedname1905501234[
	label=<<TABLE BORDER="1" CELLBORDER="0" CELLPADDING="4" CELLSPACING="0">
<TR><TD ALIGN="LEFT" >(C)RamRecordingHolder</TD></TR>
<HR/>
<TR><TD ALIGN="LEFT" >#   ramBytesUsed: long [1]</TD></TR>
<TR><TD ALIGN="LEFT" >#   updates: ReadersAndUpdates [0..1]</TD></TR>
</TABLE>>
	style=filled
	margin=0
	shape=plaintext
	fillcolor="#FFFFFF"
];
} 

'edges    
AbstractBeforeAfterRule1509133915 -> TestRuleSetupAndRestoreClassEnv1509133915[arrowhead=none, arrowtail=empty, dir=both];
AbstractBeforeAfterRule1509133915 -> TestRuleSetupAndRestoreInstanceEnv1509133915[arrowhead=none, arrowtail=empty, dir=both];
AbstractBeforeAfterRule1509133915 -> VerifyTestClassNamingConvention1509133915[arrowhead=none, arrowtail=empty, dir=both];
AddIndexesMergeSource104941043 -> OneMerge1248977512[label="pendingAddIndexesMerges
[0..1]"];
AnalysisThread808145979 -> RandomIndexWriter450222991[label="iw
[0..1]"];
ApplyDeletesResult1951225561 -> SegmentCommitInfo250830108[label="allDeleted
[0..1]"];
AssertingBinaryDocValues240599230 -> BinaryDocValues250830108[label="in
[0..1]"];
AssertingBinaryDocValues240599230 -> DocValuesIterator250830108[label="advanceExact() -> advanceExact()"];
AssertingCodec132317806 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
AssertingCodec132317806 -> DocValuesFormat985053165[label="docValues
[0..1]"];
AssertingCodec132317806 -> KnnVectorsFormat985053165[label="defaultKnnVectorsFormat
[0..1]"];
AssertingCodec132317806 -> KnnVectorsFormat985053165[label="knnVectorsFormat
[0..1]"];
AssertingCodec132317806 -> LiveDocsFormat985053165[label="liveDocs
[0..1]"];
AssertingCodec132317806 -> NormsFormat985053165[label="norms
[0..1]"];
AssertingCodec132317806 -> PointsFormat985053165[label="pointsFormat
[0..1]"];
AssertingCodec132317806 -> PostingsFormat985053165[label="defaultFormat
[0..1]"];
AssertingCodec132317806 -> PostingsFormat985053165[label="postings
[0..1]"];
AssertingCodec132317806 -> RandomCodec450222991[arrowhead=none, arrowtail=empty, dir=both];
AssertingCodec132317806 -> StoredFieldsFormat985053165[label="storedFields
[0..1]"];
AssertingCodec132317806 -> TermVectorsFormat985053165[label="vectors
[0..1]"];
AssertingDocValuesConsumer19733963 -> BinaryDocValues250830108[label="addBinaryField() -> binaryValue()"];
AssertingDocValuesConsumer19733963 -> DocValuesConsumer985053165[label="in
[0..1]"];
AssertingDocValuesConsumer19733963 -> FixedBitSet2069755272[label="addSortedField() -> cardinality()"];
AssertingDocValuesConsumer19733963 -> LongBitSet2069755272[label="addSortedSetField() -> cardinality()"];
AssertingDocValuesConsumer19733963 -> NumericDocValues250830108[label="addNumericField() -> longValue()"];
AssertingDocValuesFormat132317806 -> DocValuesFormat985053165[label="in
[0..1]"];
AssertingFieldsConsumer952482012 -> SegmentWriteState250830108[label="writeState
[0..1]"];
AssertingKnnVectorsFormat132317806 -> KnnVectorsFormat985053165[label="delegate
[0..1]"];
AssertingKnnVectorsWriter1194681000 -> KnnVectorsWriter985053165[label="delegate
[0..1]"];
AssertingLiveDocsFormat132317806 -> LiveDocsFormat985053165[label="in
[0..1]"];
AssertingNormsFormat132317806 -> NormsFormat985053165[label="in
[0..1]"];
AssertingPointsFormat132317806 -> PointsFormat985053165[label="in
[0..1]"];
AssertingPointsFormat132317806 -> SegmentInfo250830108[label="fieldsReader() -> maxDoc()"];
AssertingPostingsFormat132317806 -> PostingsFormat985053165[label="in
[0..1]"];
AssertingStoredFieldsFormat132317806 -> SegmentInfo250830108[label="fieldsReader() -> maxDoc()"];
AssertingStoredFieldsFormat132317806 -> StoredFieldsFormat985053165[label="in
[0..1]"];
AssertingTermVectorsFormat132317806 -> TermVectorsFormat985053165[label="in
[0..1]"];
BaseDirectoryTestCase459647902 -> BaseChunkedDirectoryTestCase459647902[arrowhead=none, arrowtail=empty, dir=both];
BaseDocValuesFormatTestCase450222991 -> BaseCompressingDocValuesFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BaseCompoundFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BaseDocValuesFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BaseFieldInfoFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BaseKnnVectorsFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BaseNormsFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BasePointsFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BasePostingsFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BaseSegmentInfoFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BaseStoredFieldsFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> BaseTermVectorsFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
BaseIndexFileFormatTestCase450222991 -> Codec985053165[label="savedCodec
[0..1]"];
BaseLiveDocsFormatTestCase450222991 -> Codec985053165[label="savedCodec
[0..1]"];
BaseTokenStreamTestCase1726600449 -> BaseTokenStreamFactoryTestCase1726600449[arrowhead=none, arrowtail=empty, dir=both];
BinaryDocValues250830108 -> AssertingBinaryDocValues240599230[arrowhead=none, arrowtail=empty, dir=both];
BinaryDocValues250830108 -> BinaryRangeDocValues14040943[arrowhead=none, arrowtail=empty, dir=both];
BinaryDocValues250830108 -> BufferedBinaryDocValues815682522[arrowhead=none, arrowtail=empty, dir=both];
BinaryDocValues250830108 -> DenseBinaryDocValues841633975[arrowhead=none, arrowtail=empty, dir=both];
BinaryDocValues250830108 -> FilterBinaryDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
BinaryDocValues250830108 -> SortingBinaryDocValues815682522[arrowhead=none, arrowtail=empty, dir=both];
BinaryDocValues250830108 -> SparseBinaryDocValues841633975[arrowhead=none, arrowtail=empty, dir=both];
BinaryRangeDocValues14040943 -> BinaryDocValues250830108[label="in
[0..1]"];
BinaryRangeDocValues14040943 -> DocValuesIterator250830108[label="advanceExact() -> advanceExact()"];
BloomFilteredFieldsConsumer2057373899 -> SegmentWriteState250830108[label="state
[0..1]"];
BloomFilteringPostingsFormat329228184 -> PostingsFormat985053165[label="delegatePostingsFormat
[0..1]"];
BufferedBinaryDocValues815682522 -> BytesRefBuilder2069755272[label="value
[0..1]"];
BufferedBinaryDocValues815682522 -> DataInput260255019[label="bytesIterator
[0..1]"];
BufferedBinaryDocValues815682522 -> DocIdSetIterator536298850[label="docsWithField
[0..1]"];
BufferedBinaryDocValues815682522 -> Iterator55156406[label="lengthsIterator
[0..1]"];
BufferedUpdatesStream250830108 -> FrozenBufferedUpdates250830108[label="updates
[0..1]"];
Builder1141387501 -> SegmentWriteState250830108[label="state
[0..1]"];
CheapBastardCodec830865138 -> PostingsFormat985053165[label="postings
[0..1]"];
Codec985053165 -> DocValuesFormat985053165[arrowhead=none];
Codec985053165 -> FilterCodec985053165[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> KnnVectorsFormat985053165[arrowhead=none];
Codec985053165 -> Lucene70Codec965738438[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene80Codec965738469[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene84Codec965738473[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene86Codec965738475[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene87Codec965738476[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene90Codec965738500[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene91Codec965738501[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene92Codec965738502[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene94Codec965738504[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> Lucene95Codec961650873[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> PostingsFormat985053165[arrowhead=none];
Codec985053165 -> SimpleTextCodec932932250[arrowhead=none, arrowtail=empty, dir=both];
Codec985053165 -> SortFieldProvider250830108[arrowhead=none];
CodecReader250830108 -> Fields250830108[label="terms() -> terms()"];
CodecReader250830108 -> FieldsProducer985053165[label="checkIntegrity() -> checkIntegrity()"];
CodecReader250830108 -> FilterCodecReader250830108[arrowhead=none, arrowtail=empty, dir=both];
CodecReader250830108 -> SegmentReader250830108[arrowhead=none, arrowtail=empty, dir=both];
CodecReader250830108 -> StoredFields250830108[label="storedFields() -> document()"];
CodecReader250830108 -> StoredFieldsReader985053165[label="checkIntegrity() -> checkIntegrity()"];
CodecReader250830108 -> TermVectorsReader985053165[label="checkIntegrity() -> checkIntegrity()"];
CompletionFieldsConsumer1319730795 -> SegmentWriteState250830108[label="state
[0..1]"];
CompletionPostingsFormat1319730795 -> Completion50PostingsFormat1319730795[arrowhead=none, arrowtail=empty, dir=both];
CompletionPostingsFormat1319730795 -> Completion84PostingsFormat1319730795[arrowhead=none, arrowtail=empty, dir=both];
CompletionPostingsFormat1319730795 -> Completion90PostingsFormat1319730795[arrowhead=none, arrowtail=empty, dir=both];
CompoundFormat985053165 -> CrankyCompoundFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
CompoundFormat985053165 -> Lucene50CompoundFormat965738376[arrowhead=none, arrowtail=empty, dir=both];
CompoundFormat985053165 -> Lucene90CompoundFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
CompoundFormat985053165 -> SimpleTextCompoundFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
CompressingCodec673666990 -> DeflateWithPresetCompressingCodec673666990[arrowhead=none, arrowtail=empty, dir=both];
CompressingCodec673666990 -> DummyCompressingCodec223308788[arrowhead=none, arrowtail=empty, dir=both];
CompressingCodec673666990 -> FastCompressingCodec673666990[arrowhead=none, arrowtail=empty, dir=both];
CompressingCodec673666990 -> FastDecompressionCompressingCodec673666990[arrowhead=none, arrowtail=empty, dir=both];
CompressingCodec673666990 -> HighCompressionCompressingCodec673666990[arrowhead=none, arrowtail=empty, dir=both];
CompressingCodec673666990 -> LZ4WithPresetCompressingCodec673666990[arrowhead=none, arrowtail=empty, dir=both];
CompressingCodec673666990 -> Lucene90CompressingStoredFieldsFormat390611718[label="storedFieldsFormat
[0..1]"];
CompressingCodec673666990 -> Lucene90CompressingTermVectorsFormat390611718[label="termVectorsFormat
[0..1]"];
ConfigurableMCodec346484465 -> KnnVectorsFormat985053165[label="knnVectorsFormat
[0..1]"];
ConsumerAndSuffix439672098 -> DocValuesConsumer985053165[label="consumer
[0..1]"];
CopyState1813495465 -> SegmentInfos250830108[label="infos
[0..1]"];
CrankyCompoundFormat185529096 -> CompoundFormat985053165[label="delegate
[0..1]"];
CrankyDocValuesConsumer562316335 -> DocValuesConsumer985053165[label="delegate
[0..1]"];
CrankyDocValuesFormat185529096 -> DocValuesFormat985053165[label="delegate
[0..1]"];
CrankyFieldInfosFormat185529096 -> FieldInfosFormat985053165[label="delegate
[0..1]"];
CrankyLiveDocsFormat185529096 -> LiveDocsFormat985053165[label="delegate
[0..1]"];
CrankyNormsFormat185529096 -> NormsFormat985053165[label="delegate
[0..1]"];
CrankyPointsFormat185529096 -> PointsFormat985053165[label="delegate
[0..1]"];
CrankyPostingsFormat185529096 -> PostingsFormat985053165[label="delegate
[0..1]"];
CrankySegmentInfoFormat185529096 -> SegmentInfoFormat985053165[label="delegate
[0..1]"];
CrankyStoredFieldsFormat185529096 -> StoredFieldsFormat985053165[label="delegate
[0..1]"];
CrankyTermVectorsFormat185529096 -> TermVectorsFormat985053165[label="delegate
[0..1]"];
DocIDMerger250830108 -> SequentialDocIDMerger1353062267[arrowhead=none, arrowtail=empty, dir=both];
DocIDMerger250830108 -> SortedDocIDMerger1353062267[arrowhead=none, arrowtail=empty, dir=both];
DocValues250830108 -> LeafReaderContext250830108[label="isCacheable() -> reader()"];
DocValuesConsumer985053165 -> AssertingDocValuesConsumer19733963[arrowhead=none, arrowtail=empty, dir=both];
DocValuesConsumer985053165 -> BinaryDocValues250830108[label="mergeBinaryField() -> binaryValue()"];
DocValuesConsumer985053165 -> CrankyDocValuesConsumer562316335[arrowhead=none, arrowtail=empty, dir=both];
DocValuesConsumer985053165 -> FieldsWriter439672098[arrowhead=none, arrowtail=empty, dir=both];
DocValuesConsumer985053165 -> Lucene70DocValuesConsumer965738438[arrowhead=none, arrowtail=empty, dir=both];
DocValuesConsumer985053165 -> Lucene80DocValuesConsumer965738469[arrowhead=none, arrowtail=empty, dir=both];
DocValuesConsumer985053165 -> Lucene90DocValuesConsumer961650868[arrowhead=none, arrowtail=empty, dir=both];
DocValuesConsumer985053165 -> NumericDocValues250830108[label="mergeNumericValues() -> longValue()"];
DocValuesConsumer985053165 -> SimpleTextDocValuesWriter932932250[arrowhead=none, arrowtail=empty, dir=both];
DocValuesFormat985053165 -> AssertingDocValuesFormat132317806[arrowhead=none, arrowtail=empty, dir=both];
DocValuesFormat985053165 -> CrankyDocValuesFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
DocValuesFormat985053165 -> Lucene70DocValuesFormat965738438[arrowhead=none, arrowtail=empty, dir=both];
DocValuesFormat985053165 -> Lucene80DocValuesFormat965738469[arrowhead=none, arrowtail=empty, dir=both];
DocValuesFormat985053165 -> Lucene90DocValuesFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
DocValuesFormat985053165 -> PerFieldDocValuesFormat1541985928[arrowhead=none, arrowtail=empty, dir=both];
DocValuesFormat985053165 -> SimpleTextDocValuesFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
DocValuesIterator250830108 -> BinaryDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
DocValuesIterator250830108 -> MergedDocValues957810353[arrowhead=none, arrowtail=empty, dir=both];
DocValuesIterator250830108 -> NumericDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
DocValuesIterator250830108 -> SortedDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
DocValuesIterator250830108 -> SortedNumericDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
DocValuesIterator250830108 -> SortedSetDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
DocValuesProducer985053165 -> AssertingDocValuesProducer19733963[arrowhead=none, arrowtail=empty, dir=both];
DocValuesProducer985053165 -> EmptyDocValuesProducer250830108[arrowhead=none, arrowtail=empty, dir=both];
DocValuesProducer985053165 -> FieldsReader439672098[arrowhead=none, arrowtail=empty, dir=both];
DocValuesProducer985053165 -> Lucene70DocValuesProducer965738438[arrowhead=none, arrowtail=empty, dir=both];
DocValuesProducer985053165 -> Lucene80DocValuesProducer965738469[arrowhead=none, arrowtail=empty, dir=both];
DocValuesProducer985053165 -> Lucene90DocValuesProducer961650868[arrowhead=none, arrowtail=empty, dir=both];
DocValuesProducer985053165 -> SegmentDocValuesProducer250830108[arrowhead=none, arrowtail=empty, dir=both];
DocValuesProducer985053165 -> SimpleTextDocValuesReader932932250[arrowhead=none, arrowtail=empty, dir=both];
DocumentsWriter250830108 -> LiveIndexWriterConfig250830108[label="config
[0..1]"];
DocumentsWriterFlushControl250830108 -> FlushPolicy250830108[label="flushPolicy
[0..1]"];
DocumentsWriterFlushControl250830108 -> LiveIndexWriterConfig250830108[label="config
[0..1]"];
DocumentsWriterPerThread250830108 -> Codec985053165[label="codec
[0..1]"];
DocumentsWriterPerThread250830108 -> LiveIndexWriterConfig250830108[label="indexWriterConfig
[0..1]"];
DocumentsWriterPerThread250830108 -> SegmentInfo250830108[label="segmentInfo
[0..1]"];
FST146897711 -> KnnVectorsWriter985053165[label="fstStore
[0..1]", arrowhead=none];
FieldInfosFormat985053165 -> CrankyFieldInfosFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
FieldInfosFormat985053165 -> Lucene60FieldInfosFormat965738407[arrowhead=none, arrowtail=empty, dir=both];
FieldInfosFormat985053165 -> Lucene90FieldInfosFormat965738500[arrowhead=none, arrowtail=empty, dir=both];
FieldInfosFormat985053165 -> Lucene94FieldInfosFormat961650872[arrowhead=none, arrowtail=empty, dir=both];
FieldInfosFormat985053165 -> SimpleTextFieldInfosFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> FieldsProducer985053165[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> FilterFields1773060597[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> FreqProxFields250830108[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> MemoryFields2001513788[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> MultiFields250830108[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> ParallelFields156833114[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> SeedFields1550953042[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> SimpleTVFields2046628276[arrowhead=none, arrowtail=empty, dir=both];
Fields250830108 -> TVFields1635201816[arrowhead=none, arrowtail=empty, dir=both];
FieldsConsumer985053165 -> AssertingFieldsConsumer952482012[arrowhead=none, arrowtail=empty, dir=both];
FieldsConsumer985053165 -> BloomFilteredFieldsConsumer2057373899[arrowhead=none, arrowtail=empty, dir=both];
FieldsConsumer985053165 -> CompletionFieldsConsumer1319730795[arrowhead=none, arrowtail=empty, dir=both];
FieldsConsumer985053165 -> FieldsWriter1666370907[arrowhead=none, arrowtail=empty, dir=both];
FieldsConsumer985053165 -> RAMFieldsConsumer402540384[arrowhead=none, arrowtail=empty, dir=both];
FieldsConsumer985053165 -> SimpleTextFieldsWriter932932250[arrowhead=none, arrowtail=empty, dir=both];
FieldsGroup1666370907 -> SegmentWriteState250830108[label="state
[0..1]"];
FieldsWriter1327861297 -> KnnVectorsFormat985053165[label="formats
[0..1]"];
FieldsWriter1327861297 -> SegmentWriteState250830108[label="segmentWriteState
[0..1]"];
FieldsWriter1666370907 -> SegmentWriteState250830108[label="writeState
[0..1]"];
FieldsWriter439672098 -> ConsumerAndSuffix439672098[label="formats
[0..1]"];
FieldsWriter439672098 -> DocValuesFormat985053165[label="formats
[0..1]"];
FieldsWriter439672098 -> IOUtils2069755272[label="close() -> close()"];
FieldsWriter439672098 -> SegmentWriteState250830108[label="segmentWriteState
[0..1]"];
FilterBinaryDocValues250830108 -> BinaryDocValues250830108[label="in
[0..1]"];
FilterBinaryDocValues250830108 -> DocValuesIterator250830108[label="advanceExact() -> advanceExact()"];
FilterBinaryDocValues250830108 -> OrdinalMappingBinaryDocValues1344004654[arrowhead=none, arrowtail=empty, dir=both];
FilterCodec985053165 -> AssertingCodec132317806[arrowhead=none, arrowtail=empty, dir=both];
FilterCodec985053165 -> CheapBastardCodec830865138[arrowhead=none, arrowtail=empty, dir=both];
FilterCodec985053165 -> Codec985053165[label="delegate
[0..1]"];
FilterCodec985053165 -> CompressingCodec673666990[arrowhead=none, arrowtail=empty, dir=both];
FilterCodec985053165 -> ConfigurableMCodec346484465[arrowhead=none, arrowtail=empty, dir=both];
FilterCodec985053165 -> CrankyCodec185529096[arrowhead=none, arrowtail=empty, dir=both];
FilterFields1773060597 -> MappedMultiFields250830108[arrowhead=none, arrowtail=empty, dir=both];
FilterMergePolicy250830108 -> FilterPath1344450007[arrowhead=none];
FilterMergePolicy250830108 -> FilterPostingsEnum1773060597[arrowhead=none];
FilterMergePolicy250830108 -> FilterScorer536298850[arrowhead=none];
FilterMergePolicy250830108 -> ForceMergePolicy450222991[arrowhead=none, arrowtail=empty, dir=both];
FilterMergePolicy250830108 -> MergeOnFlushMergePolicy1230525131[arrowhead=none, arrowtail=empty, dir=both];
FilterMergePolicy250830108 -> MergePolicy250830108[label="in
[0..1]"];
FilterMergePolicy250830108 -> OneMergeWrappingMergePolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
FilterMergePolicy250830108 -> TokenFilter1900207534[arrowhead=none];
FilterMergePolicy250830108 -> UpgradeIndexMergePolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
FilterTerms1773060597 -> MappedMultiTerms1126399149[arrowhead=none, arrowtail=empty, dir=both];
FilterTermsEnum1773060597 -> MappedMultiTermsEnum1126399149[arrowhead=none, arrowtail=empty, dir=both];
FlushPolicy250830108 -> FlushByRamOrCountsPolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
FlushPolicy250830108 -> LiveIndexWriterConfig250830108[label="indexWriterConfig
[0..1]"];
FlushTicket2070583898 -> FrozenBufferedUpdates250830108[label="frozenUpdates
[0..1]"];
FlushedSegment361602770 -> FrozenBufferedUpdates250830108[label="segmentUpdates
[0..1]"];
FlushedSegment361602770 -> SegmentCommitInfo250830108[label="segmentInfo
[0..1]"];
FrozenBufferedUpdates250830108 -> SegmentCommitInfo250830108[label="privateSegment
[0..1]"];
IndexFileDeleter250830108 -> SegmentInfos250830108[label="lastSegmentInfos
[0..1]"];
IndexRearranger1397736262 -> IndexWriterConfig250830108[label="config
[0..1]"];
IndexSplitter1397736262 -> SegmentInfos250830108[label="infos
[0..1]"];
IndexUpgrader250830108 -> IndexWriterConfig250830108[label="iwc
[0..1]"];
IndexWriter250830108 -> AbstractMultiTermQueryConstantScoreWrapper536298850[arrowhead=none];
IndexWriter250830108 -> AbstractPagedMutable611233966[arrowhead=none];
IndexWriter250830108 -> AddIndexesMergeSource104941043[label="addIndexesMergeSource
[0..1]"];
IndexWriter250830108 -> AnalyzingInfixSuggester598362673[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> AnalyzingSuggester598362673[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> AssertingKnnVectorsReader1194681000[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> AssertingKnnVectorsWriter1194681000[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> AssertingStoredFieldsWriter1117745233[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> AssertingTermVectorsWriter732135745[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Automaton1522148614[arrowhead=none];
IndexWriter250830108 -> AutomatonQuery536298850[arrowhead=none];
IndexWriter250830108 -> BitDocIdSet2069755272[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> BitSet2069755272[arrowhead=none];
IndexWriter250830108 -> BlockHeader157807647[arrowhead=none];
IndexWriter250830108 -> BlockLine157807647[arrowhead=none];
IndexWriter250830108 -> BlockReader157807647[arrowhead=none];
IndexWriter250830108 -> BufferedUpdates250830108[arrowhead=none];
IndexWriter250830108 -> BufferedUpdatesStream250830108[arrowhead=none];
IndexWriter250830108 -> BufferingKnnVectorsWriter985053165[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Builder55156406[arrowhead=none];
IndexWriter250830108 -> ByteBlockPool2069755272[arrowhead=none];
IndexWriter250830108 -> ByteBuffersDataInput260255019[arrowhead=none];
IndexWriter250830108 -> ByteBuffersDataOutput260255019[arrowhead=none];
IndexWriter250830108 -> BytesRefHash2069755272[arrowhead=none];
IndexWriter250830108 -> BytesStore146897711[arrowhead=none];
IndexWriter250830108 -> CacheAndCount915011271[arrowhead=none];
IndexWriter250830108 -> CachedOrdinalsReader1914416286[arrowhead=none];
IndexWriter250830108 -> CachedOrds1498707127[arrowhead=none];
IndexWriter250830108 -> CombinedFieldQuery786328997[arrowhead=none];
IndexWriter250830108 -> CompiledAutomaton1522148614[arrowhead=none];
IndexWriter250830108 -> CompletionFieldsProducer1319730795[arrowhead=none];
IndexWriter250830108 -> CompletionsTermsReader1319730795[arrowhead=none];
IndexWriter250830108 -> ContextQuery1319730795[arrowhead=none];
IndexWriter250830108 -> CoveringQuery786328997[arrowhead=none];
IndexWriter250830108 -> CrankyStoredFieldsWriter1067712659[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> CrankyTermVectorsWriter1832214875[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> DefaultSortedSetDocValuesReaderState1241185064[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> DeltaBaseTermStateSerializer157807647[arrowhead=none];
IndexWriter250830108 -> DirectField530590557[arrowhead=none];
IndexWriter250830108 -> DirectMonotonicReader611233966[arrowhead=none];
IndexWriter250830108 -> DirectPacked64SingleBlockReader611233966[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> DirectPackedReader611233966[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Directory260255019[label="directory
[0..1]"];
IndexWriter250830108 -> Directory260255019[label="directoryOrig
[0..1]"];
IndexWriter250830108 -> DirectoryTaxonomyReader91058461[arrowhead=none];
IndexWriter250830108 -> DocIdSet536298850[arrowhead=none];
IndexWriter250830108 -> DocIdSetIterator536298850[label="countSoftDeletes() -> nextDoc()"];
IndexWriter250830108 -> DocsWithFieldSet250830108[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> DocumentsWriter250830108[arrowhead=none];
IndexWriter250830108 -> DocumentsWriterFlushControl250830108[label="rollbackInternalNoCommit() -> waitForFlush()"];
IndexWriter250830108 -> DocumentsWriterPerThread250830108[arrowhead=none];
IndexWriter250830108 -> EventQueue104941043[label="eventQueue
[0..1]"];
IndexWriter250830108 -> FST146897711[arrowhead=none];
IndexWriter250830108 -> FSTCompletionLookup2105149299[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> FieldEntry1910073334[arrowhead=none];
IndexWriter250830108 -> FieldIndexData843236785[arrowhead=none];
IndexWriter250830108 -> FieldInfos250830108[label="publishFlushedSegment() -> fieldInfo()"];
IndexWriter250830108 -> FieldNumbers457064227[label="globalFieldNumberMap
[0..1]"];
IndexWriter250830108 -> FieldReader1943830902[arrowhead=none];
IndexWriter250830108 -> FieldType14040943[arrowhead=none];
IndexWriter250830108 -> FieldWriter1781967873[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> FieldsReader1327861297[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> FieldsWriter1327861297[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> FilterCodecReader250830108[label="mergeMiddle() -> wrapLiveDocs()"];
IndexWriter250830108 -> FixedBitSet2069755272[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> FixedGapTermsIndexReader625905195[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> FlushTicket2070583898[label="publishFlushedSegments() -> markPublished()"];
IndexWriter250830108 -> FreeTextSuggester598362673[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> FrequencyTrackingRingBuffer2069755272[arrowhead=none];
IndexWriter250830108 -> FuzzySet329228184[arrowhead=none];
IndexWriter250830108 -> GlobalOrdinalsQuery1521700474[arrowhead=none];
IndexWriter250830108 -> GlobalOrdinalsWithScoreQuery1521700474[arrowhead=none];
IndexWriter250830108 -> GrowableWriter611233966[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> HighFreqTerm181433766[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> IndexFileDeleter250830108[label="deleter
[0..1]"];
IndexWriter250830108 -> IndexFileNames250830108[label="startCommit() -> fileNameFromGeneration()"];
IndexWriter250830108 -> IndexWriterMergeSource104941043[arrowhead=none];
IndexWriter250830108 -> IndexingChain250830108[arrowhead=none];
IndexWriter250830108 -> InfoStream2069755272[label="infoStream
[0..1]"];
IndexWriter250830108 -> IntArrayDocIdSet2069755272[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> IntBag2016300173[arrowhead=none];
IndexWriter250830108 -> Iterator1098935144[label="commitMergedDeletesAndUpdates() -> nextDoc()"];
IndexWriter250830108 -> JavaUtilBitSet2098602577[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> KnnFieldVectorsWriter985053165[arrowhead=none];
IndexWriter250830108 -> KnnVectorsReader985053165[arrowhead=none];
IndexWriter250830108 -> KnnVectorsWriter985053165[arrowhead=none];
IndexWriter250830108 -> LRUQueryCache536298850[arrowhead=none];
IndexWriter250830108 -> LeafCache915011271[arrowhead=none];
IndexWriter250830108 -> LeafReaderContext250830108[label="tryModifyDocument() -> reader()"];
IndexWriter250830108 -> LegacyDirectMonotonicReader86183421[arrowhead=none];
IndexWriter250830108 -> LegacyPacked6486183421[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> LegacyPacked64SingleBlock86183421[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> LiveIndexWriterConfig250830108[label="config
[0..1]"];
IndexWriter250830108 -> Lock260255019[label="writeLock
[0..1]"];
IndexWriter250830108 -> LongBitSet2069755272[arrowhead=none];
IndexWriter250830108 -> LongHashSet14040943[arrowhead=none];
IndexWriter250830108 -> Lookup833569740[arrowhead=none];
IndexWriter250830108 -> LowFreqTerm181433766[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Lucene90CompressingStoredFieldsWriter390611718[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Lucene90CompressingTermVectorsWriter390611718[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Lucene90HnswVectorsReader965738500[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Lucene91HnswVectorsReader965738501[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Lucene92HnswVectorsReader965738502[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Lucene94HnswVectorsReader965738504[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Lucene95HnswVectorsReader961650873[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Lucene95HnswVectorsWriter961650873[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> MergeScheduler250830108[label="mergeScheduler
[0..1]"];
IndexWriter250830108 -> Merges104941043[label="merges
[0..1]"];
IndexWriter250830108 -> Meta1170552560[arrowhead=none];
IndexWriter250830108 -> MockIndexWriterEventListener450222991[arrowhead=none];
IndexWriter250830108 -> MonotonicBlockPackedReader611233966[arrowhead=none];
IndexWriter250830108 -> NRTCachingDirectory260255019[arrowhead=none];
IndexWriter250830108 -> NRTSuggester1319730795[arrowhead=none];
IndexWriter250830108 -> NotDocIdSet2069755272[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> NullReader126344284[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> OffHeapFSTStore146897711[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> OnHeapFSTStore146897711[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> OnHeapHnswGraph258806880[arrowhead=none];
IndexWriter250830108 -> OneMerge1248977512[label="mergeExceptions
[0..1]"];
IndexWriter250830108 -> OneMerge1248977512[label="pendingMerges
[0..1]"];
IndexWriter250830108 -> OneMerge1248977512[label="runningMerges
[0..1]"];
IndexWriter250830108 -> OrdinalMap250830108[arrowhead=none];
IndexWriter250830108 -> Packed64611233966[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> Packed64SingleBlock611233966[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> PackedLongValues611233966[arrowhead=none];
IndexWriter250830108 -> PagedBytes2069755272[arrowhead=none];
IndexWriter250830108 -> PendingSoftDeletes250830108[label="addIndexesReaderMerge() -> countSoftDeletes()"];
IndexWriter250830108 -> PointInGeo3DShapeQuery1841925665[arrowhead=none];
IndexWriter250830108 -> PointInSetIncludingScoreQuery1521700474[arrowhead=none];
IndexWriter250830108 -> PointInSetQuery536298850[arrowhead=none];
IndexWriter250830108 -> PreCopyMergedSegmentWarmer1813495465[arrowhead=none];
IndexWriter250830108 -> PrefixCodedTerms250830108[arrowhead=none];
IndexWriter250830108 -> RAMDoc402540384[arrowhead=none];
IndexWriter250830108 -> Reader126344284[arrowhead=none];
IndexWriter250830108 -> ReaderPool250830108[label="readerPool
[0..1]"];
IndexWriter250830108 -> ReaderUtil250830108[label="tryModifyDocument() -> subIndex()"];
IndexWriter250830108 -> RoaringDocIdSet2069755272[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> RunAutomaton1522148614[arrowhead=none];
IndexWriter250830108 -> SegmentCommitInfo250830108[label="mergingSegments
[0..1]"];
IndexWriter250830108 -> SegmentCommitInfo250830108[label="rollbackSegments
[0..1]"];
IndexWriter250830108 -> SegmentCommitInfo250830108[label="segmentsToMerge
[0..1]"];
IndexWriter250830108 -> SegmentInfos250830108[label="pendingCommit
[0..1]"];
IndexWriter250830108 -> SegmentInfos250830108[label="segmentInfos
[0..1]"];
IndexWriter250830108 -> SegmentMap1114888867[arrowhead=none];
IndexWriter250830108 -> SegmentMerger250830108[label="runningAddIndexesMerges
[0..1]"];
IndexWriter250830108 -> Serializer639060940[arrowhead=none];
IndexWriter250830108 -> ShortArrayDocIdSet1694690669[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> SimpleMergedSegmentWarmer250830108[arrowhead=none];
IndexWriter250830108 -> SimpleTextKnnVectorsReader932932250[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> SimpleTextStoredFieldsWriter932932250[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> SimpleTextTermVectorsWriter932932250[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> SimpleTextTerms1909808529[arrowhead=none];
IndexWriter250830108 -> SmallDocSet406107357[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> SortState1927379451[arrowhead=none];
IndexWriter250830108 -> SortedNumericDocValuesSetQuery14040943[arrowhead=none];
IndexWriter250830108 -> SortedSetDocValuesReaderState1241185064[arrowhead=none];
IndexWriter250830108 -> SparseFixedBitSet2069755272[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> StoredFieldsWriter985053165[arrowhead=none];
IndexWriter250830108 -> TSTLookup2105135845[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> TaxonomyIndexArrays91058461[arrowhead=none];
IndexWriter250830108 -> Term250830108[arrowhead=none];
IndexWriter250830108 -> TermAndSkip181433766[arrowhead=none];
IndexWriter250830108 -> TermAutomatonQuery786328997[arrowhead=none];
IndexWriter250830108 -> TermBytes157807647[arrowhead=none];
IndexWriter250830108 -> TermData784942383[arrowhead=none];
IndexWriter250830108 -> TermInSetQuery536298850[arrowhead=none];
IndexWriter250830108 -> TermVectorsWriter985053165[arrowhead=none];
IndexWriter250830108 -> TermsIncludingScoreQuery1521700474[arrowhead=none];
IndexWriter250830108 -> TermsIndexReaderBase625905195[arrowhead=none];
IndexWriter250830108 -> TermsQuery1521700474[arrowhead=none];
IndexWriter250830108 -> TrackingDirectoryWrapper260255019[label="addIndexesReaderMerge() -> clearCreatedFiles()"];
IndexWriter250830108 -> UTF8TaxonomyWriterCache1222590879[arrowhead=none];
IndexWriter250830108 -> VariableGapTermsIndexReader625905195[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexWriter250830108 -> WFSTCompletionLookup2105149299[label="ramBytesUsed() -> ramBytesUsed()", arrowhead=none];
IndexingChain250830108 -> LiveIndexWriterConfig250830108[label="indexWriterConfig
[0..1]"];
InfoStream2069755272 -> FailOnNonBulkMergesInfoStream1509133915[arrowhead=none, arrowtail=empty, dir=both];
InfoStream2069755272 -> JavaLoggingInfoStream2069755272[arrowhead=none, arrowtail=empty, dir=both];
InfoStream2069755272 -> NoOutput890247972[arrowhead=none, arrowtail=empty, dir=both];
InfoStream2069755272 -> NullInfoStream1509133915[arrowhead=none, arrowtail=empty, dir=both];
InfoStream2069755272 -> PrintStreamInfoStream2069755272[arrowhead=none, arrowtail=empty, dir=both];
InfoStream2069755272 -> TestPointInfoStream1993680483[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsFormat985053165 -> AssertingKnnVectorsFormat132317806[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsFormat985053165 -> Lucene90HnswVectorsFormat965738500[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsFormat985053165 -> Lucene91HnswVectorsFormat965738501[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsFormat985053165 -> Lucene92HnswVectorsFormat965738502[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsFormat985053165 -> Lucene94HnswVectorsFormat965738504[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsFormat985053165 -> Lucene95HnswVectorsFormat961650873[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsFormat985053165 -> NamedSPILoader2069755272[label="forName() -> lookup()"];
KnnVectorsFormat985053165 -> PerFieldKnnVectorsFormat1541985928[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsFormat985053165 -> SimpleTextKnnVectorsFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsReader985053165 -> SimpleTextKnnVectorsReader932932250[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsWriter985053165 -> AbstractMultiTermQueryConstantScoreWrapper536298850[arrowhead=none];
KnnVectorsWriter985053165 -> AbstractPagedMutable611233966[arrowhead=none];
KnnVectorsWriter985053165 -> AssertingKnnVectorsWriter1194681000[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsWriter985053165 -> Automaton1522148614[arrowhead=none];
KnnVectorsWriter985053165 -> AutomatonQuery536298850[arrowhead=none];
KnnVectorsWriter985053165 -> BitSet2069755272[arrowhead=none];
KnnVectorsWriter985053165 -> BlockHeader157807647[arrowhead=none];
KnnVectorsWriter985053165 -> BlockLine157807647[arrowhead=none];
KnnVectorsWriter985053165 -> BlockReader157807647[arrowhead=none];
KnnVectorsWriter985053165 -> BufferedUpdates250830108[arrowhead=none];
KnnVectorsWriter985053165 -> BufferedUpdatesStream250830108[arrowhead=none];
KnnVectorsWriter985053165 -> BufferingKnnVectorsWriter985053165[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsWriter985053165 -> Builder55156406[arrowhead=none];
KnnVectorsWriter985053165 -> ByteBlockPool2069755272[arrowhead=none];
KnnVectorsWriter985053165 -> ByteBuffersDataInput260255019[arrowhead=none];
KnnVectorsWriter985053165 -> ByteBuffersDataOutput260255019[arrowhead=none];
KnnVectorsWriter985053165 -> BytesRefHash2069755272[arrowhead=none];
KnnVectorsWriter985053165 -> BytesStore146897711[arrowhead=none];
KnnVectorsWriter985053165 -> CacheAndCount915011271[arrowhead=none];
KnnVectorsWriter985053165 -> CachedOrdinalsReader1914416286[arrowhead=none];
KnnVectorsWriter985053165 -> CachedOrds1498707127[arrowhead=none];
KnnVectorsWriter985053165 -> CombinedFieldQuery786328997[arrowhead=none];
KnnVectorsWriter985053165 -> CompiledAutomaton1522148614[arrowhead=none];
KnnVectorsWriter985053165 -> CompletionFieldsProducer1319730795[arrowhead=none];
KnnVectorsWriter985053165 -> CompletionsTermsReader1319730795[arrowhead=none];
KnnVectorsWriter985053165 -> ContextQuery1319730795[arrowhead=none];
KnnVectorsWriter985053165 -> CoveringQuery786328997[arrowhead=none];
KnnVectorsWriter985053165 -> DeltaBaseTermStateSerializer157807647[arrowhead=none];
KnnVectorsWriter985053165 -> DirectField530590557[arrowhead=none];
KnnVectorsWriter985053165 -> DirectMonotonicReader611233966[arrowhead=none];
KnnVectorsWriter985053165 -> DirectoryTaxonomyReader91058461[arrowhead=none];
KnnVectorsWriter985053165 -> DocIdSet536298850[arrowhead=none];
KnnVectorsWriter985053165 -> DocValuesFieldUpdates250830108[arrowhead=none];
KnnVectorsWriter985053165 -> DocumentsWriter250830108[arrowhead=none];
KnnVectorsWriter985053165 -> DocumentsWriterDeleteQueue250830108[arrowhead=none];
KnnVectorsWriter985053165 -> DocumentsWriterFlushControl250830108[arrowhead=none];
KnnVectorsWriter985053165 -> DocumentsWriterPerThread250830108[arrowhead=none];
KnnVectorsWriter985053165 -> FieldEntry1910073334[arrowhead=none];
KnnVectorsWriter985053165 -> FieldIndexData843236785[arrowhead=none];
KnnVectorsWriter985053165 -> FieldReader1943830902[arrowhead=none];
KnnVectorsWriter985053165 -> FieldsWriter1327861297[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsWriter985053165 -> FrequencyTrackingRingBuffer2069755272[arrowhead=none];
KnnVectorsWriter985053165 -> FuzzySet329228184[arrowhead=none];
KnnVectorsWriter985053165 -> GlobalOrdinalsQuery1521700474[arrowhead=none];
KnnVectorsWriter985053165 -> GlobalOrdinalsWithScoreQuery1521700474[arrowhead=none];
KnnVectorsWriter985053165 -> IndexWriter250830108[arrowhead=none];
KnnVectorsWriter985053165 -> IndexingChain250830108[arrowhead=none];
KnnVectorsWriter985053165 -> IntBag2016300173[arrowhead=none];
KnnVectorsWriter985053165 -> KnnFieldVectorsWriter985053165[arrowhead=none];
KnnVectorsWriter985053165 -> KnnVectorsReader985053165[arrowhead=none];
KnnVectorsWriter985053165 -> LRUQueryCache536298850[arrowhead=none];
KnnVectorsWriter985053165 -> LeafCache915011271[arrowhead=none];
KnnVectorsWriter985053165 -> LegacyDirectMonotonicReader86183421[arrowhead=none];
KnnVectorsWriter985053165 -> LongBitSet2069755272[arrowhead=none];
KnnVectorsWriter985053165 -> LongHashSet14040943[arrowhead=none];
KnnVectorsWriter985053165 -> Lookup833569740[arrowhead=none];
KnnVectorsWriter985053165 -> Lucene95HnswVectorsWriter961650873[arrowhead=none, arrowtail=empty, dir=both];
KnnVectorsWriter985053165 -> Meta1170552560[arrowhead=none];
KnnVectorsWriter985053165 -> MonotonicBlockPackedReader611233966[arrowhead=none];
KnnVectorsWriter985053165 -> NRTCachingDirectory260255019[arrowhead=none];
KnnVectorsWriter985053165 -> NRTSuggester1319730795[arrowhead=none];
KnnVectorsWriter985053165 -> OffHeapFSTStore146897711[arrowhead=none];
KnnVectorsWriter985053165 -> OnHeapFSTStore146897711[arrowhead=none];
KnnVectorsWriter985053165 -> OnHeapHnswGraph258806880[arrowhead=none];
KnnVectorsWriter985053165 -> OrdinalMap250830108[arrowhead=none];
KnnVectorsWriter985053165 -> PackedLongValues611233966[arrowhead=none];
KnnVectorsWriter985053165 -> PagedBytes2069755272[arrowhead=none];
KnnVectorsWriter985053165 -> PointInGeo3DShapeQuery1841925665[arrowhead=none];
KnnVectorsWriter985053165 -> PointInSetIncludingScoreQuery1521700474[arrowhead=none];
KnnVectorsWriter985053165 -> PointInSetQuery536298850[arrowhead=none];
KnnVectorsWriter985053165 -> PrefixCodedTerms250830108[arrowhead=none];
KnnVectorsWriter985053165 -> RAMDoc402540384[arrowhead=none];
KnnVectorsWriter985053165 -> Reader126344284[arrowhead=none];
KnnVectorsWriter985053165 -> RunAutomaton1522148614[arrowhead=none];
KnnVectorsWriter985053165 -> SegmentMap1114888867[arrowhead=none];
KnnVectorsWriter985053165 -> Serializer639060940[arrowhead=none];
KnnVectorsWriter985053165 -> SimpleTextTerms1909808529[arrowhead=none];
KnnVectorsWriter985053165 -> SortState1927379451[arrowhead=none];
KnnVectorsWriter985053165 -> SortedNumericDocValuesSetQuery14040943[arrowhead=none];
KnnVectorsWriter985053165 -> SortedSetDocValuesReaderState1241185064[arrowhead=none];
KnnVectorsWriter985053165 -> StoredFieldsWriter985053165[arrowhead=none];
KnnVectorsWriter985053165 -> TaxonomyIndexArrays91058461[arrowhead=none];
KnnVectorsWriter985053165 -> Term250830108[arrowhead=none];
KnnVectorsWriter985053165 -> TermAndSkip181433766[arrowhead=none];
KnnVectorsWriter985053165 -> TermAutomatonQuery786328997[arrowhead=none];
KnnVectorsWriter985053165 -> TermBytes157807647[arrowhead=none];
KnnVectorsWriter985053165 -> TermData784942383[arrowhead=none];
KnnVectorsWriter985053165 -> TermInSetQuery536298850[arrowhead=none];
KnnVectorsWriter985053165 -> TermVectorsWriter985053165[arrowhead=none];
KnnVectorsWriter985053165 -> TermsIncludingScoreQuery1521700474[arrowhead=none];
KnnVectorsWriter985053165 -> TermsIndexReaderBase625905195[arrowhead=none];
KnnVectorsWriter985053165 -> TermsQuery1521700474[arrowhead=none];
KnnVectorsWriter985053165 -> UTF8TaxonomyWriterCache1222590879[arrowhead=none];
LeafReader250830108 -> CodecReader250830108[arrowhead=none, arrowtail=empty, dir=both];
LiveDocsFormat985053165 -> AssertingLiveDocsFormat132317806[arrowhead=none, arrowtail=empty, dir=both];
LiveDocsFormat985053165 -> CrankyLiveDocsFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
LiveDocsFormat985053165 -> Lucene50LiveDocsFormat965738376[arrowhead=none, arrowtail=empty, dir=both];
LiveDocsFormat985053165 -> Lucene90LiveDocsFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
LiveDocsFormat985053165 -> SimpleTextLiveDocsFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
LiveIndexWriterConfig250830108 -> Codec985053165[label="codec
[0..1]"];
LiveIndexWriterConfig250830108 -> FlushPolicy250830108[label="flushPolicy
[0..1]"];
LiveIndexWriterConfig250830108 -> IndexWriterConfig250830108[arrowhead=none, arrowtail=empty, dir=both];
LogMergePolicy250830108 -> AlcoholicMergePolicy450222991[arrowhead=none, arrowtail=empty, dir=both];
LogMergePolicy250830108 -> LogByteSizeMergePolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
LogMergePolicy250830108 -> LogDocMergePolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> AbstractPagedMutable611233966[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectMonotonicReader611233966[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader12748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader16748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader1748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader20748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader24748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader2748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader28748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader32748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader40748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader4748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader48748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader56748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader64748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> DirectPackedReader8748024224[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> LegacyDirectMonotonicReader86183421[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> MonotonicBlockPackedReader611233966[arrowhead=none, arrowtail=empty, dir=both];
LongValues2069755272 -> PackedLongValues611233966[arrowhead=none, arrowtail=empty, dir=both];
Lucene50CompressingStoredFieldsFormat1265304538 -> CompressionMode1091407211[label="compressionMode
[0..1]"];
Lucene50CompressingTermVectorsFormat1265304538 -> CompressionMode1091407211[label="compressionMode
[0..1]"];
Lucene50CompressingTermVectorsFormat1265304538 -> Lucene50TermVectorsFormat965738376[arrowhead=none, arrowtail=empty, dir=both];
Lucene50LiveDocsFormat965738376 -> DataInput260255019[label="readFixedBitSet() -> readLong()"];
Lucene50LiveDocsFormat965738376 -> DataOutput260255019[label="writeBits() -> writeLong()"];
Lucene50LiveDocsFormat965738376 -> SegmentInfo250830108[label="readLiveDocs() -> maxDoc()"];
Lucene50PostingsFormat965738376 -> IOUtils2069755272[label="fieldsProducer() -> closeWhileHandlingException()"];
Lucene50StoredFieldsFormat965738376 -> SegmentInfo250830108[label="fieldsReader() -> getAttribute()"];
Lucene60FieldInfosFormat965738407 -> FieldInfos250830108[label="write() -> size()"];
Lucene60PointsReader965738407 -> SegmentReadState250830108[label="readState
[0..1]"];
Lucene70Codec965738438 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene70Codec965738438 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene70Codec965738438 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene70Codec965738438 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene70Codec965738438 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene70Codec965738438 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene70Codec965738438 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene70Codec965738438 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene70Codec965738438 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene70Codec965738438 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene70DocValuesConsumer965738438 -> BlockReader157807647[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> BloomFilteredTermsEnum1038637548[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> BufferedInputIterator833569740[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> ByteSequenceIterator522240398[arrowhead=none];
Lucene70DocValuesConsumer965738438 -> ByteSequencesReader85288584[arrowhead=none];
Lucene70DocValuesConsumer965738438 -> BytesRefHashIterator664386453[arrowhead=none];
Lucene70DocValuesConsumer965738438 -> CellToBytesRefIterator1037972046[arrowhead=none];
Lucene70DocValuesConsumer965738438 -> DirectIntersectTermsEnum181433766[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> DirectTermsEnum181433766[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> DocumentInputIterator1681937451[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> FieldTermIterator250830108[arrowhead=none];
Lucene70DocValuesConsumer965738438 -> FileIterator45371468[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> FilterTermsEnum1773060597[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> FilteredTermsEnum250830108[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> FreqProxTermsEnum135592398[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> FuzzyTermsEnum536298850[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> HighFrequencyIterator1689880614[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> IDVersionSegmentTermsEnum1085677175[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> IndexOutput260255019[label="data
[0..1]"];
Lucene70DocValuesConsumer965738438 -> IndexOutput260255019[label="meta
[0..1]"];
Lucene70DocValuesConsumer965738438 -> InputIteratorWrapper258807294[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> IntersectTermsEnum1104727281[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> MathUtil2069755272[label="writeValues() -> gcd()"];
Lucene70DocValuesConsumer965738438 -> MemoryTermsEnum2001513788[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> MergedTermsEnum1257536853[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> MultiTermsEnum250830108[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> OrdsIntersectTermsEnum679407426[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> OrdsSegmentTermsEnum679407426[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> RAMTermsEnum402540384[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> STMergingTermsEnum1748595275[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> SeedTermsEnum1550953042[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> SegmentTermsEnum1104727281[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> SimpleTVTermsEnum2046628276[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> SimpleTextTermsEnum1909808529[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> SortedDocValues250830108[label="doAddSortedField() -> ordValue()"];
Lucene70DocValuesConsumer965738438 -> SortedDocValuesTermsEnum250830108[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> SortedInputIterator833569740[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> SortedSetDocValuesTermsEnum250830108[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> SortedSetSelector536298850[label="addSortedSetField() -> wrap()"];
Lucene70DocValuesConsumer965738438 -> Stream543217653[arrowhead=none];
Lucene70DocValuesConsumer965738438 -> TVTermsEnum1121260056[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> TermIterator1195435668[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> TermsDict2131115289[label="next() -> next()", arrowhead=none];
Lucene70DocValuesConsumer965738438 -> TermsEnum250830108[arrowhead=none];
Lucene70SegmentInfoFormat965738438 -> EndiannessReverserUtil1523452426[label="read() -> openChecksumInput()"];
Lucene70SegmentInfoFormat965738438 -> IndexFileNames250830108[label="read() -> segmentFileName()"];
Lucene80Codec965738469 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene80Codec965738469 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene80Codec965738469 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene80Codec965738469 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene80Codec965738469 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene80Codec965738469 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene80Codec965738469 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene80Codec965738469 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene80Codec965738469 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene80Codec965738469 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene80DocValuesConsumer965738469 -> ByteArrayDataOutput260255019[label="addTermsDict() -> reset()"];
Lucene80DocValuesConsumer965738469 -> EndiannessReverserUtil1523452426[label="compressAndGetTermsDictBlockLength() -> wrapDataOutput()"];
Lucene80DocValuesConsumer965738469 -> FieldInfo250830108[label="addBinaryField() -> putAttribute()"];
Lucene80DocValuesConsumer965738469 -> IndexOutput260255019[label="data
[0..1]"];
Lucene80DocValuesConsumer965738469 -> IndexOutput260255019[label="meta
[0..1]"];
Lucene80DocValuesConsumer965738469 -> LZ41930041880[label="compressAndGetTermsDictBlockLength() -> compress()"];
Lucene80DocValuesConsumer965738469 -> MathUtil2069755272[label="writeValues() -> gcd()"];
Lucene80DocValuesConsumer965738469 -> SegmentWriteState250830108[label="state
[0..1]"];
Lucene80DocValuesConsumer965738469 -> SortedDocValues250830108[label="doAddSortedField() -> ordValue()"];
Lucene80DocValuesConsumer965738469 -> SortedSetSelector536298850[label="addSortedSetField() -> wrap()"];
Lucene84Codec965738473 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene84Codec965738473 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene84Codec965738473 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene84Codec965738473 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene84Codec965738473 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene84Codec965738473 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene84Codec965738473 -> PostingsFormat985053165[label="defaultFormat
[0..1]"];
Lucene84Codec965738473 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene84Codec965738473 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene84Codec965738473 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene84Codec965738473 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene84PostingsFormat965738473 -> IOUtils2069755272[label="fieldsProducer() -> closeWhileHandlingException()"];
Lucene86Codec965738475 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene86Codec965738475 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene86Codec965738475 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene86Codec965738475 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene86Codec965738475 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene86Codec965738475 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene86Codec965738475 -> PointsFormat985053165[label="pointsFormat
[0..1]"];
Lucene86Codec965738475 -> PostingsFormat985053165[label="defaultFormat
[0..1]"];
Lucene86Codec965738475 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene86Codec965738475 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene86Codec965738475 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene86Codec965738475 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene86PointsReader965738475 -> SegmentReadState250830108[label="readState
[0..1]"];
Lucene86SegmentInfoFormat965738475 -> EndiannessReverserUtil1523452426[label="read() -> openChecksumInput()"];
Lucene86SegmentInfoFormat965738475 -> IndexFileNames250830108[label="read() -> segmentFileName()"];
Lucene87Codec965738476 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene87Codec965738476 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene87Codec965738476 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene87Codec965738476 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene87Codec965738476 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene87Codec965738476 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene87Codec965738476 -> PointsFormat985053165[label="pointsFormat
[0..1]"];
Lucene87Codec965738476 -> PostingsFormat985053165[label="defaultFormat
[0..1]"];
Lucene87Codec965738476 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene87Codec965738476 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene87Codec965738476 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene87Codec965738476 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene87StoredFieldsFormat965738476 -> SegmentInfo250830108[label="fieldsReader() -> getAttribute()"];
Lucene90Codec965738500 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene90Codec965738500 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene90Codec965738500 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene90Codec965738500 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene90Codec965738500 -> KnnVectorsFormat985053165[label="defaultKnnVectorsFormat
[0..1]"];
Lucene90Codec965738500 -> KnnVectorsFormat985053165[label="knnVectorsFormat
[0..1]"];
Lucene90Codec965738500 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene90Codec965738500 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene90Codec965738500 -> PostingsFormat985053165[label="defaultPostingsFormat
[0..1]"];
Lucene90Codec965738500 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene90Codec965738500 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene90Codec965738500 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene90Codec965738500 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene90CompoundFormat961650868 -> IndexInput260255019[label="writeCompoundFile() -> length()"];
Lucene90CompoundFormat961650868 -> IndexOutput260255019[label="writeCompoundFile() -> alignFilePointer()"];
Lucene90CompressingStoredFieldsFormat390611718 -> CompressionMode1687999461[label="compressionMode
[0..1]"];
Lucene90CompressingTermVectorsFormat390611718 -> CompressionMode1687999461[label="compressionMode
[0..1]"];
Lucene90CompressingTermVectorsFormat390611718 -> Lucene90TermVectorsFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
Lucene90DocValuesConsumer961650868 -> DocValuesIterator250830108[label="doAddSortedField() -> advanceExact()"];
Lucene90DocValuesConsumer961650868 -> IndexOutput260255019[label="data
[0..1]"];
Lucene90DocValuesConsumer961650868 -> IndexOutput260255019[label="meta
[0..1]"];
Lucene90DocValuesConsumer961650868 -> LZ41930041880[label="compressAndGetTermsDictBlockLength() -> compressWithDictionary()"];
Lucene90DocValuesConsumer961650868 -> MathUtil2069755272[label="writeValues() -> gcd()"];
Lucene90DocValuesConsumer961650868 -> SortedDocValues250830108[label="doAddSortedField() -> ordValue()"];
Lucene90DocValuesConsumer961650868 -> SortedSetSelector536298850[label="addSortedSetField() -> wrap()"];
Lucene90FieldInfosFormat965738500 -> FieldInfos250830108[label="write() -> size()"];
Lucene90LiveDocsFormat961650868 -> AssertingBits240599230[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> BitSet2069755272[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> BitsSlice250830108[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> DataInput260255019[label="readFixedBitSet() -> readLong()"];
Lucene90LiveDocsFormat961650868 -> DataOutput260255019[label="writeBits() -> writeLong()"];
Lucene90LiveDocsFormat961650868 -> FixedBits2069755272[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> MatchAllBits259943716[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> MatchNoBits259943716[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> MultiBits250830108[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> SegmentInfo250830108[label="readLiveDocs() -> maxDoc()"];
Lucene90LiveDocsFormat961650868 -> SimpleTextBits748878065[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> SmallDocSet406107357[arrowhead=none];
Lucene90LiveDocsFormat961650868 -> SortingBits1402395001[arrowhead=none];
Lucene90PointsReader961650868 -> SegmentReadState250830108[label="readState
[0..1]"];
Lucene90PointsWriter961650868 -> SegmentWriteState250830108[label="writeState
[0..1]"];
Lucene91Codec965738501 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene91Codec965738501 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene91Codec965738501 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene91Codec965738501 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene91Codec965738501 -> KnnVectorsFormat985053165[label="defaultKnnVectorsFormat
[0..1]"];
Lucene91Codec965738501 -> KnnVectorsFormat985053165[label="knnVectorsFormat
[0..1]"];
Lucene91Codec965738501 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene91Codec965738501 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene91Codec965738501 -> PostingsFormat985053165[label="defaultPostingsFormat
[0..1]"];
Lucene91Codec965738501 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene91Codec965738501 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene91Codec965738501 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene91Codec965738501 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene92Codec965738502 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene92Codec965738502 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene92Codec965738502 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene92Codec965738502 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene92Codec965738502 -> KnnVectorsFormat985053165[label="defaultKnnVectorsFormat
[0..1]"];
Lucene92Codec965738502 -> KnnVectorsFormat985053165[label="knnVectorsFormat
[0..1]"];
Lucene92Codec965738502 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene92Codec965738502 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene92Codec965738502 -> PostingsFormat985053165[label="defaultPostingsFormat
[0..1]"];
Lucene92Codec965738502 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene92Codec965738502 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene92Codec965738502 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene92Codec965738502 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene94Codec965738504 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene94Codec965738504 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene94Codec965738504 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene94Codec965738504 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene94Codec965738504 -> KnnVectorsFormat985053165[label="defaultKnnVectorsFormat
[0..1]"];
Lucene94Codec965738504 -> KnnVectorsFormat985053165[label="knnVectorsFormat
[0..1]"];
Lucene94Codec965738504 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene94Codec965738504 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene94Codec965738504 -> PostingsFormat985053165[label="defaultPostingsFormat
[0..1]"];
Lucene94Codec965738504 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene94Codec965738504 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene94Codec965738504 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene94Codec965738504 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene94FieldInfosFormat961650872 -> FieldInfos250830108[label="write() -> size()"];
Lucene95Codec961650873 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
Lucene95Codec961650873 -> DocValuesFormat985053165[label="defaultDVFormat
[0..1]"];
Lucene95Codec961650873 -> DocValuesFormat985053165[label="docValuesFormat
[0..1]"];
Lucene95Codec961650873 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
Lucene95Codec961650873 -> KnnVectorsFormat985053165[label="defaultKnnVectorsFormat
[0..1]"];
Lucene95Codec961650873 -> KnnVectorsFormat985053165[label="knnVectorsFormat
[0..1]"];
Lucene95Codec961650873 -> LiveDocsFormat985053165[label="liveDocsFormat
[0..1]"];
Lucene95Codec961650873 -> NormsFormat985053165[label="normsFormat
[0..1]"];
Lucene95Codec961650873 -> PostingsFormat985053165[label="defaultPostingsFormat
[0..1]"];
Lucene95Codec961650873 -> PostingsFormat985053165[label="postingsFormat
[0..1]"];
Lucene95Codec961650873 -> SegmentInfoFormat985053165[label="segmentInfosFormat
[0..1]"];
Lucene95Codec961650873 -> StoredFieldsFormat985053165[label="storedFieldsFormat
[0..1]"];
Lucene95Codec961650873 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
Lucene95HnswVectorsWriter961650873 -> SegmentWriteState250830108[label="segmentWriteState
[0..1]"];
LuceneFixedGap979182648 -> TermsIndexReaderBase625905195[label="fieldsProducer() -> close()"];
LuceneTestCase1509133915 -> BaseBitSetTestCase1509133915[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseDirectoryTestCase459647902[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseDocIdSetTestCase1509133915[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseExplanationTestCase1349913227[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseGeoPointTestCase1752419662[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseIndexFileFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseLiveDocsFormatTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseLockFactoryTestCase459647902[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseMergePolicyTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseRangeFieldQueryTestCase1349913227[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseSimilarityTestCase925567676[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseTestCheckIndex450222991[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseTokenStreamTestCase1726600449[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> BaseXYPointTestCase1752419662[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> CollationTestBase1726600449[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> MatchesTestBase1349913227[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> MockFileSystemTestCase1344450007[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> SearchEquivalenceTestBase1349913227[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> ShardSearchingTestBase1349913227[arrowhead=none, arrowtail=empty, dir=both];
LuceneTestCase1509133915 -> ThreadedIndexingAndSearchingTestCase450222991[arrowhead=none, arrowtail=empty, dir=both];
LuceneVarGapDocFreqInterval979182648 -> TermsIndexReaderBase625905195[label="fieldsProducer() -> close()"];
LuceneVarGapFixedInterval979182648 -> TermsIndexReaderBase625905195[label="fieldsProducer() -> close()"];
MappedMultiFields250830108 -> MergeState250830108[label="mergeState
[0..1]"];
MappedMultiTerms1126399149 -> MergeState250830108[label="mergeState
[0..1]"];
MappedMultiTermsEnum1126399149 -> MergeState250830108[label="mergeState
[0..1]"];
MergePolicy250830108 -> AlcoholicMergePolicy450222991[label="size() -> size()"];
MergePolicy250830108 -> FilterMergePolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
MergePolicy250830108 -> IndexWriter250830108[arrowhead=none];
MergePolicy250830108 -> LogByteSizeMergePolicy250830108[label="size() -> size()"];
MergePolicy250830108 -> LogDocMergePolicy250830108[label="size() -> size()"];
MergePolicy250830108 -> LogMergePolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
MergePolicy250830108 -> MockMergeContext372938628[arrowhead=none];
MergePolicy250830108 -> MockRandomMergePolicy450222991[arrowhead=none, arrowtail=empty, dir=both];
MergePolicy250830108 -> NoMergePolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
MergePolicy250830108 -> SegmentCommitInfo250830108[label="size() -> sizeInBytes()"];
MergePolicy250830108 -> TieredMergePolicy250830108[arrowhead=none, arrowtail=empty, dir=both];
MergeReader1248977512 -> SegmentReader250830108[label="reader
[0..1]"];
MergeSpecification1248977512 -> OneMerge1248977512[label="merges
[0..1]"];
MergeState250830108 -> SegmentInfo250830108[label="segmentInfo
[0..1]"];
MergeThread320686676 -> OneMerge1248977512[label="merge
[0..1]"];
MergedDocValues957810353 -> Iterator1098935144[label="updateIterator
[0..1]"];
MergedDocValues957810353 -> noqualifiedname1905501234[label="currentValuesSupplier
[0..1]"];
MergedDocValues957810353 -> noqualifiedname1905501234[label="onDiskDocValues
[0..1]"];
MergedDocValues957810353 -> noqualifiedname1905501234[label="updateDocValues
[0..1]"];
MockMergeContext372938628 -> IndexWriter250830108[arrowhead=none];
MockMergeContext372938628 -> InfoStream2069755272[label="infoStream
[0..1]"];
MockMergeContext372938628 -> SegmentCommitInfo250830108[label="mergingSegments
[0..1]"];
MockMergeContext372938628 -> SegmentCommitInfo250830108[label="numDeletesFunc
[0..1]"];
MockRandomPostingsFormat718940805 -> DataInput260255019[label="fieldsProducer() -> readLong()"];
MockRandomPostingsFormat718940805 -> DataOutput260255019[label="fieldsConsumer() -> writeLong()"];
MockRandomPostingsFormat718940805 -> IndexInput260255019[label="fieldsProducer() -> close()"];
MockRandomPostingsFormat718940805 -> SegmentInfo250830108[label="fieldsConsumer() -> maxDoc()"];
MockRandomPostingsFormat718940805 -> TermsIndexReaderBase625905195[label="fieldsProducer() -> close()"];
NamedSPILoader2069755272 -> Codec985053165[arrowhead=none];
NamedSPILoader2069755272 -> DocValuesFormat985053165[arrowhead=none];
NamedSPILoader2069755272 -> KnnVectorsFormat985053165[arrowhead=none];
NamedSPILoader2069755272 -> PostingsFormat985053165[arrowhead=none];
NamedSPILoader2069755272 -> SortFieldProvider250830108[arrowhead=none];
NamedSPILoader2069755272 -> noqualifiedname1905501234[label="clazz
[0..1]"];
NamedSPILoader2069755272 -> noqualifiedname1905501234[label="services
[0..1]"];
NormsFormat985053165 -> AssertingNormsFormat132317806[arrowhead=none, arrowtail=empty, dir=both];
NormsFormat985053165 -> CrankyNormsFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
NormsFormat985053165 -> Lucene70NormsFormat965738438[arrowhead=none, arrowtail=empty, dir=both];
NormsFormat985053165 -> Lucene80NormsFormat965738469[arrowhead=none, arrowtail=empty, dir=both];
NormsFormat985053165 -> Lucene90NormsFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
NormsFormat985053165 -> SimpleTextNormsFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
NormsProducer985053165 -> AssertingNormsProducer1942197810[arrowhead=none, arrowtail=empty, dir=both];
NormsProducer985053165 -> Lucene70NormsProducer965738438[arrowhead=none, arrowtail=empty, dir=both];
NormsProducer985053165 -> Lucene80NormsProducer965738469[arrowhead=none, arrowtail=empty, dir=both];
NormsProducer985053165 -> Lucene90NormsProducer961650868[arrowhead=none, arrowtail=empty, dir=both];
NormsProducer985053165 -> SimpleTextNormsProducer1974852379[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> AssertingNumericDocValues240599230[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> BufferedNorms1391967427[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> BufferedNumericDocValues647795726[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> DenseNormsIterator371244166[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> DenseNumericDocValues841633975[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> FilterNumericDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> MaxValue438825503[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> MinValue438825503[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> MultiFieldNormValues692532526[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> NumDV941996959[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> SortingNumericDocValues647795726[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> SparseNormsIterator371244166[arrowhead=none, arrowtail=empty, dir=both];
NumericDocValues250830108 -> SparseNumericDocValues841633975[arrowhead=none, arrowtail=empty, dir=both];
OneMerge1248977512 -> MockRandomOneMerge1417707806[arrowhead=none, arrowtail=empty, dir=both];
OneMerge1248977512 -> SegmentCommitInfo250830108[label="info
[0..1]"];
OneMerge1248977512 -> SegmentCommitInfo250830108[label="segments
[0..1]"];
OneMergeWrappingMergePolicy250830108 -> OneMerge1248977512[label="wrapOneMerge
[0..1]"];
Options1334058346 -> IndexWriterConfig250830108[label="config
[0..1]"];
PKIndexSplitter1397736262 -> IndexWriterConfig250830108[label="config1
[0..1]"];
PKIndexSplitter1397736262 -> IndexWriterConfig250830108[label="config2
[0..1]"];
PendingDeletes250830108 -> Codec985053165[label="writeLiveDocs() -> liveDocsFormat()"];
PendingDeletes250830108 -> FixedBitSet2069755272[label="writeableLiveDocs
[0..1]"];
PendingDeletes250830108 -> IOUtils2069755272[label="writeLiveDocs() -> deleteFilesIgnoringExceptions()"];
PendingDeletes250830108 -> LiveDocsFormat985053165[label="writeLiveDocs() -> writeLiveDocs()"];
PendingDeletes250830108 -> MergePolicy250830108[label="numDeletesToMerge() -> numDeletesToMerge()"];
PendingDeletes250830108 -> PendingSoftDeletes250830108[arrowhead=none, arrowtail=empty, dir=both];
PendingDeletes250830108 -> SegmentCommitInfo250830108[label="info
[0..1]"];
PendingSoftDeletes250830108 -> PendingDeletes250830108[label="hardDeletes
[0..1]"];
PerFieldMergeState1541985928 -> MergeState250830108[label="in
[0..1]"];
PointsFormat985053165 -> AssertingPointsFormat132317806[arrowhead=none, arrowtail=empty, dir=both];
PointsFormat985053165 -> CrankyPointsFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
PointsFormat985053165 -> Lucene60PointsFormat965738407[arrowhead=none, arrowtail=empty, dir=both];
PointsFormat985053165 -> Lucene86PointsFormat965738475[arrowhead=none, arrowtail=empty, dir=both];
PointsFormat985053165 -> Lucene90PointsFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
PointsFormat985053165 -> SimpleTextPointsFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
PointsReader985053165 -> Lucene60PointsReader965738407[arrowhead=none, arrowtail=empty, dir=both];
PointsReader985053165 -> Lucene86PointsReader965738475[arrowhead=none, arrowtail=empty, dir=both];
PointsReader985053165 -> Lucene90PointsReader961650868[arrowhead=none, arrowtail=empty, dir=both];
PointsReader985053165 -> SimpleTextPointsReader932932250[arrowhead=none, arrowtail=empty, dir=both];
PointsWriter985053165 -> Lucene90PointsWriter961650868[arrowhead=none, arrowtail=empty, dir=both];
PointsWriter985053165 -> SimpleTextPointsWriter932932250[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> AssertingPostingsFormat132317806[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> BlockTreeOrdsPostingsFormat679407426[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> BloomFilteringPostingsFormat329228184[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> CompletionPostingsFormat1319730795[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> CrankyPostingsFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> DirectPostingsFormat1307742404[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> FSTPostingsFormat1307742404[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> IDVersionPostingsFormat1085677175[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> Lucene50PostingsFormat965738376[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> Lucene84PostingsFormat965738473[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> Lucene90PostingsFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> LuceneFixedGap979182648[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> LuceneVarGapDocFreqInterval979182648[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> LuceneVarGapFixedInterval979182648[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> MockRandomPostingsFormat718940805[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> PerFieldPostingsFormat1541985928[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> RAMOnlyPostingsFormat1504362276[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> SimpleTextPostingsFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> TestBloomFilteredLucenePostings1669641579[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> UniformSplitPostingsFormat157807647[arrowhead=none, arrowtail=empty, dir=both];
PostingsFormat985053165 -> UniformSplitRot13PostingsFormat355023596[arrowhead=none, arrowtail=empty, dir=both];
PrimaryNode1813495465 -> SegmentInfos250830108[label="curInfos
[0..1]"];
RAMFieldsConsumer402540384 -> SegmentWriteState250830108[label="state
[0..1]"];
RAMOnlyPostingsFormat1504362276 -> DataInput260255019[label="fieldsProducer() -> readVInt()"];
RAMOnlyPostingsFormat1504362276 -> DataOutput260255019[label="fieldsConsumer() -> writeVInt()"];
RAMOnlyPostingsFormat1504362276 -> RAMPostings402540384[label="state
[0..1]"];
RandomCodec450222991 -> AssertingPointTree240599230[arrowhead=none];
RandomCodec450222991 -> BKDPointTree480502827[arrowhead=none];
RandomCodec450222991 -> DataOutput260255019[label="pointsFormat() -> writeInt()"];
RandomCodec450222991 -> DocValuesFormat985053165[label="dvFormats
[0..1]"];
RandomCodec450222991 -> DocValuesFormat985053165[label="previousDVMappings
[0..1]"];
RandomCodec450222991 -> ExitablePointTree149965818[arrowhead=none];
RandomCodec450222991 -> MutablePointTree985053165[arrowhead=none];
RandomCodec450222991 -> PointsReader985053165[label="pointsFormat() -> getValues()"];
RandomCodec450222991 -> PostingsFormat985053165[label="formats
[0..1]"];
RandomCodec450222991 -> PostingsFormat985053165[label="previousMappings
[0..1]"];
RandomCodec450222991 -> SegmentInfo250830108[label="pointsFormat() -> maxDoc()"];
RandomCodec450222991 -> SimpleTextPointTree1344420139[arrowhead=none];
RandomCodec450222991 -> SortingPointTree1402395001[arrowhead=none];
RandomIndexWriter450222991 -> LiveIndexWriterConfig250830108[label="config
[0..1]"];
ReaderPool250830108 -> ReadersAndUpdates250830108[label="readerMap
[0..1]"];
ReaderPool250830108 -> SegmentCommitInfo250830108[label="readerMap
[0..1]"];
ReaderPool250830108 -> SegmentInfos250830108[label="segmentInfos
[0..1]"];
ReadersAndUpdates250830108 -> BinaryDocValues250830108[label="handleDVUpdates() -> binaryValue()"];
ReadersAndUpdates250830108 -> DocMap149786621[label="sortMap
[0..1]"];
ReadersAndUpdates250830108 -> DocValuesFieldUpdates250830108[label="mergingDVUpdates
[0..1]"];
ReadersAndUpdates250830108 -> DocValuesFieldUpdates250830108[label="pendingDVUpdates
[0..1]"];
ReadersAndUpdates250830108 -> DocValuesFormat985053165[label="handleDVUpdates() -> fieldsConsumer()"];
ReadersAndUpdates250830108 -> FieldInfosFormat985053165[label="writeFieldInfosGen() -> write()"];
ReadersAndUpdates250830108 -> FieldNumbers457064227[label="writeFieldUpdates() -> constructFieldInfo()"];
ReadersAndUpdates250830108 -> IOUtils2069755272[label="writeFieldUpdates() -> deleteFilesIgnoringExceptions()"];
ReadersAndUpdates250830108 -> MergePolicy250830108[label="keepFullyDeletedSegment() -> keepFullyDeletedSegment()"];
ReadersAndUpdates250830108 -> NumericDocValues250830108[label="handleDVUpdates() -> longValue()"];
ReadersAndUpdates250830108 -> PendingDeletes250830108[label="pendingDeletes
[0..1]"];
ReadersAndUpdates250830108 -> SegmentCommitInfo250830108[label="info
[0..1]"];
ReadersAndUpdates250830108 -> SegmentReader250830108[label="reader
[0..1]"];
SegmentCommitInfo250830108 -> Codec985053165[label="files() -> liveDocsFormat()"];
SegmentCommitInfo250830108 -> Directory260255019[label="sizeInBytes() -> fileLength()"];
SegmentCommitInfo250830108 -> LiveDocsFormat985053165[label="files() -> files()"];
SegmentCommitInfo250830108 -> SegmentInfo250830108[label="info
[0..1]"];
SegmentCommitInfo250830108 -> StringHelper2069755272[label="generationAdvanced() -> randomId()"];
SegmentInfo250830108 -> Codec985053165[label="codec
[0..1]"];
SegmentInfoAndLevel1773705000 -> SegmentCommitInfo250830108[label="info
[0..1]"];
SegmentInfoFormat985053165 -> CrankySegmentInfoFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
SegmentInfoFormat985053165 -> Lucene70SegmentInfoFormat965738438[arrowhead=none, arrowtail=empty, dir=both];
SegmentInfoFormat985053165 -> Lucene86SegmentInfoFormat965738475[arrowhead=none, arrowtail=empty, dir=both];
SegmentInfoFormat985053165 -> Lucene90SegmentInfoFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
SegmentInfoFormat985053165 -> SimpleTextSegmentInfoFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
SegmentInfoStatus706454884 -> Codec985053165[label="codec
[0..1]"];
SegmentInfos250830108 -> SegmentCommitInfo250830108[label="segments
[0..1]"];
SegmentInfosSearcherManager1813495465 -> SegmentInfos250830108[label="currentInfos
[0..1]"];
SegmentMerger250830108 -> Codec985053165[label="codec
[0..1]"];
SegmentMerger250830108 -> MergeState250830108[label="mergeState
[0..1]"];
SegmentReadState250830108 -> SegmentInfo250830108[label="segmentInfo
[0..1]"];
SegmentReader250830108 -> Codec985053165[label="initFieldInfos() -> fieldInfosFormat()"];
SegmentReader250830108 -> CompoundDirectory985053165[label="checkIntegrity() -> checkIntegrity()"];
SegmentReader250830108 -> DelegatingCacheHelper164815750[arrowhead=none];
SegmentReader250830108 -> DocValuesProducer985053165[label="docValuesProducer
[0..1]"];
SegmentReader250830108 -> FieldInfos250830108[label="fieldInfos
[0..1]"];
SegmentReader250830108 -> FieldInfosFormat985053165[label="initFieldInfos() -> read()"];
SegmentReader250830108 -> IOUtils2069755272[label="notifyReaderClosedListeners() -> applyToAll()"];
SegmentReader250830108 -> LeafMetaData250830108[label="metaData
[0..1]"];
SegmentReader250830108 -> SegmentCommitInfo250830108[label="originalSi
[0..1]"];
SegmentReader250830108 -> SegmentCommitInfo250830108[label="si
[0..1]"];
SegmentReader250830108 -> SegmentCoreReaders250830108[label="core
[0..1]"];
SegmentReader250830108 -> SegmentDocValues250830108[label="segDocValues
[0..1]"];
SegmentReader250830108 -> SegmentInfo250830108[label="maxDoc() -> maxDoc()"];
SegmentReader250830108 -> StoredFields250830108[label="document() -> document()"];
SegmentReader250830108 -> TermVectors250830108[label="getTermVectors() -> get()"];
SegmentSizeAndDocs1744242089 -> SegmentCommitInfo250830108[label="segInfo
[0..1]"];
SegmentState1951225561 -> ReadersAndUpdates250830108[label="onClose
[0..1]"];
SegmentState1951225561 -> ReadersAndUpdates250830108[label="rld
[0..1]"];
SegmentState1951225561 -> SegmentReader250830108[label="reader
[0..1]"];
SegmentWriteState250830108 -> SegmentInfo250830108[label="segmentInfo
[0..1]"];
SimpleTextCodec932932250 -> CompoundFormat985053165[label="compoundFormat
[0..1]"];
SimpleTextCodec932932250 -> DocValuesFormat985053165[label="dvFormat
[0..1]"];
SimpleTextCodec932932250 -> FieldInfosFormat985053165[label="fieldInfosFormat
[0..1]"];
SimpleTextCodec932932250 -> KnnVectorsFormat985053165[label="knnVectorsFormat
[0..1]"];
SimpleTextCodec932932250 -> LiveDocsFormat985053165[label="liveDocs
[0..1]"];
SimpleTextCodec932932250 -> NormsFormat985053165[label="normsFormat
[0..1]"];
SimpleTextCodec932932250 -> PointsFormat985053165[label="pointsFormat
[0..1]"];
SimpleTextCodec932932250 -> PostingsFormat985053165[label="postings
[0..1]"];
SimpleTextCodec932932250 -> SegmentInfoFormat985053165[label="segmentInfos
[0..1]"];
SimpleTextCodec932932250 -> StoredFieldsFormat985053165[label="storedFields
[0..1]"];
SimpleTextCodec932932250 -> TermVectorsFormat985053165[label="vectorsFormat
[0..1]"];
SimpleTextCompoundFormat932932250 -> BytesRef2069755272[label="getCompoundReader() -> utf8ToString()"];
SimpleTextCompoundFormat932932250 -> DataOutput260255019[label="write() -> copyBytes()"];
SimpleTextDocValuesWriter932932250 -> BytesRefBuilder2069755272[label="scratch
[0..1]"];
SimpleTextDocValuesWriter932932250 -> DocValuesIterator250830108[label="addSortedNumericField() -> advanceExact()"];
SimpleTextDocValuesWriter932932250 -> IndexOutput260255019[label="data
[0..1]"];
SimpleTextFieldInfosFormat932932250 -> FieldInfos250830108[label="write() -> size()"];
SimpleTextFieldInfosFormat932932250 -> IndexInput260255019[label="read() -> close()"];
SimpleTextFieldInfosFormat932932250 -> IndexOutput260255019[label="write() -> close()"];
SimpleTextFieldsWriter932932250 -> SegmentWriteState250830108[label="writeState
[0..1]"];
SimpleTextKnnVectorsReader932932250 -> SegmentReadState250830108[label="readState
[0..1]"];
SimpleTextLiveDocsFormat932932250 -> ArrayUtil2069755272[label="parseIntAt() -> parseInt()"];
SimpleTextPointsReader932932250 -> SegmentReadState250830108[label="readState
[0..1]"];
SimpleTextPointsWriter932932250 -> SegmentWriteState250830108[label="writeState
[0..1]"];
SimpleTextPostingsFormat932932250 -> IndexFileNames250830108[label="getPostingsFileName() -> segmentFileName()"];
SimpleTextSegmentInfoFormat932932250 -> ArrayUtil2069755272[label="read() -> copyOfSubArray()"];
SimpleTextSegmentInfoFormat932932250 -> ByteArrayDataInput260255019[label="read() -> eof()"];
SimpleTextSegmentInfoFormat932932250 -> DoubleSorter12078005[arrowhead=none];
SimpleTextSegmentInfoFormat932932250 -> FloatSorter12078005[arrowhead=none];
SimpleTextSegmentInfoFormat932932250 -> IntSorter12078005[arrowhead=none];
SimpleTextSegmentInfoFormat932932250 -> LongSorter12078005[arrowhead=none];
SimpleTextSegmentInfoFormat932932250 -> StringSorter12078005[arrowhead=none];
SortFieldProvider250830108 -> Provider575826809[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> AssertingSortedDocValues240599230[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> BaseSortedDocValues841633975[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> BufferedSortedDocValues1468564066[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> BytesRef2069755272[label="lookupTerm() -> compareTo()"];
SortedDocValues250830108 -> FilterSortedDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> MaxValue2012450828[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> MiddleMaxValue2012450828[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> MiddleMinValue2012450828[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> MinValue2012450828[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> MultiSortedDocValues267023757[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> SortedDVs941996959[arrowhead=none, arrowtail=empty, dir=both];
SortedDocValues250830108 -> SortingSortedDocValues1468564066[arrowhead=none, arrowtail=empty, dir=both];
SortedNumericDocValues250830108 -> AssertingSortedNumericDocValues240599230[arrowhead=none, arrowtail=empty, dir=both];
SortedNumericDocValues250830108 -> BackCompatSortedNumericDocValues1914416286[arrowhead=none, arrowtail=empty, dir=both];
SortedNumericDocValues250830108 -> BufferedSortedNumericDocValues1976607119[arrowhead=none, arrowtail=empty, dir=both];
SortedNumericDocValues250830108 -> FilterSortedNumericDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
SortedNumericDocValues250830108 -> SingletonSortedNumericDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
SortedNumericDocValues250830108 -> SortingSortedNumericDocValues1976607119[arrowhead=none, arrowtail=empty, dir=both];
SortedSetDocValues250830108 -> AssertingSortedSetDocValues240599230[arrowhead=none, arrowtail=empty, dir=both];
SortedSetDocValues250830108 -> BaseSortedSetDocValues841633975[arrowhead=none, arrowtail=empty, dir=both];
SortedSetDocValues250830108 -> BufferedSortedSetDocValues1314305254[arrowhead=none, arrowtail=empty, dir=both];
SortedSetDocValues250830108 -> BytesRef2069755272[label="lookupTerm() -> compareTo()"];
SortedSetDocValues250830108 -> FilterSortedSetDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
SortedSetDocValues250830108 -> MultiSortedSetDocValues267023757[arrowhead=none, arrowtail=empty, dir=both];
SortedSetDocValues250830108 -> SingletonSortedSetDocValues250830108[arrowhead=none, arrowtail=empty, dir=both];
SortedSetDocValues250830108 -> SortingSortedSetDocValues1314305254[arrowhead=none, arrowtail=empty, dir=both];
SortingBinaryDocValues815682522 -> BinaryDVs815682522[label="dvs
[0..1]"];
SortingBinaryDocValues815682522 -> BytesRefBuilder2069755272[label="spare
[0..1]"];
SparseBinaryDocValues841633975 -> IndexedDISI965738469[label="disi
[0..1]"];
StandardDirectoryReader250830108 -> SegmentInfos250830108[label="segmentInfos
[0..1]"];
Status1552233252 -> SegmentInfoStatus706454884[label="segmentInfos
[0..1]"];
Status1552233252 -> SegmentInfos250830108[label="newSegments
[0..1]"];
StoredFields250830108 -> StoredFieldsReader985053165[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsConsumer250830108 -> Codec985053165[label="codec
[0..1]"];
StoredFieldsConsumer250830108 -> KnnVectorsWriter985053165[label="accountable
[0..1]", arrowhead=none];
StoredFieldsConsumer250830108 -> SegmentInfo250830108[label="info
[0..1]"];
StoredFieldsFormat985053165 -> AssertingStoredFieldsFormat132317806[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsFormat985053165 -> CrankyStoredFieldsFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsFormat985053165 -> Lucene50CompressingStoredFieldsFormat1265304538[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsFormat985053165 -> Lucene50StoredFieldsFormat965738376[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsFormat985053165 -> Lucene87StoredFieldsFormat965738476[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsFormat985053165 -> Lucene90CompressingStoredFieldsFormat390611718[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsFormat985053165 -> Lucene90StoredFieldsFormat961650868[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsFormat985053165 -> SimpleTextStoredFieldsFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsReader985053165 -> AssertingStoredFieldsReader1117745233[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsReader985053165 -> Lucene50CompressingStoredFieldsReader1265304538[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsReader985053165 -> Lucene90CompressingStoredFieldsReader390611718[arrowhead=none, arrowtail=empty, dir=both];
StoredFieldsReader985053165 -> SimpleTextStoredFieldsReader932932250[arrowhead=none, arrowtail=empty, dir=both];
TermVectors250830108 -> TermVectorsReader985053165[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsConsumer250830108 -> Codec985053165[label="codec
[0..1]"];
TermVectorsConsumer250830108 -> KnnVectorsWriter985053165[label="accountable
[0..1]", arrowhead=none];
TermVectorsConsumer250830108 -> SegmentInfo250830108[label="info
[0..1]"];
TermVectorsFormat985053165 -> AssertingTermVectorsFormat132317806[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsFormat985053165 -> CrankyTermVectorsFormat185529096[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsFormat985053165 -> Lucene50CompressingTermVectorsFormat1265304538[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsFormat985053165 -> Lucene90CompressingTermVectorsFormat390611718[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsFormat985053165 -> SimpleTextTermVectorsFormat932932250[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsReader985053165 -> AssertingTermVectorsReader732135745[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsReader985053165 -> Lucene50CompressingTermVectorsReader1265304538[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsReader985053165 -> Lucene90CompressingTermVectorsReader390611718[arrowhead=none, arrowtail=empty, dir=both];
TermVectorsReader985053165 -> SimpleTextTermVectorsReader932932250[arrowhead=none, arrowtail=empty, dir=both];
TestBloomFilteredLucenePostings1669641579 -> BloomFilteringPostingsFormat329228184[label="delegate
[0..1]"];
TestRuleSetupAndRestoreClassEnv1509133915 -> Codec985053165[label="codec
[0..1]"];
TestRuleSetupAndRestoreClassEnv1509133915 -> Codec985053165[label="savedCodec
[0..1]"];
TieredMergePolicy250830108 -> SegmentInfo250830108[label="findForcedDeletesMerges() -> maxDoc()"];
TieredMergePolicy250830108 -> SegmentInfos250830108[label="findMerges() -> size()"];
UniformSplitPostingsFormat157807647 -> STUniformSplitPostingsFormat1748595275[arrowhead=none, arrowtail=empty, dir=both];
UniformSplitRot13PostingsFormat355023596 -> STUniformSplitRot13PostingsFormat1389498984[arrowhead=none, arrowtail=empty, dir=both];
VectorValuesConsumer250830108 -> Codec985053165[label="codec
[0..1]"];
VectorValuesConsumer250830108 -> KnnVectorsWriter985053165[label="accountable
[0..1]", arrowhead=none];
VectorValuesConsumer250830108 -> SegmentInfo250830108[label="segmentInfo
[0..1]"];
WriterAndSuffix1327861297 -> KnnVectorsWriter985053165[label="writer
[0..1]"];
noqualifiedname1905501234 -> ReadersAndUpdates250830108[label="updates
[0..1]"];
    
}
@enduml